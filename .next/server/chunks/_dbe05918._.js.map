{"version":3,"sources":["turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/is-thenable.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/app-render/module-loading/track-dynamic-import.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/build/webpack/loaders/next-flight-loader/track-dynamic-import.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-server.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/build/webpack/loaders/next-flight-loader/server-reference.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-dom.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/dist/compiled/react-server-dom-turbopack-experimental/cjs/react-server-dom-turbopack-client.node.production.js","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/dist/compiled/react-server-dom-turbopack-experimental/client.node.js","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/route-modules/app-page/vendored/rsc/react-server-dom-turbopack-static.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/page-path/ensure-leading-slash.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/segment.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/router/utils/app-paths.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/app-render/encryption-utils.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/lib/trace/constants.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/lib/trace/tracer.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/lib/detached-promise.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/stream-utils/encoded-tags.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/stream-utils/uint8array-helpers.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/errors/constants.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/segment-cache/output-export-prefetch-encoding.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/stream-utils/node-web-streams-helper.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/app-render/encryption.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/dist/compiled/string-hash/index.js","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/lib/format-server-error.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/request-meta.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/base-http/helpers.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/web/spec-extension/adapters/next-request.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/client-component-renderer-logger.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/pipe-readable.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/client/components/http-access-fallback/http-access-fallback.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/client/components/redirect-status-code.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/client/components/redirect-error.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/client/components/is-next-router-error.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/is-plain-object.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/lib/is-error.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/lib/error-telemetry-utils.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/app-render/react-large-shell-error.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/app-render/create-error-handler.tsx","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/use-cache/constants.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/use-cache/handlers.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/use-cache/use-cache-errors.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/utils/reflect-utils.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/request/search-params.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/lib/lazy-result.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/use-cache/use-cache-wrapper.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/build/webpack/loaders/next-flight-loader/cache-wrapper.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/lib/clone-response.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/lib/dedupe-fetch.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/response-cache/types.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/lib/batcher.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/render-result.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/route-kind.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/response-cache/utils.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/response-cache/index.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/lib/patch-fetch.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/web/spec-extension/unstable-cache.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/router/utils/sorted-routes.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/router/utils/interception-routes.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/router/utils/is-dynamic.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/router/utils/index.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/web/spec-extension/revalidate.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/web/spec-extension/unstable-no-store.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/use-cache/cache-life.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/use-cache/cache-tag.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/cache.js","turbopack:///[project]/lib/constants.ts","turbopack:///[project]/lib/type-guards.ts","turbopack:///[project]/lib/shopify/index.ts","turbopack:///[project]/lib/shopify/fragments/image.ts","turbopack:///[project]/lib/shopify/fragments/seo.ts","turbopack:///[project]/lib/shopify/fragments/product.ts","turbopack:///[project]/lib/shopify/fragments/cart.ts","turbopack:///[project]/lib/shopify/mutations/cart.ts","turbopack:///[project]/lib/shopify/queries/cart.ts","turbopack:///[project]/lib/shopify/queries/collection.ts","turbopack:///[project]/lib/shopify/queries/menu.ts","turbopack:///[project]/lib/shopify/queries/page.ts","turbopack:///[project]/lib/shopify/queries/product.ts"],"sourcesContent":["/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import { InvariantError } from '../../../shared/lib/invariant-error'\nimport { isThenable } from '../../../shared/lib/is-thenable'\nimport { trackPendingImport } from './track-module-loading.external'\n\n/**\n * in CacheComponents, `import(...)` will be transformed into `trackDynamicImport(import(...))`.\n * A dynamic import is essentially a cached async function, except it's cached by the module system.\n *\n * The promises are tracked globally regardless of if the `import()` happens inside a render or outside of it.\n * When rendering, we can make the `cacheSignal` wait for all pending promises via `trackPendingModules`.\n * */\nexport function trackDynamicImport<TExports extends Record<string, any>>(\n  modulePromise: Promise<TExports>\n): Promise<TExports> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      \"Dynamic imports should not be instrumented in the edge runtime, because `cacheComponents` doesn't support it\"\n    )\n  }\n\n  if (!isThenable(modulePromise)) {\n    // We're expecting `import()` to always return a promise. If it's not, something's very wrong.\n    throw new InvariantError(\n      '`trackDynamicImport` should always receive a promise. Something went wrong in the dynamic imports transform.'\n    )\n  }\n\n  // Even if we're inside a prerender and have `workUnitStore.cacheSignal`, we always track the promise globally.\n  // (i.e. via the global `moduleLoadingSignal` that `trackPendingImport` uses internally).\n  //\n  // We do this because the `import()` promise might be cached in userspace:\n  // (which is quite common for e.g. lazy initialization in libraries)\n  //\n  //   let promise;\n  //   function doDynamicImportOnce() {\n  //     if (!promise) {\n  //       promise = import(\"...\");\n  //       // transformed into:\n  //       // promise = trackDynamicImport(import(\"...\"));\n  //     }\n  //     return promise;\n  //   }\n  //\n  // If multiple prerenders (e.g. multiple pages) depend on `doDynamicImportOnce`,\n  // we have to wait for the import *in all of them*.\n  // If we only tracked it using `workUnitStore.cacheSignal.trackRead()`,\n  // then only the first prerender to call `doDynamicImportOnce` would wait --\n  // Subsequent prerenders would re-use the existing `promise`,\n  // and `trackDynamicImport` wouldn't be called again in their scope,\n  // so their respective CacheSignals wouldn't wait for the promise.\n  trackPendingImport(modulePromise)\n\n  return modulePromise\n}\n","export { trackDynamicImport } from '../../../../server/app-render/module-loading/track-dynamic-import'\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackServer\n","/* eslint-disable import/no-extraneous-dependencies */\nexport { registerServerReference } from 'react-server-dom-webpack/server'\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactDOM\n","/**\n * @license React\n * react-server-dom-turbopack-client.node.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nvar util = require(\"util\"),\n  ReactDOM = require(\"react-dom\"),\n  decoderOptions = { stream: !0 },\n  hasOwnProperty = Object.prototype.hasOwnProperty;\nfunction resolveClientReference(bundlerConfig, metadata) {\n  if (bundlerConfig) {\n    var moduleExports = bundlerConfig[metadata[0]];\n    if ((bundlerConfig = moduleExports && moduleExports[metadata[2]]))\n      moduleExports = bundlerConfig.name;\n    else {\n      bundlerConfig = moduleExports && moduleExports[\"*\"];\n      if (!bundlerConfig)\n        throw Error(\n          'Could not find the module \"' +\n            metadata[0] +\n            '\" in the React Server Consumer Manifest. This is probably a bug in the React Server Components bundler.'\n        );\n      moduleExports = metadata[2];\n    }\n    return 4 === metadata.length\n      ? [bundlerConfig.id, bundlerConfig.chunks, moduleExports, 1]\n      : [bundlerConfig.id, bundlerConfig.chunks, moduleExports];\n  }\n  return metadata;\n}\nfunction resolveServerReference(bundlerConfig, id) {\n  var name = \"\",\n    resolvedModuleData = bundlerConfig[id];\n  if (resolvedModuleData) name = resolvedModuleData.name;\n  else {\n    var idx = id.lastIndexOf(\"#\");\n    -1 !== idx &&\n      ((name = id.slice(idx + 1)),\n      (resolvedModuleData = bundlerConfig[id.slice(0, idx)]));\n    if (!resolvedModuleData)\n      throw Error(\n        'Could not find the module \"' +\n          id +\n          '\" in the React Server Manifest. This is probably a bug in the React Server Components bundler.'\n      );\n  }\n  return resolvedModuleData.async\n    ? [resolvedModuleData.id, resolvedModuleData.chunks, name, 1]\n    : [resolvedModuleData.id, resolvedModuleData.chunks, name];\n}\nfunction requireAsyncModule(id) {\n  var promise = globalThis.__next_require__(id);\n  if (\"function\" !== typeof promise.then || \"fulfilled\" === promise.status)\n    return null;\n  promise.then(\n    function (value) {\n      promise.status = \"fulfilled\";\n      promise.value = value;\n    },\n    function (reason) {\n      promise.status = \"rejected\";\n      promise.reason = reason;\n    }\n  );\n  return promise;\n}\nvar instrumentedChunks = new WeakSet(),\n  loadedChunks = new WeakSet();\nfunction ignoreReject() {}\nfunction preloadModule(metadata) {\n  for (var chunks = metadata[1], promises = [], i = 0; i < chunks.length; i++) {\n    var thenable = globalThis.__next_chunk_load__(chunks[i]);\n    loadedChunks.has(thenable) || promises.push(thenable);\n    if (!instrumentedChunks.has(thenable)) {\n      var resolve = loadedChunks.add.bind(loadedChunks, thenable);\n      thenable.then(resolve, ignoreReject);\n      instrumentedChunks.add(thenable);\n    }\n  }\n  return 4 === metadata.length\n    ? 0 === promises.length\n      ? requireAsyncModule(metadata[0])\n      : Promise.all(promises).then(function () {\n          return requireAsyncModule(metadata[0]);\n        })\n    : 0 < promises.length\n      ? Promise.all(promises)\n      : null;\n}\nfunction requireModule(metadata) {\n  var moduleExports = globalThis.__next_require__(metadata[0]);\n  if (4 === metadata.length && \"function\" === typeof moduleExports.then)\n    if (\"fulfilled\" === moduleExports.status)\n      moduleExports = moduleExports.value;\n    else throw moduleExports.reason;\n  if (\"*\" === metadata[2]) return moduleExports;\n  if (\"\" === metadata[2])\n    return moduleExports.__esModule ? moduleExports.default : moduleExports;\n  if (hasOwnProperty.call(moduleExports, metadata[2]))\n    return moduleExports[metadata[2]];\n}\nfunction prepareDestinationWithChunks(moduleLoading, chunks, nonce$jscomp$0) {\n  if (null !== moduleLoading)\n    for (var i = 0; i < chunks.length; i++) {\n      var nonce = nonce$jscomp$0,\n        JSCompiler_temp_const = ReactDOMSharedInternals.d,\n        JSCompiler_temp_const$jscomp$0 = JSCompiler_temp_const.X,\n        JSCompiler_temp_const$jscomp$1 = moduleLoading.prefix + chunks[i];\n      var JSCompiler_inline_result = moduleLoading.crossOrigin;\n      JSCompiler_inline_result =\n        \"string\" === typeof JSCompiler_inline_result\n          ? \"use-credentials\" === JSCompiler_inline_result\n            ? JSCompiler_inline_result\n            : \"\"\n          : void 0;\n      JSCompiler_temp_const$jscomp$0.call(\n        JSCompiler_temp_const,\n        JSCompiler_temp_const$jscomp$1,\n        { crossOrigin: JSCompiler_inline_result, nonce: nonce }\n      );\n    }\n}\nvar ReactDOMSharedInternals =\n    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n  REACT_POSTPONE_TYPE = Symbol.for(\"react.postpone\"),\n  MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[\"@@iterator\"];\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\n}\nvar ASYNC_ITERATOR = Symbol.asyncIterator,\n  isArrayImpl = Array.isArray,\n  getPrototypeOf = Object.getPrototypeOf,\n  ObjectPrototype = Object.prototype,\n  knownServerReferences = new WeakMap();\nfunction serializeNumber(number) {\n  return Number.isFinite(number)\n    ? 0 === number && -Infinity === 1 / number\n      ? \"$-0\"\n      : number\n    : Infinity === number\n      ? \"$Infinity\"\n      : -Infinity === number\n        ? \"$-Infinity\"\n        : \"$NaN\";\n}\nfunction processReply(\n  root,\n  formFieldPrefix,\n  temporaryReferences,\n  resolve,\n  reject\n) {\n  function serializeTypedArray(tag, typedArray) {\n    typedArray = new Blob([\n      new Uint8Array(\n        typedArray.buffer,\n        typedArray.byteOffset,\n        typedArray.byteLength\n      )\n    ]);\n    var blobId = nextPartId++;\n    null === formData && (formData = new FormData());\n    formData.append(formFieldPrefix + blobId, typedArray);\n    return \"$\" + tag + blobId.toString(16);\n  }\n  function serializeBinaryReader(reader) {\n    function progress(entry) {\n      entry.done\n        ? ((entry = nextPartId++),\n          data.append(formFieldPrefix + entry, new Blob(buffer)),\n          data.append(\n            formFieldPrefix + streamId,\n            '\"$o' + entry.toString(16) + '\"'\n          ),\n          data.append(formFieldPrefix + streamId, \"C\"),\n          pendingParts--,\n          0 === pendingParts && resolve(data))\n        : (buffer.push(entry.value),\n          reader.read(new Uint8Array(1024)).then(progress, reject));\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++,\n      buffer = [];\n    reader.read(new Uint8Array(1024)).then(progress, reject);\n    return \"$r\" + streamId.toString(16);\n  }\n  function serializeReader(reader) {\n    function progress(entry) {\n      if (entry.done)\n        data.append(formFieldPrefix + streamId, \"C\"),\n          pendingParts--,\n          0 === pendingParts && resolve(data);\n      else\n        try {\n          var partJSON = JSON.stringify(entry.value, resolveToJSON);\n          data.append(formFieldPrefix + streamId, partJSON);\n          reader.read().then(progress, reject);\n        } catch (x) {\n          reject(x);\n        }\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++;\n    reader.read().then(progress, reject);\n    return \"$R\" + streamId.toString(16);\n  }\n  function serializeReadableStream(stream) {\n    try {\n      var binaryReader = stream.getReader({ mode: \"byob\" });\n    } catch (x) {\n      return serializeReader(stream.getReader());\n    }\n    return serializeBinaryReader(binaryReader);\n  }\n  function serializeAsyncIterable(iterable, iterator) {\n    function progress(entry) {\n      if (entry.done) {\n        if (void 0 === entry.value)\n          data.append(formFieldPrefix + streamId, \"C\");\n        else\n          try {\n            var partJSON = JSON.stringify(entry.value, resolveToJSON);\n            data.append(formFieldPrefix + streamId, \"C\" + partJSON);\n          } catch (x) {\n            reject(x);\n            return;\n          }\n        pendingParts--;\n        0 === pendingParts && resolve(data);\n      } else\n        try {\n          var partJSON$21 = JSON.stringify(entry.value, resolveToJSON);\n          data.append(formFieldPrefix + streamId, partJSON$21);\n          iterator.next().then(progress, reject);\n        } catch (x$22) {\n          reject(x$22);\n        }\n    }\n    null === formData && (formData = new FormData());\n    var data = formData;\n    pendingParts++;\n    var streamId = nextPartId++;\n    iterable = iterable === iterator;\n    iterator.next().then(progress, reject);\n    return \"$\" + (iterable ? \"x\" : \"X\") + streamId.toString(16);\n  }\n  function resolveToJSON(key, value) {\n    if (null === value) return null;\n    if (\"object\" === typeof value) {\n      switch (value.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          if (void 0 !== temporaryReferences && -1 === key.indexOf(\":\")) {\n            var parentReference = writtenObjects.get(this);\n            if (void 0 !== parentReference)\n              return (\n                temporaryReferences.set(parentReference + \":\" + key, value),\n                \"$T\"\n              );\n          }\n          throw Error(\n            \"React Element cannot be passed to Server Functions from the Client without a temporary reference set. Pass a TemporaryReferenceSet to the options.\"\n          );\n        case REACT_LAZY_TYPE:\n          parentReference = value._payload;\n          var init = value._init;\n          null === formData && (formData = new FormData());\n          pendingParts++;\n          try {\n            var resolvedModel = init(parentReference),\n              lazyId = nextPartId++,\n              partJSON = serializeModel(resolvedModel, lazyId);\n            formData.append(formFieldPrefix + lazyId, partJSON);\n            return \"$\" + lazyId.toString(16);\n          } catch (x) {\n            if (\n              \"object\" === typeof x &&\n              null !== x &&\n              \"function\" === typeof x.then\n            ) {\n              pendingParts++;\n              var lazyId$23 = nextPartId++;\n              parentReference = function () {\n                try {\n                  var partJSON$24 = serializeModel(value, lazyId$23),\n                    data$25 = formData;\n                  data$25.append(formFieldPrefix + lazyId$23, partJSON$24);\n                  pendingParts--;\n                  0 === pendingParts && resolve(data$25);\n                } catch (reason) {\n                  reject(reason);\n                }\n              };\n              x.then(parentReference, parentReference);\n              return \"$\" + lazyId$23.toString(16);\n            }\n            reject(x);\n            return null;\n          } finally {\n            pendingParts--;\n          }\n      }\n      parentReference = writtenObjects.get(value);\n      if (\"function\" === typeof value.then) {\n        if (void 0 !== parentReference)\n          if (modelRoot === value) modelRoot = null;\n          else return parentReference;\n        null === formData && (formData = new FormData());\n        pendingParts++;\n        var promiseId = nextPartId++;\n        key = \"$@\" + promiseId.toString(16);\n        writtenObjects.set(value, key);\n        value.then(function (partValue) {\n          try {\n            var previousReference = writtenObjects.get(partValue);\n            var partJSON$27 =\n              void 0 !== previousReference\n                ? JSON.stringify(previousReference)\n                : serializeModel(partValue, promiseId);\n            partValue = formData;\n            partValue.append(formFieldPrefix + promiseId, partJSON$27);\n            pendingParts--;\n            0 === pendingParts && resolve(partValue);\n          } catch (reason) {\n            reject(reason);\n          }\n        }, reject);\n        return key;\n      }\n      if (void 0 !== parentReference)\n        if (modelRoot === value) modelRoot = null;\n        else return parentReference;\n      else\n        -1 === key.indexOf(\":\") &&\n          ((parentReference = writtenObjects.get(this)),\n          void 0 !== parentReference &&\n            ((key = parentReference + \":\" + key),\n            writtenObjects.set(value, key),\n            void 0 !== temporaryReferences &&\n              temporaryReferences.set(key, value)));\n      if (isArrayImpl(value)) return value;\n      if (value instanceof FormData) {\n        null === formData && (formData = new FormData());\n        var data$31 = formData;\n        key = nextPartId++;\n        var prefix = formFieldPrefix + key + \"_\";\n        value.forEach(function (originalValue, originalKey) {\n          data$31.append(prefix + originalKey, originalValue);\n        });\n        return \"$K\" + key.toString(16);\n      }\n      if (value instanceof Map)\n        return (\n          (key = nextPartId++),\n          (parentReference = serializeModel(Array.from(value), key)),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + key, parentReference),\n          \"$Q\" + key.toString(16)\n        );\n      if (value instanceof Set)\n        return (\n          (key = nextPartId++),\n          (parentReference = serializeModel(Array.from(value), key)),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + key, parentReference),\n          \"$W\" + key.toString(16)\n        );\n      if (value instanceof ArrayBuffer)\n        return (\n          (key = new Blob([value])),\n          (parentReference = nextPartId++),\n          null === formData && (formData = new FormData()),\n          formData.append(formFieldPrefix + parentReference, key),\n          \"$A\" + parentReference.toString(16)\n        );\n      if (value instanceof Int8Array) return serializeTypedArray(\"O\", value);\n      if (value instanceof Uint8Array) return serializeTypedArray(\"o\", value);\n      if (value instanceof Uint8ClampedArray)\n        return serializeTypedArray(\"U\", value);\n      if (value instanceof Int16Array) return serializeTypedArray(\"S\", value);\n      if (value instanceof Uint16Array) return serializeTypedArray(\"s\", value);\n      if (value instanceof Int32Array) return serializeTypedArray(\"L\", value);\n      if (value instanceof Uint32Array) return serializeTypedArray(\"l\", value);\n      if (value instanceof Float32Array) return serializeTypedArray(\"G\", value);\n      if (value instanceof Float64Array) return serializeTypedArray(\"g\", value);\n      if (value instanceof BigInt64Array)\n        return serializeTypedArray(\"M\", value);\n      if (value instanceof BigUint64Array)\n        return serializeTypedArray(\"m\", value);\n      if (value instanceof DataView) return serializeTypedArray(\"V\", value);\n      if (\"function\" === typeof Blob && value instanceof Blob)\n        return (\n          null === formData && (formData = new FormData()),\n          (key = nextPartId++),\n          formData.append(formFieldPrefix + key, value),\n          \"$B\" + key.toString(16)\n        );\n      if ((key = getIteratorFn(value)))\n        return (\n          (parentReference = key.call(value)),\n          parentReference === value\n            ? ((key = nextPartId++),\n              (parentReference = serializeModel(\n                Array.from(parentReference),\n                key\n              )),\n              null === formData && (formData = new FormData()),\n              formData.append(formFieldPrefix + key, parentReference),\n              \"$i\" + key.toString(16))\n            : Array.from(parentReference)\n        );\n      if (\n        \"function\" === typeof ReadableStream &&\n        value instanceof ReadableStream\n      )\n        return serializeReadableStream(value);\n      key = value[ASYNC_ITERATOR];\n      if (\"function\" === typeof key)\n        return serializeAsyncIterable(value, key.call(value));\n      key = getPrototypeOf(value);\n      if (\n        key !== ObjectPrototype &&\n        (null === key || null !== getPrototypeOf(key))\n      ) {\n        if (void 0 === temporaryReferences)\n          throw Error(\n            \"Only plain objects, and a few built-ins, can be passed to Server Functions. Classes or null prototypes are not supported.\"\n          );\n        return \"$T\";\n      }\n      return value;\n    }\n    if (\"string\" === typeof value) {\n      if (\"Z\" === value[value.length - 1] && this[key] instanceof Date)\n        return \"$D\" + value;\n      key = \"$\" === value[0] ? \"$\" + value : value;\n      return key;\n    }\n    if (\"boolean\" === typeof value) return value;\n    if (\"number\" === typeof value) return serializeNumber(value);\n    if (\"undefined\" === typeof value) return \"$undefined\";\n    if (\"function\" === typeof value) {\n      parentReference = knownServerReferences.get(value);\n      if (void 0 !== parentReference)\n        return (\n          (key = JSON.stringify(\n            { id: parentReference.id, bound: parentReference.bound },\n            resolveToJSON\n          )),\n          null === formData && (formData = new FormData()),\n          (parentReference = nextPartId++),\n          formData.set(formFieldPrefix + parentReference, key),\n          \"$h\" + parentReference.toString(16)\n        );\n      if (\n        void 0 !== temporaryReferences &&\n        -1 === key.indexOf(\":\") &&\n        ((parentReference = writtenObjects.get(this)),\n        void 0 !== parentReference)\n      )\n        return (\n          temporaryReferences.set(parentReference + \":\" + key, value), \"$T\"\n        );\n      throw Error(\n        \"Client Functions cannot be passed directly to Server Functions. Only Functions passed from the Server can be passed back again.\"\n      );\n    }\n    if (\"symbol\" === typeof value) {\n      if (\n        void 0 !== temporaryReferences &&\n        -1 === key.indexOf(\":\") &&\n        ((parentReference = writtenObjects.get(this)),\n        void 0 !== parentReference)\n      )\n        return (\n          temporaryReferences.set(parentReference + \":\" + key, value), \"$T\"\n        );\n      throw Error(\n        \"Symbols cannot be passed to a Server Function without a temporary reference set. Pass a TemporaryReferenceSet to the options.\"\n      );\n    }\n    if (\"bigint\" === typeof value) return \"$n\" + value.toString(10);\n    throw Error(\n      \"Type \" +\n        typeof value +\n        \" is not supported as an argument to a Server Function.\"\n    );\n  }\n  function serializeModel(model, id) {\n    \"object\" === typeof model &&\n      null !== model &&\n      ((id = \"$\" + id.toString(16)),\n      writtenObjects.set(model, id),\n      void 0 !== temporaryReferences && temporaryReferences.set(id, model));\n    modelRoot = model;\n    return JSON.stringify(model, resolveToJSON);\n  }\n  var nextPartId = 1,\n    pendingParts = 0,\n    formData = null,\n    writtenObjects = new WeakMap(),\n    modelRoot = root,\n    json = serializeModel(root, 0);\n  null === formData\n    ? resolve(json)\n    : (formData.set(formFieldPrefix + \"0\", json),\n      0 === pendingParts && resolve(formData));\n  return function () {\n    0 < pendingParts &&\n      ((pendingParts = 0),\n      null === formData ? resolve(json) : resolve(formData));\n  };\n}\nvar boundCache = new WeakMap();\nfunction encodeFormData(reference) {\n  var resolve,\n    reject,\n    thenable = new Promise(function (res, rej) {\n      resolve = res;\n      reject = rej;\n    });\n  processReply(\n    reference,\n    \"\",\n    void 0,\n    function (body) {\n      if (\"string\" === typeof body) {\n        var data = new FormData();\n        data.append(\"0\", body);\n        body = data;\n      }\n      thenable.status = \"fulfilled\";\n      thenable.value = body;\n      resolve(body);\n    },\n    function (e) {\n      thenable.status = \"rejected\";\n      thenable.reason = e;\n      reject(e);\n    }\n  );\n  return thenable;\n}\nfunction defaultEncodeFormAction(identifierPrefix) {\n  var referenceClosure = knownServerReferences.get(this);\n  if (!referenceClosure)\n    throw Error(\n      \"Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.\"\n    );\n  var data = null;\n  if (null !== referenceClosure.bound) {\n    data = boundCache.get(referenceClosure);\n    data ||\n      ((data = encodeFormData({\n        id: referenceClosure.id,\n        bound: referenceClosure.bound\n      })),\n      boundCache.set(referenceClosure, data));\n    if (\"rejected\" === data.status) throw data.reason;\n    if (\"fulfilled\" !== data.status) throw data;\n    referenceClosure = data.value;\n    var prefixedData = new FormData();\n    referenceClosure.forEach(function (value, key) {\n      prefixedData.append(\"$ACTION_\" + identifierPrefix + \":\" + key, value);\n    });\n    data = prefixedData;\n    referenceClosure = \"$ACTION_REF_\" + identifierPrefix;\n  } else referenceClosure = \"$ACTION_ID_\" + referenceClosure.id;\n  return {\n    name: referenceClosure,\n    method: \"POST\",\n    encType: \"multipart/form-data\",\n    data: data\n  };\n}\nfunction isSignatureEqual(referenceId, numberOfBoundArgs) {\n  var referenceClosure = knownServerReferences.get(this);\n  if (!referenceClosure)\n    throw Error(\n      \"Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.\"\n    );\n  if (referenceClosure.id !== referenceId) return !1;\n  var boundPromise = referenceClosure.bound;\n  if (null === boundPromise) return 0 === numberOfBoundArgs;\n  switch (boundPromise.status) {\n    case \"fulfilled\":\n      return boundPromise.value.length === numberOfBoundArgs;\n    case \"pending\":\n      throw boundPromise;\n    case \"rejected\":\n      throw boundPromise.reason;\n    default:\n      throw (\n        (\"string\" !== typeof boundPromise.status &&\n          ((boundPromise.status = \"pending\"),\n          boundPromise.then(\n            function (boundArgs) {\n              boundPromise.status = \"fulfilled\";\n              boundPromise.value = boundArgs;\n            },\n            function (error) {\n              boundPromise.status = \"rejected\";\n              boundPromise.reason = error;\n            }\n          )),\n        boundPromise)\n      );\n  }\n}\nfunction registerBoundServerReference(reference, id, bound, encodeFormAction) {\n  knownServerReferences.has(reference) ||\n    (knownServerReferences.set(reference, {\n      id: id,\n      originalBind: reference.bind,\n      bound: bound\n    }),\n    Object.defineProperties(reference, {\n      $$FORM_ACTION: {\n        value:\n          void 0 === encodeFormAction\n            ? defaultEncodeFormAction\n            : function () {\n                var referenceClosure = knownServerReferences.get(this);\n                if (!referenceClosure)\n                  throw Error(\n                    \"Tried to encode a Server Action from a different instance than the encoder is from. This is a bug in React.\"\n                  );\n                var boundPromise = referenceClosure.bound;\n                null === boundPromise && (boundPromise = Promise.resolve([]));\n                return encodeFormAction(referenceClosure.id, boundPromise);\n              }\n      },\n      $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },\n      bind: { value: bind }\n    }));\n}\nvar FunctionBind = Function.prototype.bind,\n  ArraySlice = Array.prototype.slice;\nfunction bind() {\n  var referenceClosure = knownServerReferences.get(this);\n  if (!referenceClosure) return FunctionBind.apply(this, arguments);\n  var newFn = referenceClosure.originalBind.apply(this, arguments),\n    args = ArraySlice.call(arguments, 1),\n    boundPromise = null;\n  boundPromise =\n    null !== referenceClosure.bound\n      ? Promise.resolve(referenceClosure.bound).then(function (boundArgs) {\n          return boundArgs.concat(args);\n        })\n      : Promise.resolve(args);\n  knownServerReferences.set(newFn, {\n    id: referenceClosure.id,\n    originalBind: newFn.bind,\n    bound: boundPromise\n  });\n  Object.defineProperties(newFn, {\n    $$FORM_ACTION: { value: this.$$FORM_ACTION },\n    $$IS_SIGNATURE_EQUAL: { value: isSignatureEqual },\n    bind: { value: bind }\n  });\n  return newFn;\n}\nfunction createBoundServerReference(metaData, callServer, encodeFormAction) {\n  function action() {\n    var args = Array.prototype.slice.call(arguments);\n    return bound\n      ? \"fulfilled\" === bound.status\n        ? callServer(id, bound.value.concat(args))\n        : Promise.resolve(bound).then(function (boundArgs) {\n            return callServer(id, boundArgs.concat(args));\n          })\n      : callServer(id, args);\n  }\n  var id = metaData.id,\n    bound = metaData.bound;\n  registerBoundServerReference(action, id, bound, encodeFormAction);\n  return action;\n}\nfunction createServerReference$1(id, callServer, encodeFormAction) {\n  function action() {\n    var args = Array.prototype.slice.call(arguments);\n    return callServer(id, args);\n  }\n  registerBoundServerReference(action, id, null, encodeFormAction);\n  return action;\n}\nfunction ReactPromise(status, value, reason) {\n  this.status = status;\n  this.value = value;\n  this.reason = reason;\n}\nReactPromise.prototype = Object.create(Promise.prototype);\nReactPromise.prototype.then = function (resolve, reject) {\n  switch (this.status) {\n    case \"resolved_model\":\n      initializeModelChunk(this);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(this);\n  }\n  switch (this.status) {\n    case \"fulfilled\":\n      \"function\" === typeof resolve && resolve(this.value);\n      break;\n    case \"pending\":\n    case \"blocked\":\n      \"function\" === typeof resolve &&\n        (null === this.value && (this.value = []), this.value.push(resolve));\n      \"function\" === typeof reject &&\n        (null === this.reason && (this.reason = []), this.reason.push(reject));\n      break;\n    case \"halted\":\n      break;\n    default:\n      \"function\" === typeof reject && reject(this.reason);\n  }\n};\nfunction readChunk(chunk) {\n  switch (chunk.status) {\n    case \"resolved_model\":\n      initializeModelChunk(chunk);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(chunk);\n  }\n  switch (chunk.status) {\n    case \"fulfilled\":\n      return chunk.value;\n    case \"pending\":\n    case \"blocked\":\n    case \"halted\":\n      throw chunk;\n    default:\n      throw chunk.reason;\n  }\n}\nfunction createErrorChunk(response, error) {\n  return new ReactPromise(\"rejected\", null, error);\n}\nfunction wakeChunk(listeners, value, chunk) {\n  for (var i = 0; i < listeners.length; i++) {\n    var listener = listeners[i];\n    \"function\" === typeof listener\n      ? listener(value)\n      : fulfillReference(listener, value, chunk);\n  }\n}\nfunction rejectChunk(listeners, error) {\n  for (var i = 0; i < listeners.length; i++) {\n    var listener = listeners[i];\n    \"function\" === typeof listener\n      ? listener(error)\n      : rejectReference(listener, error);\n  }\n}\nfunction resolveBlockedCycle(resolvedChunk, reference) {\n  var referencedChunk = reference.handler.chunk;\n  if (null === referencedChunk) return null;\n  if (referencedChunk === resolvedChunk) return reference.handler;\n  reference = referencedChunk.value;\n  if (null !== reference)\n    for (\n      referencedChunk = 0;\n      referencedChunk < reference.length;\n      referencedChunk++\n    ) {\n      var listener = reference[referencedChunk];\n      if (\n        \"function\" !== typeof listener &&\n        ((listener = resolveBlockedCycle(resolvedChunk, listener)),\n        null !== listener)\n      )\n        return listener;\n    }\n  return null;\n}\nfunction wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners) {\n  switch (chunk.status) {\n    case \"fulfilled\":\n      wakeChunk(resolveListeners, chunk.value, chunk);\n      break;\n    case \"blocked\":\n      for (var i = 0; i < resolveListeners.length; i++) {\n        var listener = resolveListeners[i];\n        if (\"function\" !== typeof listener) {\n          var cyclicHandler = resolveBlockedCycle(chunk, listener);\n          null !== cyclicHandler &&\n            (fulfillReference(listener, cyclicHandler.value, chunk),\n            resolveListeners.splice(i, 1),\n            i--,\n            null !== rejectListeners &&\n              ((listener = rejectListeners.indexOf(listener)),\n              -1 !== listener && rejectListeners.splice(listener, 1)));\n        }\n      }\n    case \"pending\":\n      if (chunk.value)\n        for (i = 0; i < resolveListeners.length; i++)\n          chunk.value.push(resolveListeners[i]);\n      else chunk.value = resolveListeners;\n      if (chunk.reason) {\n        if (rejectListeners)\n          for (\n            resolveListeners = 0;\n            resolveListeners < rejectListeners.length;\n            resolveListeners++\n          )\n            chunk.reason.push(rejectListeners[resolveListeners]);\n      } else chunk.reason = rejectListeners;\n      break;\n    case \"rejected\":\n      rejectListeners && rejectChunk(rejectListeners, chunk.reason);\n  }\n}\nfunction triggerErrorOnChunk(response, chunk, error) {\n  \"pending\" !== chunk.status && \"blocked\" !== chunk.status\n    ? chunk.reason.error(error)\n    : ((response = chunk.reason),\n      (chunk.status = \"rejected\"),\n      (chunk.reason = error),\n      null !== response && rejectChunk(response, error));\n}\nfunction createResolvedIteratorResultChunk(response, value, done) {\n  return new ReactPromise(\n    \"resolved_model\",\n    (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\",\n    response\n  );\n}\nfunction resolveIteratorResultChunk(response, chunk, value, done) {\n  resolveModelChunk(\n    response,\n    chunk,\n    (done ? '{\"done\":true,\"value\":' : '{\"done\":false,\"value\":') + value + \"}\"\n  );\n}\nfunction resolveModelChunk(response, chunk, value) {\n  if (\"pending\" !== chunk.status) chunk.reason.enqueueModel(value);\n  else {\n    var resolveListeners = chunk.value,\n      rejectListeners = chunk.reason;\n    chunk.status = \"resolved_model\";\n    chunk.value = value;\n    chunk.reason = response;\n    null !== resolveListeners &&\n      (initializeModelChunk(chunk),\n      wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners));\n  }\n}\nfunction resolveModuleChunk(response, chunk, value) {\n  if (\"pending\" === chunk.status || \"blocked\" === chunk.status) {\n    response = chunk.value;\n    var rejectListeners = chunk.reason;\n    chunk.status = \"resolved_module\";\n    chunk.value = value;\n    chunk.reason = null;\n    null !== response &&\n      (initializeModuleChunk(chunk),\n      wakeChunkIfInitialized(chunk, response, rejectListeners));\n  }\n}\nvar initializingHandler = null;\nfunction initializeModelChunk(chunk) {\n  var prevHandler = initializingHandler;\n  initializingHandler = null;\n  var resolvedModel = chunk.value,\n    response = chunk.reason;\n  chunk.status = \"blocked\";\n  chunk.value = null;\n  chunk.reason = null;\n  try {\n    var value = JSON.parse(resolvedModel, response._fromJSON),\n      resolveListeners = chunk.value;\n    if (null !== resolveListeners)\n      for (\n        chunk.value = null, chunk.reason = null, resolvedModel = 0;\n        resolvedModel < resolveListeners.length;\n        resolvedModel++\n      ) {\n        var listener = resolveListeners[resolvedModel];\n        \"function\" === typeof listener\n          ? listener(value)\n          : fulfillReference(listener, value, chunk);\n      }\n    if (null !== initializingHandler) {\n      if (initializingHandler.errored) throw initializingHandler.reason;\n      if (0 < initializingHandler.deps) {\n        initializingHandler.value = value;\n        initializingHandler.chunk = chunk;\n        return;\n      }\n    }\n    chunk.status = \"fulfilled\";\n    chunk.value = value;\n  } catch (error) {\n    (chunk.status = \"rejected\"), (chunk.reason = error);\n  } finally {\n    initializingHandler = prevHandler;\n  }\n}\nfunction initializeModuleChunk(chunk) {\n  try {\n    var value = requireModule(chunk.value);\n    chunk.status = \"fulfilled\";\n    chunk.value = value;\n  } catch (error) {\n    (chunk.status = \"rejected\"), (chunk.reason = error);\n  }\n}\nfunction reportGlobalError(weakResponse, error) {\n  weakResponse._closed = !0;\n  weakResponse._closedReason = error;\n  weakResponse._chunks.forEach(function (chunk) {\n    \"pending\" === chunk.status\n      ? triggerErrorOnChunk(weakResponse, chunk, error)\n      : \"fulfilled\" === chunk.status &&\n        null !== chunk.reason &&\n        chunk.reason.error(error);\n  });\n}\nfunction createLazyChunkWrapper(chunk) {\n  return { $$typeof: REACT_LAZY_TYPE, _payload: chunk, _init: readChunk };\n}\nfunction getChunk(response, id) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  chunk ||\n    ((chunk = response._closed\n      ? createErrorChunk(response, response._closedReason)\n      : new ReactPromise(\"pending\", null, null)),\n    chunks.set(id, chunk));\n  return chunk;\n}\nfunction fulfillReference(reference, value) {\n  var response = reference.response,\n    handler = reference.handler,\n    parentObject = reference.parentObject,\n    key = reference.key,\n    map = reference.map,\n    path = reference.path;\n  try {\n    for (var i = 1; i < path.length; i++) {\n      for (\n        ;\n        \"object\" === typeof value &&\n        null !== value &&\n        value.$$typeof === REACT_LAZY_TYPE;\n\n      ) {\n        var referencedChunk = value._payload;\n        if (referencedChunk === handler.chunk) value = handler.value;\n        else {\n          switch (referencedChunk.status) {\n            case \"resolved_model\":\n              initializeModelChunk(referencedChunk);\n              break;\n            case \"resolved_module\":\n              initializeModuleChunk(referencedChunk);\n          }\n          switch (referencedChunk.status) {\n            case \"fulfilled\":\n              value = referencedChunk.value;\n              continue;\n            case \"blocked\":\n              var cyclicHandler = resolveBlockedCycle(\n                referencedChunk,\n                reference\n              );\n              if (null !== cyclicHandler) {\n                value = cyclicHandler.value;\n                continue;\n              }\n            case \"pending\":\n              path.splice(0, i - 1);\n              null === referencedChunk.value\n                ? (referencedChunk.value = [reference])\n                : referencedChunk.value.push(reference);\n              null === referencedChunk.reason\n                ? (referencedChunk.reason = [reference])\n                : referencedChunk.reason.push(reference);\n              return;\n            case \"halted\":\n              return;\n            default:\n              rejectReference(\n                response,\n                reference.handler,\n                referencedChunk.reason\n              );\n              return;\n          }\n        }\n      }\n      value = value[path[i]];\n    }\n    for (\n      ;\n      \"object\" === typeof value &&\n      null !== value &&\n      value.$$typeof === REACT_LAZY_TYPE;\n\n    ) {\n      var referencedChunk$43 = value._payload;\n      if (referencedChunk$43 === handler.chunk) value = handler.value;\n      else {\n        switch (referencedChunk$43.status) {\n          case \"resolved_model\":\n            initializeModelChunk(referencedChunk$43);\n            break;\n          case \"resolved_module\":\n            initializeModuleChunk(referencedChunk$43);\n        }\n        switch (referencedChunk$43.status) {\n          case \"fulfilled\":\n            value = referencedChunk$43.value;\n            continue;\n        }\n        break;\n      }\n    }\n    var mappedValue = map(response, value, parentObject, key);\n    parentObject[key] = mappedValue;\n    \"\" === key && null === handler.value && (handler.value = mappedValue);\n    if (\n      parentObject[0] === REACT_ELEMENT_TYPE &&\n      \"object\" === typeof handler.value &&\n      null !== handler.value &&\n      handler.value.$$typeof === REACT_ELEMENT_TYPE\n    ) {\n      var element = handler.value;\n      switch (key) {\n        case \"3\":\n          element.props = mappedValue;\n      }\n    }\n  } catch (error) {\n    rejectReference(response, reference.handler);\n    return;\n  }\n  handler.deps--;\n  0 === handler.deps &&\n    ((reference = handler.chunk),\n    null !== reference &&\n      \"blocked\" === reference.status &&\n      ((value = reference.value),\n      (reference.status = \"fulfilled\"),\n      (reference.value = handler.value),\n      (reference.reason = handler.reason),\n      null !== value && wakeChunk(value, handler.value, reference)));\n}\nfunction rejectReference(reference, error) {\n  var handler = reference.handler;\n  reference = reference.response;\n  handler.errored ||\n    ((handler.errored = !0),\n    (handler.value = null),\n    (handler.reason = error),\n    (handler = handler.chunk),\n    null !== handler &&\n      \"blocked\" === handler.status &&\n      triggerErrorOnChunk(reference, handler, error));\n}\nfunction waitForReference(\n  referencedChunk,\n  parentObject,\n  key,\n  response,\n  map,\n  path\n) {\n  if (initializingHandler) {\n    var handler = initializingHandler;\n    handler.deps++;\n  } else\n    handler = initializingHandler = {\n      parent: null,\n      chunk: null,\n      value: null,\n      reason: null,\n      deps: 1,\n      errored: !1\n    };\n  parentObject = {\n    response: response,\n    handler: handler,\n    parentObject: parentObject,\n    key: key,\n    map: map,\n    path: path\n  };\n  null === referencedChunk.value\n    ? (referencedChunk.value = [parentObject])\n    : referencedChunk.value.push(parentObject);\n  null === referencedChunk.reason\n    ? (referencedChunk.reason = [parentObject])\n    : referencedChunk.reason.push(parentObject);\n  return null;\n}\nfunction loadServerReference(response, metaData, parentObject, key) {\n  if (!response._serverReferenceConfig)\n    return createBoundServerReference(\n      metaData,\n      response._callServer,\n      response._encodeFormAction\n    );\n  var serverReference = resolveServerReference(\n      response._serverReferenceConfig,\n      metaData.id\n    ),\n    promise = preloadModule(serverReference);\n  if (promise)\n    metaData.bound && (promise = Promise.all([promise, metaData.bound]));\n  else if (metaData.bound) promise = Promise.resolve(metaData.bound);\n  else\n    return (\n      (promise = requireModule(serverReference)),\n      registerBoundServerReference(\n        promise,\n        metaData.id,\n        metaData.bound,\n        response._encodeFormAction\n      ),\n      promise\n    );\n  if (initializingHandler) {\n    var handler = initializingHandler;\n    handler.deps++;\n  } else\n    handler = initializingHandler = {\n      parent: null,\n      chunk: null,\n      value: null,\n      reason: null,\n      deps: 1,\n      errored: !1\n    };\n  promise.then(\n    function () {\n      var resolvedValue = requireModule(serverReference);\n      if (metaData.bound) {\n        var boundArgs = metaData.bound.value.slice(0);\n        boundArgs.unshift(null);\n        resolvedValue = resolvedValue.bind.apply(resolvedValue, boundArgs);\n      }\n      registerBoundServerReference(\n        resolvedValue,\n        metaData.id,\n        metaData.bound,\n        response._encodeFormAction\n      );\n      parentObject[key] = resolvedValue;\n      \"\" === key && null === handler.value && (handler.value = resolvedValue);\n      if (\n        parentObject[0] === REACT_ELEMENT_TYPE &&\n        \"object\" === typeof handler.value &&\n        null !== handler.value &&\n        handler.value.$$typeof === REACT_ELEMENT_TYPE\n      )\n        switch (((boundArgs = handler.value), key)) {\n          case \"3\":\n            boundArgs.props = resolvedValue;\n        }\n      handler.deps--;\n      0 === handler.deps &&\n        ((resolvedValue = handler.chunk),\n        null !== resolvedValue &&\n          \"blocked\" === resolvedValue.status &&\n          ((boundArgs = resolvedValue.value),\n          (resolvedValue.status = \"fulfilled\"),\n          (resolvedValue.value = handler.value),\n          (resolvedValue.reason = null),\n          null !== boundArgs &&\n            wakeChunk(boundArgs, handler.value, resolvedValue)));\n    },\n    function (error) {\n      if (!handler.errored) {\n        handler.errored = !0;\n        handler.value = null;\n        handler.reason = error;\n        var chunk = handler.chunk;\n        null !== chunk &&\n          \"blocked\" === chunk.status &&\n          triggerErrorOnChunk(response, chunk, error);\n      }\n    }\n  );\n  return null;\n}\nfunction getOutlinedModel(response, reference, parentObject, key, map) {\n  reference = reference.split(\":\");\n  var id = parseInt(reference[0], 16);\n  id = getChunk(response, id);\n  switch (id.status) {\n    case \"resolved_model\":\n      initializeModelChunk(id);\n      break;\n    case \"resolved_module\":\n      initializeModuleChunk(id);\n  }\n  switch (id.status) {\n    case \"fulfilled\":\n      id = id.value;\n      for (var i = 1; i < reference.length; i++) {\n        for (\n          ;\n          \"object\" === typeof id &&\n          null !== id &&\n          id.$$typeof === REACT_LAZY_TYPE;\n\n        ) {\n          id = id._payload;\n          switch (id.status) {\n            case \"resolved_model\":\n              initializeModelChunk(id);\n              break;\n            case \"resolved_module\":\n              initializeModuleChunk(id);\n          }\n          switch (id.status) {\n            case \"fulfilled\":\n              id = id.value;\n              break;\n            case \"blocked\":\n            case \"pending\":\n              return waitForReference(\n                id,\n                parentObject,\n                key,\n                response,\n                map,\n                reference.slice(i - 1)\n              );\n            case \"halted\":\n              return (\n                initializingHandler\n                  ? ((response = initializingHandler), response.deps++)\n                  : (initializingHandler = {\n                      parent: null,\n                      chunk: null,\n                      value: null,\n                      reason: null,\n                      deps: 1,\n                      errored: !1\n                    }),\n                null\n              );\n            default:\n              return (\n                initializingHandler\n                  ? ((initializingHandler.errored = !0),\n                    (initializingHandler.value = null),\n                    (initializingHandler.reason = id.reason))\n                  : (initializingHandler = {\n                      parent: null,\n                      chunk: null,\n                      value: null,\n                      reason: id.reason,\n                      deps: 0,\n                      errored: !0\n                    }),\n                null\n              );\n          }\n        }\n        id = id[reference[i]];\n      }\n      for (\n        ;\n        \"object\" === typeof id &&\n        null !== id &&\n        id.$$typeof === REACT_LAZY_TYPE;\n\n      ) {\n        reference = id._payload;\n        switch (reference.status) {\n          case \"resolved_model\":\n            initializeModelChunk(reference);\n            break;\n          case \"resolved_module\":\n            initializeModuleChunk(reference);\n        }\n        switch (reference.status) {\n          case \"fulfilled\":\n            id = reference.value;\n            continue;\n        }\n        break;\n      }\n      return map(response, id, parentObject, key);\n    case \"pending\":\n    case \"blocked\":\n      return waitForReference(id, parentObject, key, response, map, reference);\n    case \"halted\":\n      return (\n        initializingHandler\n          ? ((response = initializingHandler), response.deps++)\n          : (initializingHandler = {\n              parent: null,\n              chunk: null,\n              value: null,\n              reason: null,\n              deps: 1,\n              errored: !1\n            }),\n        null\n      );\n    default:\n      return (\n        initializingHandler\n          ? ((initializingHandler.errored = !0),\n            (initializingHandler.value = null),\n            (initializingHandler.reason = id.reason))\n          : (initializingHandler = {\n              parent: null,\n              chunk: null,\n              value: null,\n              reason: id.reason,\n              deps: 0,\n              errored: !0\n            }),\n        null\n      );\n  }\n}\nfunction createMap(response, model) {\n  return new Map(model);\n}\nfunction createSet(response, model) {\n  return new Set(model);\n}\nfunction createBlob(response, model) {\n  return new Blob(model.slice(1), { type: model[0] });\n}\nfunction createFormData(response, model) {\n  response = new FormData();\n  for (var i = 0; i < model.length; i++)\n    response.append(model[i][0], model[i][1]);\n  return response;\n}\nfunction extractIterator(response, model) {\n  return model[Symbol.iterator]();\n}\nfunction createModel(response, model) {\n  return model;\n}\nfunction parseModelString(response, parentObject, key, value) {\n  if (\"$\" === value[0]) {\n    if (\"$\" === value)\n      return (\n        null !== initializingHandler &&\n          \"0\" === key &&\n          (initializingHandler = {\n            parent: initializingHandler,\n            chunk: null,\n            value: null,\n            reason: null,\n            deps: 0,\n            errored: !1\n          }),\n        REACT_ELEMENT_TYPE\n      );\n    switch (value[1]) {\n      case \"$\":\n        return value.slice(1);\n      case \"L\":\n        return (\n          (parentObject = parseInt(value.slice(2), 16)),\n          (response = getChunk(response, parentObject)),\n          createLazyChunkWrapper(response)\n        );\n      case \"@\":\n        return (\n          (parentObject = parseInt(value.slice(2), 16)),\n          getChunk(response, parentObject)\n        );\n      case \"S\":\n        return Symbol.for(value.slice(2));\n      case \"h\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(\n            response,\n            value,\n            parentObject,\n            key,\n            loadServerReference\n          )\n        );\n      case \"T\":\n        parentObject = \"$\" + value.slice(2);\n        response = response._tempRefs;\n        if (null == response)\n          throw Error(\n            \"Missing a temporary reference set but the RSC response returned a temporary reference. Pass a temporaryReference option with the set that was used with the reply.\"\n          );\n        return response.get(parentObject);\n      case \"Q\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createMap)\n        );\n      case \"W\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createSet)\n        );\n      case \"B\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createBlob)\n        );\n      case \"K\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, createFormData)\n        );\n      case \"Z\":\n        return resolveErrorProd();\n      case \"i\":\n        return (\n          (value = value.slice(2)),\n          getOutlinedModel(response, value, parentObject, key, extractIterator)\n        );\n      case \"I\":\n        return Infinity;\n      case \"-\":\n        return \"$-0\" === value ? -0 : -Infinity;\n      case \"N\":\n        return NaN;\n      case \"u\":\n        return;\n      case \"D\":\n        return new Date(Date.parse(value.slice(2)));\n      case \"n\":\n        return BigInt(value.slice(2));\n      default:\n        return (\n          (value = value.slice(1)),\n          getOutlinedModel(response, value, parentObject, key, createModel)\n        );\n    }\n  }\n  return value;\n}\nfunction missingCall() {\n  throw Error(\n    'Trying to call a function from \"use server\" but the callServer option was not implemented in your router runtime.'\n  );\n}\nfunction ResponseInstance(\n  bundlerConfig,\n  serverReferenceConfig,\n  moduleLoading,\n  callServer,\n  encodeFormAction,\n  nonce,\n  temporaryReferences\n) {\n  var chunks = new Map();\n  this._bundlerConfig = bundlerConfig;\n  this._serverReferenceConfig = serverReferenceConfig;\n  this._moduleLoading = moduleLoading;\n  this._callServer = void 0 !== callServer ? callServer : missingCall;\n  this._encodeFormAction = encodeFormAction;\n  this._nonce = nonce;\n  this._chunks = chunks;\n  this._stringDecoder = new util.TextDecoder();\n  this._fromJSON = null;\n  this._closed = !1;\n  this._closedReason = null;\n  this._tempRefs = temporaryReferences;\n  this._fromJSON = createFromJSONCallback(this);\n}\nfunction createStreamState() {\n  return { _rowState: 0, _rowID: 0, _rowTag: 0, _rowLength: 0, _buffer: [] };\n}\nfunction resolveBuffer(response, id, buffer) {\n  response = response._chunks;\n  var chunk = response.get(id);\n  chunk && \"pending\" !== chunk.status\n    ? chunk.reason.enqueueValue(buffer)\n    : ((buffer = new ReactPromise(\"fulfilled\", buffer, null)),\n      response.set(id, buffer));\n}\nfunction resolveModule(response, id, model) {\n  var chunks = response._chunks,\n    chunk = chunks.get(id);\n  model = JSON.parse(model, response._fromJSON);\n  var clientReference = resolveClientReference(response._bundlerConfig, model);\n  prepareDestinationWithChunks(\n    response._moduleLoading,\n    model[1],\n    response._nonce\n  );\n  if ((model = preloadModule(clientReference))) {\n    if (chunk) {\n      var blockedChunk = chunk;\n      blockedChunk.status = \"blocked\";\n    } else\n      (blockedChunk = new ReactPromise(\"blocked\", null, null)),\n        chunks.set(id, blockedChunk);\n    model.then(\n      function () {\n        return resolveModuleChunk(response, blockedChunk, clientReference);\n      },\n      function (error) {\n        return triggerErrorOnChunk(response, blockedChunk, error);\n      }\n    );\n  } else\n    chunk\n      ? resolveModuleChunk(response, chunk, clientReference)\n      : ((chunk = new ReactPromise(\"resolved_module\", clientReference, null)),\n        chunks.set(id, chunk));\n}\nfunction resolveStream(response, id, stream, controller) {\n  response = response._chunks;\n  var chunk = response.get(id);\n  chunk\n    ? \"pending\" === chunk.status &&\n      ((id = chunk.value),\n      (chunk.status = \"fulfilled\"),\n      (chunk.value = stream),\n      (chunk.reason = controller),\n      null !== id && wakeChunk(id, chunk.value, chunk))\n    : ((stream = new ReactPromise(\"fulfilled\", stream, controller)),\n      response.set(id, stream));\n}\nfunction startReadableStream(response, id, type) {\n  var controller = null,\n    closed = !1;\n  type = new ReadableStream({\n    type: type,\n    start: function (c) {\n      controller = c;\n    }\n  });\n  var previousBlockedChunk = null;\n  resolveStream(response, id, type, {\n    enqueueValue: function (value) {\n      null === previousBlockedChunk\n        ? controller.enqueue(value)\n        : previousBlockedChunk.then(function () {\n            controller.enqueue(value);\n          });\n    },\n    enqueueModel: function (json) {\n      if (null === previousBlockedChunk) {\n        var chunk = new ReactPromise(\"resolved_model\", json, response);\n        initializeModelChunk(chunk);\n        \"fulfilled\" === chunk.status\n          ? controller.enqueue(chunk.value)\n          : (chunk.then(\n              function (v) {\n                return controller.enqueue(v);\n              },\n              function (e) {\n                return controller.error(e);\n              }\n            ),\n            (previousBlockedChunk = chunk));\n      } else {\n        chunk = previousBlockedChunk;\n        var chunk$54 = new ReactPromise(\"pending\", null, null);\n        chunk$54.then(\n          function (v) {\n            return controller.enqueue(v);\n          },\n          function (e) {\n            return controller.error(e);\n          }\n        );\n        previousBlockedChunk = chunk$54;\n        chunk.then(function () {\n          previousBlockedChunk === chunk$54 && (previousBlockedChunk = null);\n          resolveModelChunk(response, chunk$54, json);\n        });\n      }\n    },\n    close: function () {\n      if (!closed)\n        if (((closed = !0), null === previousBlockedChunk)) controller.close();\n        else {\n          var blockedChunk = previousBlockedChunk;\n          previousBlockedChunk = null;\n          blockedChunk.then(function () {\n            return controller.close();\n          });\n        }\n    },\n    error: function (error) {\n      if (!closed)\n        if (((closed = !0), null === previousBlockedChunk))\n          controller.error(error);\n        else {\n          var blockedChunk = previousBlockedChunk;\n          previousBlockedChunk = null;\n          blockedChunk.then(function () {\n            return controller.error(error);\n          });\n        }\n    }\n  });\n}\nfunction asyncIterator() {\n  return this;\n}\nfunction createIterator(next) {\n  next = { next: next };\n  next[ASYNC_ITERATOR] = asyncIterator;\n  return next;\n}\nfunction startAsyncIterable(response, id, iterator) {\n  var buffer = [],\n    closed = !1,\n    nextWriteIndex = 0,\n    iterable = {};\n  iterable[ASYNC_ITERATOR] = function () {\n    var nextReadIndex = 0;\n    return createIterator(function (arg) {\n      if (void 0 !== arg)\n        throw Error(\n          \"Values cannot be passed to next() of AsyncIterables passed to Client Components.\"\n        );\n      if (nextReadIndex === buffer.length) {\n        if (closed)\n          return new ReactPromise(\n            \"fulfilled\",\n            { done: !0, value: void 0 },\n            null\n          );\n        buffer[nextReadIndex] = new ReactPromise(\"pending\", null, null);\n      }\n      return buffer[nextReadIndex++];\n    });\n  };\n  resolveStream(\n    response,\n    id,\n    iterator ? iterable[ASYNC_ITERATOR]() : iterable,\n    {\n      enqueueValue: function (value) {\n        if (nextWriteIndex === buffer.length)\n          buffer[nextWriteIndex] = new ReactPromise(\n            \"fulfilled\",\n            { done: !1, value: value },\n            null\n          );\n        else {\n          var chunk = buffer[nextWriteIndex],\n            resolveListeners = chunk.value,\n            rejectListeners = chunk.reason;\n          chunk.status = \"fulfilled\";\n          chunk.value = { done: !1, value: value };\n          chunk.reason = null;\n          null !== resolveListeners &&\n            wakeChunkIfInitialized(chunk, resolveListeners, rejectListeners);\n        }\n        nextWriteIndex++;\n      },\n      enqueueModel: function (value) {\n        nextWriteIndex === buffer.length\n          ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(\n              response,\n              value,\n              !1\n            ))\n          : resolveIteratorResultChunk(\n              response,\n              buffer[nextWriteIndex],\n              value,\n              !1\n            );\n        nextWriteIndex++;\n      },\n      close: function (value) {\n        if (!closed)\n          for (\n            closed = !0,\n              nextWriteIndex === buffer.length\n                ? (buffer[nextWriteIndex] = createResolvedIteratorResultChunk(\n                    response,\n                    value,\n                    !0\n                  ))\n                : resolveIteratorResultChunk(\n                    response,\n                    buffer[nextWriteIndex],\n                    value,\n                    !0\n                  ),\n              nextWriteIndex++;\n            nextWriteIndex < buffer.length;\n\n          )\n            resolveIteratorResultChunk(\n              response,\n              buffer[nextWriteIndex++],\n              '\"$undefined\"',\n              !0\n            );\n      },\n      error: function (error) {\n        if (!closed)\n          for (\n            closed = !0,\n              nextWriteIndex === buffer.length &&\n                (buffer[nextWriteIndex] = new ReactPromise(\n                  \"pending\",\n                  null,\n                  null\n                ));\n            nextWriteIndex < buffer.length;\n\n          )\n            triggerErrorOnChunk(response, buffer[nextWriteIndex++], error);\n      }\n    }\n  );\n}\nfunction resolveErrorProd() {\n  var error = Error(\n    \"An error occurred in the Server Components render. The specific message is omitted in production builds to avoid leaking sensitive details. A digest property is included on this error instance which may provide additional details about the nature of the error.\"\n  );\n  error.stack = \"Error: \" + error.message;\n  return error;\n}\nfunction mergeBuffer(buffer, lastChunk) {\n  for (var l = buffer.length, byteLength = lastChunk.length, i = 0; i < l; i++)\n    byteLength += buffer[i].byteLength;\n  byteLength = new Uint8Array(byteLength);\n  for (var i$55 = (i = 0); i$55 < l; i$55++) {\n    var chunk = buffer[i$55];\n    byteLength.set(chunk, i);\n    i += chunk.byteLength;\n  }\n  byteLength.set(lastChunk, i);\n  return byteLength;\n}\nfunction resolveTypedArray(\n  response,\n  id,\n  buffer,\n  lastChunk,\n  constructor,\n  bytesPerElement\n) {\n  buffer =\n    0 === buffer.length && 0 === lastChunk.byteOffset % bytesPerElement\n      ? lastChunk\n      : mergeBuffer(buffer, lastChunk);\n  constructor = new constructor(\n    buffer.buffer,\n    buffer.byteOffset,\n    buffer.byteLength / bytesPerElement\n  );\n  resolveBuffer(response, id, constructor);\n}\nfunction processFullBinaryRow(response, streamState, id, tag, buffer, chunk) {\n  switch (tag) {\n    case 65:\n      resolveBuffer(response, id, mergeBuffer(buffer, chunk).buffer);\n      return;\n    case 79:\n      resolveTypedArray(response, id, buffer, chunk, Int8Array, 1);\n      return;\n    case 111:\n      resolveBuffer(\n        response,\n        id,\n        0 === buffer.length ? chunk : mergeBuffer(buffer, chunk)\n      );\n      return;\n    case 85:\n      resolveTypedArray(response, id, buffer, chunk, Uint8ClampedArray, 1);\n      return;\n    case 83:\n      resolveTypedArray(response, id, buffer, chunk, Int16Array, 2);\n      return;\n    case 115:\n      resolveTypedArray(response, id, buffer, chunk, Uint16Array, 2);\n      return;\n    case 76:\n      resolveTypedArray(response, id, buffer, chunk, Int32Array, 4);\n      return;\n    case 108:\n      resolveTypedArray(response, id, buffer, chunk, Uint32Array, 4);\n      return;\n    case 71:\n      resolveTypedArray(response, id, buffer, chunk, Float32Array, 4);\n      return;\n    case 103:\n      resolveTypedArray(response, id, buffer, chunk, Float64Array, 8);\n      return;\n    case 77:\n      resolveTypedArray(response, id, buffer, chunk, BigInt64Array, 8);\n      return;\n    case 109:\n      resolveTypedArray(response, id, buffer, chunk, BigUint64Array, 8);\n      return;\n    case 86:\n      resolveTypedArray(response, id, buffer, chunk, DataView, 1);\n      return;\n  }\n  for (\n    var stringDecoder = response._stringDecoder, row = \"\", i = 0;\n    i < buffer.length;\n    i++\n  )\n    row += stringDecoder.decode(buffer[i], decoderOptions);\n  row += stringDecoder.decode(chunk);\n  processFullStringRow(response, streamState, id, tag, row);\n}\nfunction processFullStringRow(response, streamState, id, tag, row) {\n  switch (tag) {\n    case 73:\n      resolveModule(response, id, row);\n      break;\n    case 72:\n      id = row[0];\n      row = row.slice(1);\n      response = JSON.parse(row, response._fromJSON);\n      row = ReactDOMSharedInternals.d;\n      switch (id) {\n        case \"D\":\n          row.D(response);\n          break;\n        case \"C\":\n          \"string\" === typeof response\n            ? row.C(response)\n            : row.C(response[0], response[1]);\n          break;\n        case \"L\":\n          id = response[0];\n          streamState = response[1];\n          3 === response.length\n            ? row.L(id, streamState, response[2])\n            : row.L(id, streamState);\n          break;\n        case \"m\":\n          \"string\" === typeof response\n            ? row.m(response)\n            : row.m(response[0], response[1]);\n          break;\n        case \"X\":\n          \"string\" === typeof response\n            ? row.X(response)\n            : row.X(response[0], response[1]);\n          break;\n        case \"S\":\n          \"string\" === typeof response\n            ? row.S(response)\n            : row.S(\n                response[0],\n                0 === response[1] ? void 0 : response[1],\n                3 === response.length ? response[2] : void 0\n              );\n          break;\n        case \"M\":\n          \"string\" === typeof response\n            ? row.M(response)\n            : row.M(response[0], response[1]);\n      }\n      break;\n    case 69:\n      streamState = response._chunks;\n      tag = streamState.get(id);\n      row = JSON.parse(row);\n      var error = resolveErrorProd();\n      error.digest = row.digest;\n      tag\n        ? triggerErrorOnChunk(response, tag, error)\n        : ((response = createErrorChunk(response, error)),\n          streamState.set(id, response));\n      break;\n    case 84:\n      response = response._chunks;\n      (streamState = response.get(id)) && \"pending\" !== streamState.status\n        ? streamState.reason.enqueueValue(row)\n        : ((row = new ReactPromise(\"fulfilled\", row, null)),\n          response.set(id, row));\n      break;\n    case 78:\n    case 68:\n    case 74:\n    case 87:\n      throw Error(\n        \"Failed to read a RSC payload created by a development version of React on the server while using a production version on the client. Always use matching versions on the server and the client.\"\n      );\n    case 82:\n      startReadableStream(response, id, void 0);\n      break;\n    case 114:\n      startReadableStream(response, id, \"bytes\");\n      break;\n    case 88:\n      startAsyncIterable(response, id, !1);\n      break;\n    case 120:\n      startAsyncIterable(response, id, !0);\n      break;\n    case 67:\n      (id = response._chunks.get(id)) &&\n        \"fulfilled\" === id.status &&\n        id.reason.close(\"\" === row ? '\"$undefined\"' : row);\n      break;\n    case 80:\n      streamState = Error(\n        \"A Server Component was postponed. The reason is omitted in production builds to avoid leaking sensitive details.\"\n      );\n      streamState.$$typeof = REACT_POSTPONE_TYPE;\n      streamState.stack = \"Error: \" + streamState.message;\n      row = response._chunks;\n      (tag = row.get(id))\n        ? triggerErrorOnChunk(response, tag, streamState)\n        : ((response = createErrorChunk(response, streamState)),\n          row.set(id, response));\n      break;\n    default:\n      (streamState = response._chunks),\n        (tag = streamState.get(id))\n          ? resolveModelChunk(response, tag, row)\n          : ((response = new ReactPromise(\"resolved_model\", row, response)),\n            streamState.set(id, response));\n  }\n}\nfunction processBinaryChunk(weakResponse, streamState, chunk) {\n  for (\n    var i = 0,\n      rowState = streamState._rowState,\n      rowID = streamState._rowID,\n      rowTag = streamState._rowTag,\n      rowLength = streamState._rowLength,\n      buffer = streamState._buffer,\n      chunkLength = chunk.length;\n    i < chunkLength;\n\n  ) {\n    var lastIdx = -1;\n    switch (rowState) {\n      case 0:\n        lastIdx = chunk[i++];\n        58 === lastIdx\n          ? (rowState = 1)\n          : (rowID =\n              (rowID << 4) | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n        continue;\n      case 1:\n        rowState = chunk[i];\n        84 === rowState ||\n        65 === rowState ||\n        79 === rowState ||\n        111 === rowState ||\n        85 === rowState ||\n        83 === rowState ||\n        115 === rowState ||\n        76 === rowState ||\n        108 === rowState ||\n        71 === rowState ||\n        103 === rowState ||\n        77 === rowState ||\n        109 === rowState ||\n        86 === rowState\n          ? ((rowTag = rowState), (rowState = 2), i++)\n          : (64 < rowState && 91 > rowState) ||\n              35 === rowState ||\n              114 === rowState ||\n              120 === rowState\n            ? ((rowTag = rowState), (rowState = 3), i++)\n            : ((rowTag = 0), (rowState = 3));\n        continue;\n      case 2:\n        lastIdx = chunk[i++];\n        44 === lastIdx\n          ? (rowState = 4)\n          : (rowLength =\n              (rowLength << 4) | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n        continue;\n      case 3:\n        lastIdx = chunk.indexOf(10, i);\n        break;\n      case 4:\n        (lastIdx = i + rowLength), lastIdx > chunk.length && (lastIdx = -1);\n    }\n    var offset = chunk.byteOffset + i;\n    if (-1 < lastIdx)\n      (rowLength = new Uint8Array(chunk.buffer, offset, lastIdx - i)),\n        processFullBinaryRow(\n          weakResponse,\n          streamState,\n          rowID,\n          rowTag,\n          buffer,\n          rowLength\n        ),\n        (i = lastIdx),\n        3 === rowState && i++,\n        (rowLength = rowID = rowTag = rowState = 0),\n        (buffer.length = 0);\n    else {\n      weakResponse = new Uint8Array(chunk.buffer, offset, chunk.byteLength - i);\n      buffer.push(weakResponse);\n      rowLength -= weakResponse.byteLength;\n      break;\n    }\n  }\n  streamState._rowState = rowState;\n  streamState._rowID = rowID;\n  streamState._rowTag = rowTag;\n  streamState._rowLength = rowLength;\n}\nfunction createFromJSONCallback(response) {\n  return function (key, value) {\n    if (\"string\" === typeof value)\n      return parseModelString(response, this, key, value);\n    if (\"object\" === typeof value && null !== value) {\n      if (value[0] === REACT_ELEMENT_TYPE) {\n        if (\n          ((key = {\n            $$typeof: REACT_ELEMENT_TYPE,\n            type: value[1],\n            key: value[2],\n            ref: null,\n            props: value[3]\n          }),\n          null !== initializingHandler)\n        )\n          if (\n            ((value = initializingHandler),\n            (initializingHandler = value.parent),\n            value.errored)\n          )\n            (key = createErrorChunk(response, value.reason)),\n              (key = createLazyChunkWrapper(key));\n          else if (0 < value.deps) {\n            var blockedChunk = new ReactPromise(\"blocked\", null, null);\n            value.value = key;\n            value.chunk = blockedChunk;\n            key = createLazyChunkWrapper(blockedChunk);\n          }\n      } else key = value;\n      return key;\n    }\n    return value;\n  };\n}\nfunction close(weakResponse) {\n  reportGlobalError(weakResponse, Error(\"Connection closed.\"));\n}\nfunction noServerCall$1() {\n  throw Error(\n    \"Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.\"\n  );\n}\nfunction createResponseFromOptions(options) {\n  return new ResponseInstance(\n    options.serverConsumerManifest.moduleMap,\n    options.serverConsumerManifest.serverModuleMap,\n    options.serverConsumerManifest.moduleLoading,\n    noServerCall$1,\n    options.encodeFormAction,\n    \"string\" === typeof options.nonce ? options.nonce : void 0,\n    options && options.temporaryReferences\n      ? options.temporaryReferences\n      : void 0\n  );\n}\nfunction startReadingFromStream$1(response, stream, onDone) {\n  function progress(_ref) {\n    var value = _ref.value;\n    if (_ref.done) return onDone();\n    processBinaryChunk(response, streamState, value);\n    return reader.read().then(progress).catch(error);\n  }\n  function error(e) {\n    reportGlobalError(response, e);\n  }\n  var streamState = createStreamState(),\n    reader = stream.getReader();\n  reader.read().then(progress).catch(error);\n}\nfunction noServerCall() {\n  throw Error(\n    \"Server Functions cannot be called during initial render. This would create a fetch waterfall. Try to use a Server Component to pass data to Client Components instead.\"\n  );\n}\nfunction startReadingFromStream(response, stream, onEnd) {\n  var streamState = createStreamState();\n  stream.on(\"data\", function (chunk) {\n    if (\"string\" === typeof chunk) {\n      for (\n        var i = 0,\n          rowState = streamState._rowState,\n          rowID = streamState._rowID,\n          rowTag = streamState._rowTag,\n          rowLength = streamState._rowLength,\n          buffer = streamState._buffer,\n          chunkLength = chunk.length;\n        i < chunkLength;\n\n      ) {\n        var lastIdx = -1;\n        switch (rowState) {\n          case 0:\n            lastIdx = chunk.charCodeAt(i++);\n            58 === lastIdx\n              ? (rowState = 1)\n              : (rowID =\n                  (rowID << 4) | (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n            continue;\n          case 1:\n            rowState = chunk.charCodeAt(i);\n            84 === rowState ||\n            65 === rowState ||\n            79 === rowState ||\n            111 === rowState ||\n            85 === rowState ||\n            83 === rowState ||\n            115 === rowState ||\n            76 === rowState ||\n            108 === rowState ||\n            71 === rowState ||\n            103 === rowState ||\n            77 === rowState ||\n            109 === rowState ||\n            86 === rowState\n              ? ((rowTag = rowState), (rowState = 2), i++)\n              : (64 < rowState && 91 > rowState) ||\n                  114 === rowState ||\n                  120 === rowState\n                ? ((rowTag = rowState), (rowState = 3), i++)\n                : ((rowTag = 0), (rowState = 3));\n            continue;\n          case 2:\n            lastIdx = chunk.charCodeAt(i++);\n            44 === lastIdx\n              ? (rowState = 4)\n              : (rowLength =\n                  (rowLength << 4) |\n                  (96 < lastIdx ? lastIdx - 87 : lastIdx - 48));\n            continue;\n          case 3:\n            lastIdx = chunk.indexOf(\"\\n\", i);\n            break;\n          case 4:\n            if (84 !== rowTag)\n              throw Error(\n                \"Binary RSC chunks cannot be encoded as strings. This is a bug in the wiring of the React streams.\"\n              );\n            if (rowLength < chunk.length || chunk.length > 3 * rowLength)\n              throw Error(\n                \"String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.\"\n              );\n            lastIdx = chunk.length;\n        }\n        if (-1 < lastIdx) {\n          if (0 < buffer.length)\n            throw Error(\n              \"String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.\"\n            );\n          i = chunk.slice(i, lastIdx);\n          processFullStringRow(response, streamState, rowID, rowTag, i);\n          i = lastIdx;\n          3 === rowState && i++;\n          rowLength = rowID = rowTag = rowState = 0;\n          buffer.length = 0;\n        } else if (chunk.length !== i)\n          throw Error(\n            \"String chunks need to be passed in their original shape. Not split into smaller string chunks. This is a bug in the wiring of the React streams.\"\n          );\n      }\n      streamState._rowState = rowState;\n      streamState._rowID = rowID;\n      streamState._rowTag = rowTag;\n      streamState._rowLength = rowLength;\n    } else processBinaryChunk(response, streamState, chunk);\n  });\n  stream.on(\"error\", function (error) {\n    reportGlobalError(response, error);\n  });\n  stream.on(\"end\", onEnd);\n}\nexports.createFromFetch = function (promiseForResponse, options) {\n  var response = createResponseFromOptions(options);\n  promiseForResponse.then(\n    function (r) {\n      startReadingFromStream$1(response, r.body, close.bind(null, response));\n    },\n    function (e) {\n      reportGlobalError(response, e);\n    }\n  );\n  return getChunk(response, 0);\n};\nexports.createFromNodeStream = function (\n  stream,\n  serverConsumerManifest,\n  options\n) {\n  serverConsumerManifest = new ResponseInstance(\n    serverConsumerManifest.moduleMap,\n    serverConsumerManifest.serverModuleMap,\n    serverConsumerManifest.moduleLoading,\n    noServerCall,\n    options ? options.encodeFormAction : void 0,\n    options && \"string\" === typeof options.nonce ? options.nonce : void 0,\n    void 0\n  );\n  startReadingFromStream(\n    serverConsumerManifest,\n    stream,\n    close.bind(null, serverConsumerManifest)\n  );\n  return getChunk(serverConsumerManifest, 0);\n};\nexports.createFromReadableStream = function (stream, options) {\n  options = createResponseFromOptions(options);\n  startReadingFromStream$1(options, stream, close.bind(null, options));\n  return getChunk(options, 0);\n};\nexports.createServerReference = function (id) {\n  return createServerReference$1(id, noServerCall$1);\n};\nexports.createTemporaryReferenceSet = function () {\n  return new Map();\n};\nexports.encodeReply = function (value, options) {\n  return new Promise(function (resolve, reject) {\n    var abort = processReply(\n      value,\n      \"\",\n      options && options.temporaryReferences\n        ? options.temporaryReferences\n        : void 0,\n      resolve,\n      reject\n    );\n    if (options && options.signal) {\n      var signal = options.signal;\n      if (signal.aborted) abort(signal.reason);\n      else {\n        var listener = function () {\n          abort(signal.reason);\n          signal.removeEventListener(\"abort\", listener);\n        };\n        signal.addEventListener(\"abort\", listener);\n      }\n    }\n  });\n};\nexports.registerServerReference = function (reference, id, encodeFormAction) {\n  registerBoundServerReference(reference, id, null, encodeFormAction);\n  return reference;\n};\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-server-dom-turbopack-client.node.production.js');\n} else {\n  module.exports = require('./cjs/react-server-dom-turbopack-client.node.development.js');\n}\n","module.exports = (\n  require('../../module.compiled') as typeof import('../../module.compiled')\n).vendored['react-rsc']!.ReactServerDOMTurbopackStatic\n","/**\n * For a given page path, this function ensures that there is a leading slash.\n * If there is not a leading slash, one is added, otherwise it is noop.\n */\nexport function ensureLeadingSlash(path: string) {\n  return path.startsWith('/') ? path : `/${path}`\n}\n","import type { Segment } from './app-router-types'\n\nexport function isGroupSegment(segment: string) {\n  // Use array[0] for performant purpose\n  return segment[0] === '(' && segment.endsWith(')')\n}\n\nexport function isParallelRouteSegment(segment: string) {\n  return segment.startsWith('@') && segment !== '@children'\n}\n\nexport function addSearchParamsIfPageSegment(\n  segment: Segment,\n  searchParams: Record<string, string | string[] | undefined>\n) {\n  const isPageSegment = segment.includes(PAGE_SEGMENT_KEY)\n\n  if (isPageSegment) {\n    const stringifiedQuery = JSON.stringify(searchParams)\n    return stringifiedQuery !== '{}'\n      ? PAGE_SEGMENT_KEY + '?' + stringifiedQuery\n      : PAGE_SEGMENT_KEY\n  }\n\n  return segment\n}\n\nexport const PAGE_SEGMENT_KEY = '__PAGE__'\nexport const DEFAULT_SEGMENT_KEY = '__DEFAULT__'\n","import { ensureLeadingSlash } from '../../page-path/ensure-leading-slash'\nimport { isGroupSegment } from '../../segment'\n\n/**\n * Normalizes an app route so it represents the actual request path. Essentially\n * performing the following transformations:\n *\n * - `/(dashboard)/user/[id]/page` to `/user/[id]`\n * - `/(dashboard)/account/page` to `/account`\n * - `/user/[id]/page` to `/user/[id]`\n * - `/account/page` to `/account`\n * - `/page` to `/`\n * - `/(dashboard)/user/[id]/route` to `/user/[id]`\n * - `/(dashboard)/account/route` to `/account`\n * - `/user/[id]/route` to `/user/[id]`\n * - `/account/route` to `/account`\n * - `/route` to `/`\n * - `/` to `/`\n *\n * @param route the app route to normalize\n * @returns the normalized pathname\n */\nexport function normalizeAppPath(route: string) {\n  return ensureLeadingSlash(\n    route.split('/').reduce((pathname, segment, index, segments) => {\n      // Empty segments are ignored.\n      if (!segment) {\n        return pathname\n      }\n\n      // Groups are ignored.\n      if (isGroupSegment(segment)) {\n        return pathname\n      }\n\n      // Parallel segments are ignored.\n      if (segment[0] === '@') {\n        return pathname\n      }\n\n      // The last segment (if it's a leaf) should be ignored.\n      if (\n        (segment === 'page' || segment === 'route') &&\n        index === segments.length - 1\n      ) {\n        return pathname\n      }\n\n      return `${pathname}/${segment}`\n    }, '')\n  )\n}\n\n/**\n * Strips the `.rsc` extension if it's in the pathname.\n * Since this function is used on full urls it checks `?` for searchParams handling.\n */\nexport function normalizeRscURL(url: string) {\n  return url.replace(\n    /\\.rsc($|\\?)/,\n    // $1 ensures `?` is preserved\n    '$1'\n  )\n}\n","import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type {\n  ClientReferenceManifest,\n  ClientReferenceManifestForRsc,\n} from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\n// This is a global singleton that is used to encode/decode the action bound args from\n// the closure. This can't be using a AsyncLocalStorage as it might happen on the module\n// level. Since the client reference manifest won't be mutated, let's use a global singleton\n// to keep it.\nconst SERVER_ACTION_MANIFESTS_SINGLETON = Symbol.for(\n  'next.server.action-manifests'\n)\n\nexport function setReferenceManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n  serverModuleMap,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: {\n    [id: string]: {\n      id: string\n      chunks: string[]\n      name: string\n    }\n  }\n}) {\n  // @ts-expect-error\n  const clientReferenceManifestsPerPage = globalThis[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ]?.clientReferenceManifestsPerPage as\n    | undefined\n    | DeepReadonly<Record<string, ClientReferenceManifest>>\n\n  // @ts-expect-error\n  globalThis[SERVER_ACTION_MANIFESTS_SINGLETON] = {\n    clientReferenceManifestsPerPage: {\n      ...clientReferenceManifestsPerPage,\n      [normalizeAppPath(page)]: clientReferenceManifest,\n    },\n    serverActionsManifest,\n    serverModuleMap,\n  }\n}\n\nexport function getServerModuleMap() {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverModuleMap: {\n      [id: string]: {\n        id: string\n        chunks: string[]\n        name: string\n      }\n    }\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  return serverActionsManifestSingleton.serverModuleMap\n}\n\nexport function getClientReferenceManifestForRsc(): DeepReadonly<ClientReferenceManifestForRsc> {\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    clientReferenceManifestsPerPage: DeepReadonly<\n      Record<string, ClientReferenceManifest>\n    >\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const { clientReferenceManifestsPerPage } = serverActionsManifestSingleton\n  const workStore = workAsyncStorage.getStore()\n\n  if (!workStore) {\n    // If there's no work store defined, we can assume that a client reference\n    // manifest is needed during module evaluation, e.g. to create a server\n    // action using a higher-order function. This might also use client\n    // components which need to be serialized by Flight, and therefore client\n    // references need to be resolvable. To make this work, we're returning a\n    // merged manifest across all pages. This is fine as long as the module IDs\n    // are not page specific, which they are not for Webpack. TODO: Fix this in\n    // Turbopack.\n    return mergeClientReferenceManifests(clientReferenceManifestsPerPage)\n  }\n\n  const clientReferenceManifest =\n    clientReferenceManifestsPerPage[workStore.route]\n\n  if (!clientReferenceManifest) {\n    throw new InvariantError(\n      `Missing Client Reference Manifest for ${workStore.route}.`\n    )\n  }\n\n  return clientReferenceManifest\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifestSingleton = (globalThis as any)[\n    SERVER_ACTION_MANIFESTS_SINGLETON\n  ] as {\n    serverActionsManifest: DeepReadonly<ActionManifest>\n  }\n\n  if (!serverActionsManifestSingleton) {\n    throw new InvariantError('Missing manifest for Server Actions.')\n  }\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifestSingleton.serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n\nfunction mergeClientReferenceManifests(\n  clientReferenceManifestsPerPage: DeepReadonly<\n    Record<string, ClientReferenceManifest>\n  >\n): ClientReferenceManifestForRsc {\n  const clientReferenceManifests = Object.values(\n    clientReferenceManifestsPerPage as Record<string, ClientReferenceManifest>\n  )\n\n  const mergedClientReferenceManifest: ClientReferenceManifestForRsc = {\n    clientModules: {},\n    edgeRscModuleMapping: {},\n    rscModuleMapping: {},\n  }\n\n  for (const clientReferenceManifest of clientReferenceManifests) {\n    mergedClientReferenceManifest.clientModules = {\n      ...mergedClientReferenceManifest.clientModules,\n      ...clientReferenceManifest.clientModules,\n    }\n    mergedClientReferenceManifest.edgeRscModuleMapping = {\n      ...mergedClientReferenceManifest.edgeRscModuleMapping,\n      ...clientReferenceManifest.edgeRscModuleMapping,\n    }\n    mergedClientReferenceManifest.rscModuleMapping = {\n      ...mergedClientReferenceManifest.rscModuleMapping,\n      ...clientReferenceManifest.rscModuleMapping,\n    }\n  }\n\n  return mergedClientReferenceManifest\n}\n","/**\n * Contains predefined constants for the trace span name in next/server.\n *\n * Currently, next/server/tracer is internal implementation only for tracking\n * next.js's implementation only with known span names defined here.\n **/\n\n// eslint typescript has a bug with TS enums\n/* eslint-disable no-shadow */\n\nenum BaseServerSpan {\n  handleRequest = 'BaseServer.handleRequest',\n  run = 'BaseServer.run',\n  pipe = 'BaseServer.pipe',\n  getStaticHTML = 'BaseServer.getStaticHTML',\n  render = 'BaseServer.render',\n  renderToResponseWithComponents = 'BaseServer.renderToResponseWithComponents',\n  renderToResponse = 'BaseServer.renderToResponse',\n  renderToHTML = 'BaseServer.renderToHTML',\n  renderError = 'BaseServer.renderError',\n  renderErrorToResponse = 'BaseServer.renderErrorToResponse',\n  renderErrorToHTML = 'BaseServer.renderErrorToHTML',\n  render404 = 'BaseServer.render404',\n}\n\nenum LoadComponentsSpan {\n  loadDefaultErrorComponents = 'LoadComponents.loadDefaultErrorComponents',\n  loadComponents = 'LoadComponents.loadComponents',\n}\n\nenum NextServerSpan {\n  getRequestHandler = 'NextServer.getRequestHandler',\n  getRequestHandlerWithMetadata = 'NextServer.getRequestHandlerWithMetadata',\n  getServer = 'NextServer.getServer',\n  getServerRequestHandler = 'NextServer.getServerRequestHandler',\n  createServer = 'createServer.createServer',\n}\n\nenum NextNodeServerSpan {\n  compression = 'NextNodeServer.compression',\n  getBuildId = 'NextNodeServer.getBuildId',\n  createComponentTree = 'NextNodeServer.createComponentTree',\n  clientComponentLoading = 'NextNodeServer.clientComponentLoading',\n  getLayoutOrPageModule = 'NextNodeServer.getLayoutOrPageModule',\n  generateStaticRoutes = 'NextNodeServer.generateStaticRoutes',\n  generateFsStaticRoutes = 'NextNodeServer.generateFsStaticRoutes',\n  generatePublicRoutes = 'NextNodeServer.generatePublicRoutes',\n  generateImageRoutes = 'NextNodeServer.generateImageRoutes.route',\n  sendRenderResult = 'NextNodeServer.sendRenderResult',\n  proxyRequest = 'NextNodeServer.proxyRequest',\n  runApi = 'NextNodeServer.runApi',\n  render = 'NextNodeServer.render',\n  renderHTML = 'NextNodeServer.renderHTML',\n  imageOptimizer = 'NextNodeServer.imageOptimizer',\n  getPagePath = 'NextNodeServer.getPagePath',\n  getRoutesManifest = 'NextNodeServer.getRoutesManifest',\n  findPageComponents = 'NextNodeServer.findPageComponents',\n  getFontManifest = 'NextNodeServer.getFontManifest',\n  getServerComponentManifest = 'NextNodeServer.getServerComponentManifest',\n  getRequestHandler = 'NextNodeServer.getRequestHandler',\n  renderToHTML = 'NextNodeServer.renderToHTML',\n  renderError = 'NextNodeServer.renderError',\n  renderErrorToHTML = 'NextNodeServer.renderErrorToHTML',\n  render404 = 'NextNodeServer.render404',\n  startResponse = 'NextNodeServer.startResponse',\n\n  // nested inner span, does not require parent scope name\n  route = 'route',\n  onProxyReq = 'onProxyReq',\n  apiResolver = 'apiResolver',\n  internalFetch = 'internalFetch',\n}\n\nenum StartServerSpan {\n  startServer = 'startServer.startServer',\n}\n\nenum RenderSpan {\n  getServerSideProps = 'Render.getServerSideProps',\n  getStaticProps = 'Render.getStaticProps',\n  renderToString = 'Render.renderToString',\n  renderDocument = 'Render.renderDocument',\n  createBodyResult = 'Render.createBodyResult',\n}\n\nenum AppRenderSpan {\n  renderToString = 'AppRender.renderToString',\n  renderToReadableStream = 'AppRender.renderToReadableStream',\n  getBodyResult = 'AppRender.getBodyResult',\n  fetch = 'AppRender.fetch',\n}\n\nenum RouterSpan {\n  executeRoute = 'Router.executeRoute',\n}\n\nenum NodeSpan {\n  runHandler = 'Node.runHandler',\n}\n\nenum AppRouteRouteHandlersSpan {\n  runHandler = 'AppRouteRouteHandlers.runHandler',\n}\n\nenum ResolveMetadataSpan {\n  generateMetadata = 'ResolveMetadata.generateMetadata',\n  generateViewport = 'ResolveMetadata.generateViewport',\n}\n\nenum MiddlewareSpan {\n  execute = 'Middleware.execute',\n}\n\ntype SpanTypes =\n  | `${BaseServerSpan}`\n  | `${LoadComponentsSpan}`\n  | `${NextServerSpan}`\n  | `${StartServerSpan}`\n  | `${NextNodeServerSpan}`\n  | `${RenderSpan}`\n  | `${RouterSpan}`\n  | `${AppRenderSpan}`\n  | `${NodeSpan}`\n  | `${AppRouteRouteHandlersSpan}`\n  | `${ResolveMetadataSpan}`\n  | `${MiddlewareSpan}`\n\n// This list is used to filter out spans that are not relevant to the user\nexport const NextVanillaSpanAllowlist = [\n  MiddlewareSpan.execute,\n  BaseServerSpan.handleRequest,\n  RenderSpan.getServerSideProps,\n  RenderSpan.getStaticProps,\n  AppRenderSpan.fetch,\n  AppRenderSpan.getBodyResult,\n  RenderSpan.renderDocument,\n  NodeSpan.runHandler,\n  AppRouteRouteHandlersSpan.runHandler,\n  ResolveMetadataSpan.generateMetadata,\n  ResolveMetadataSpan.generateViewport,\n  NextNodeServerSpan.createComponentTree,\n  NextNodeServerSpan.findPageComponents,\n  NextNodeServerSpan.getLayoutOrPageModule,\n  NextNodeServerSpan.startResponse,\n  NextNodeServerSpan.clientComponentLoading,\n]\n\n// These Spans are allowed to be always logged\n// when the otel log prefix env is set\nexport const LogSpanAllowList = [\n  NextNodeServerSpan.findPageComponents,\n  NextNodeServerSpan.createComponentTree,\n  NextNodeServerSpan.clientComponentLoading,\n]\n\nexport {\n  BaseServerSpan,\n  LoadComponentsSpan,\n  NextServerSpan,\n  NextNodeServerSpan,\n  StartServerSpan,\n  RenderSpan,\n  RouterSpan,\n  AppRenderSpan,\n  NodeSpan,\n  AppRouteRouteHandlersSpan,\n  ResolveMetadataSpan,\n  MiddlewareSpan,\n}\n\nexport type { SpanTypes }\n","import type { FetchEventResult } from '../../web/types'\nimport type { TextMapSetter } from '@opentelemetry/api'\nimport type { SpanTypes } from './constants'\nimport { LogSpanAllowList, NextVanillaSpanAllowlist } from './constants'\n\nimport type {\n  ContextAPI,\n  Span,\n  SpanOptions,\n  Tracer,\n  AttributeValue,\n  TextMapGetter,\n} from 'next/dist/compiled/@opentelemetry/api'\nimport { isThenable } from '../../../shared/lib/is-thenable'\n\nlet api: typeof import('next/dist/compiled/@opentelemetry/api')\n\n// we want to allow users to use their own version of @opentelemetry/api if they\n// want to, so we try to require it first, and if it fails we fall back to the\n// version that is bundled with Next.js\n// this is because @opentelemetry/api has to be synced with the version of\n// @opentelemetry/tracing that is used, and we don't want to force users to use\n// the version that is bundled with Next.js.\n// the API is ~stable, so this should be fine\nif (process.env.NEXT_RUNTIME === 'edge') {\n  api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n} else {\n  try {\n    api = require('@opentelemetry/api') as typeof import('@opentelemetry/api')\n  } catch (err) {\n    api =\n      require('next/dist/compiled/@opentelemetry/api') as typeof import('next/dist/compiled/@opentelemetry/api')\n  }\n}\n\nconst { context, propagation, trace, SpanStatusCode, SpanKind, ROOT_CONTEXT } =\n  api\n\nexport class BubbledError extends Error {\n  constructor(\n    public readonly bubble?: boolean,\n    public readonly result?: FetchEventResult\n  ) {\n    super()\n  }\n}\n\nexport function isBubbledError(error: unknown): error is BubbledError {\n  if (typeof error !== 'object' || error === null) return false\n  return error instanceof BubbledError\n}\n\nconst closeSpanWithError = (span: Span, error?: Error) => {\n  if (isBubbledError(error) && error.bubble) {\n    span.setAttribute('next.bubble', true)\n  } else {\n    if (error) {\n      span.recordException(error)\n      span.setAttribute('error.type', error.name)\n    }\n    span.setStatus({ code: SpanStatusCode.ERROR, message: error?.message })\n  }\n  span.end()\n}\n\ntype TracerSpanOptions = Omit<SpanOptions, 'attributes'> & {\n  parentSpan?: Span\n  spanName?: string\n  attributes?: Partial<Record<AttributeNames, AttributeValue | undefined>>\n  hideSpan?: boolean\n}\n\ninterface NextTracer {\n  getContext(): ContextAPI\n\n  /**\n   * Instruments a function by automatically creating a span activated on its\n   * scope.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its second parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   *\n   */\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n\n  /**\n   * Wrap a function to automatically create a span activated on its\n   * scope when it's called.\n   *\n   * The span will automatically be finished when one of these conditions is\n   * met:\n   *\n   * * The function returns a promise, in which case the span will finish when\n   * the promise is resolved or rejected.\n   * * The function takes a callback as its last parameter, in which case the\n   * span will finish when that callback is called.\n   * * The function doesn't accept a callback and doesn't return a promise, in\n   * which case the span will finish at the end of the function execution.\n   */\n  wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n\n  /**\n   * Starts and returns a new Span representing a logical unit of work.\n   *\n   * This method do NOT modify the current Context by default. In result, any inner span will not\n   * automatically set its parent context to the span created by this method unless manually activate\n   * context via `tracer.getContext().with`. `trace`, or `wrap` is generally recommended as it gracefully\n   * handles context activation. (ref: https://github.com/open-telemetry/opentelemetry-js/issues/1923)\n   */\n  startSpan(type: SpanTypes): Span\n  startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n\n  /**\n   * Returns currently activated span if current context is in the scope of the span.\n   * Returns undefined otherwise.\n   */\n  getActiveScopeSpan(): Span | undefined\n\n  /**\n   * Returns trace propagation data for the currently active context. The format is equal to data provided\n   * through the OpenTelemetry propagator API.\n   */\n  getTracePropagationData(): ClientTraceDataEntry[]\n}\n\ntype NextAttributeNames =\n  | 'next.route'\n  | 'next.page'\n  | 'next.rsc'\n  | 'next.segment'\n  | 'next.span_name'\n  | 'next.span_type'\n  | 'next.clientComponentLoadCount'\ntype OTELAttributeNames = `http.${string}` | `net.${string}`\ntype AttributeNames = NextAttributeNames | OTELAttributeNames\n\n/** we use this map to propagate attributes from nested spans to the top span */\nconst rootSpanAttributesStore = new Map<\n  number,\n  Map<AttributeNames, AttributeValue | undefined>\n>()\nconst rootSpanIdKey = api.createContextKey('next.rootSpanId')\nlet lastSpanId = 0\nconst getSpanId = () => lastSpanId++\n\nexport interface ClientTraceDataEntry {\n  key: string\n  value: string\n}\n\nconst clientTraceDataSetter: TextMapSetter<ClientTraceDataEntry[]> = {\n  set(carrier, key, value) {\n    carrier.push({\n      key,\n      value,\n    })\n  },\n}\n\nclass NextTracerImpl implements NextTracer {\n  /**\n   * Returns an instance to the trace with configured name.\n   * Since wrap / trace can be defined in any place prior to actual trace subscriber initialization,\n   * This should be lazily evaluated.\n   */\n  private getTracerInstance(): Tracer {\n    return trace.getTracer('next.js', '0.0.1')\n  }\n\n  public getContext(): ContextAPI {\n    return context\n  }\n\n  public getTracePropagationData(): ClientTraceDataEntry[] {\n    const activeContext = context.active()\n    const entries: ClientTraceDataEntry[] = []\n    propagation.inject(activeContext, entries, clientTraceDataSetter)\n    return entries\n  }\n\n  public getActiveScopeSpan(): Span | undefined {\n    return trace.getSpan(context?.active())\n  }\n\n  public withPropagatedContext<T, C>(\n    carrier: C,\n    fn: () => T,\n    getter?: TextMapGetter<C>\n  ): T {\n    const activeContext = context.active()\n    if (trace.getSpanContext(activeContext)) {\n      // Active span is already set, too late to propagate.\n      return fn()\n    }\n    const remoteContext = propagation.extract(activeContext, carrier, getter)\n    return context.with(remoteContext, fn)\n  }\n\n  // Trace, wrap implementation is inspired by datadog trace implementation\n  // (https://datadoghq.dev/dd-trace-js/interfaces/tracer.html#trace).\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => Promise<T>\n  ): Promise<T>\n  public trace<T>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: (span?: Span, done?: (error?: Error) => any) => T\n  ): T\n  public trace<T>(...args: Array<any>) {\n    const [type, fnOrOptions, fnOrEmpty] = args\n\n    // coerce options form overload\n    const {\n      fn,\n      options,\n    }: {\n      fn: (span?: Span, done?: (error?: Error) => any) => T | Promise<T>\n      options: TracerSpanOptions\n    } =\n      typeof fnOrOptions === 'function'\n        ? {\n            fn: fnOrOptions,\n            options: {},\n          }\n        : {\n            fn: fnOrEmpty,\n            options: { ...fnOrOptions },\n          }\n\n    const spanName = options.spanName ?? type\n\n    if (\n      (!NextVanillaSpanAllowlist.includes(type) &&\n        process.env.NEXT_OTEL_VERBOSE !== '1') ||\n      options.hideSpan\n    ) {\n      return fn()\n    }\n\n    // Trying to get active scoped span to assign parent. If option specifies parent span manually, will try to use it.\n    let spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n    let isRootSpan = false\n\n    if (!spanContext) {\n      spanContext = context?.active() ?? ROOT_CONTEXT\n      isRootSpan = true\n    } else if (trace.getSpanContext(spanContext)?.isRemote) {\n      isRootSpan = true\n    }\n\n    const spanId = getSpanId()\n\n    options.attributes = {\n      'next.span_name': spanName,\n      'next.span_type': type,\n      ...options.attributes,\n    }\n\n    return context.with(spanContext.setValue(rootSpanIdKey, spanId), () =>\n      this.getTracerInstance().startActiveSpan(\n        spanName,\n        options,\n        (span: Span) => {\n          const startTime =\n            'performance' in globalThis && 'measure' in performance\n              ? globalThis.performance.now()\n              : undefined\n\n          const onCleanup = () => {\n            rootSpanAttributesStore.delete(spanId)\n            if (\n              startTime &&\n              process.env.NEXT_OTEL_PERFORMANCE_PREFIX &&\n              LogSpanAllowList.includes(type || ('' as any))\n            ) {\n              performance.measure(\n                `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-${(\n                  type.split('.').pop() || ''\n                ).replace(\n                  /[A-Z]/g,\n                  (match: string) => '-' + match.toLowerCase()\n                )}`,\n                {\n                  start: startTime,\n                  end: performance.now(),\n                }\n              )\n            }\n          }\n\n          if (isRootSpan) {\n            rootSpanAttributesStore.set(\n              spanId,\n              new Map(\n                Object.entries(options.attributes ?? {}) as [\n                  AttributeNames,\n                  AttributeValue | undefined,\n                ][]\n              )\n            )\n          }\n          try {\n            if (fn.length > 1) {\n              return fn(span, (err) => closeSpanWithError(span, err))\n            }\n\n            const result = fn(span)\n            if (isThenable(result)) {\n              // If there's error make sure it throws\n              return result\n                .then((res) => {\n                  span.end()\n                  // Need to pass down the promise result,\n                  // it could be react stream response with error { error, stream }\n                  return res\n                })\n                .catch((err) => {\n                  closeSpanWithError(span, err)\n                  throw err\n                })\n                .finally(onCleanup)\n            } else {\n              span.end()\n              onCleanup()\n            }\n\n            return result\n          } catch (err: any) {\n            closeSpanWithError(span, err)\n            onCleanup()\n            throw err\n          }\n        }\n      )\n    )\n  }\n\n  public wrap<T = (...args: Array<any>) => any>(type: SpanTypes, fn: T): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap<T = (...args: Array<any>) => any>(\n    type: SpanTypes,\n    options: (...args: any[]) => TracerSpanOptions,\n    fn: T\n  ): T\n  public wrap(...args: Array<any>) {\n    const tracer = this\n    const [name, options, fn] =\n      args.length === 3 ? args : [args[0], {}, args[1]]\n\n    if (\n      !NextVanillaSpanAllowlist.includes(name) &&\n      process.env.NEXT_OTEL_VERBOSE !== '1'\n    ) {\n      return fn\n    }\n\n    return function (this: any) {\n      let optionsObj = options\n      if (typeof optionsObj === 'function' && typeof fn === 'function') {\n        optionsObj = optionsObj.apply(this, arguments)\n      }\n\n      const lastArgId = arguments.length - 1\n      const cb = arguments[lastArgId]\n\n      if (typeof cb === 'function') {\n        const scopeBoundCb = tracer.getContext().bind(context.active(), cb)\n        return tracer.trace(name, optionsObj, (_span, done) => {\n          arguments[lastArgId] = function (err: any) {\n            done?.(err)\n            return scopeBoundCb.apply(this, arguments)\n          }\n\n          return fn.apply(this, arguments)\n        })\n      } else {\n        return tracer.trace(name, optionsObj, () => fn.apply(this, arguments))\n      }\n    }\n  }\n\n  public startSpan(type: SpanTypes): Span\n  public startSpan(type: SpanTypes, options: TracerSpanOptions): Span\n  public startSpan(...args: Array<any>): Span {\n    const [type, options]: [string, TracerSpanOptions | undefined] = args as any\n\n    const spanContext = this.getSpanContext(\n      options?.parentSpan ?? this.getActiveScopeSpan()\n    )\n    return this.getTracerInstance().startSpan(type, options, spanContext)\n  }\n\n  private getSpanContext(parentSpan?: Span) {\n    const spanContext = parentSpan\n      ? trace.setSpan(context.active(), parentSpan)\n      : undefined\n\n    return spanContext\n  }\n\n  public getRootSpanAttributes() {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    return rootSpanAttributesStore.get(spanId)\n  }\n\n  public setRootSpanAttribute(key: AttributeNames, value: AttributeValue) {\n    const spanId = context.active().getValue(rootSpanIdKey) as number\n    const attributes = rootSpanAttributesStore.get(spanId)\n    if (attributes && !attributes.has(key)) {\n      attributes.set(key, value)\n    }\n  }\n}\n\nconst getTracer = (() => {\n  const tracer = new NextTracerImpl()\n\n  return () => tracer\n})()\n\nexport { getTracer, SpanStatusCode, SpanKind }\nexport type { NextTracer, Span, SpanOptions, ContextAPI, TracerSpanOptions }\n","/**\n * A `Promise.withResolvers` implementation that exposes the `resolve` and\n * `reject` functions on a `Promise`.\n *\n * @see https://tc39.es/proposal-promise-with-resolvers/\n */\nexport class DetachedPromise<T = any> {\n  public readonly resolve: (value: T | PromiseLike<T>) => void\n  public readonly reject: (reason: any) => void\n  public readonly promise: Promise<T>\n\n  constructor() {\n    let resolve: (value: T | PromiseLike<T>) => void\n    let reject: (reason: any) => void\n\n    // Create the promise and assign the resolvers to the object.\n    this.promise = new Promise<T>((res, rej) => {\n      resolve = res\n      reject = rej\n    })\n\n    // We know that resolvers is defined because the Promise constructor runs\n    // synchronously.\n    this.resolve = resolve!\n    this.reject = reject!\n  }\n}\n","export const ENCODED_TAGS = {\n  // opening tags do not have the closing `>` since they can contain other attributes such as `<body className=''>`\n  OPENING: {\n    // <html\n    HTML: new Uint8Array([60, 104, 116, 109, 108]),\n    // <body\n    BODY: new Uint8Array([60, 98, 111, 100, 121]),\n  },\n  CLOSED: {\n    // </head>\n    HEAD: new Uint8Array([60, 47, 104, 101, 97, 100, 62]),\n    // </body>\n    BODY: new Uint8Array([60, 47, 98, 111, 100, 121, 62]),\n    // </html>\n    HTML: new Uint8Array([60, 47, 104, 116, 109, 108, 62]),\n    // </body></html>\n    BODY_AND_HTML: new Uint8Array([\n      60, 47, 98, 111, 100, 121, 62, 60, 47, 104, 116, 109, 108, 62,\n    ]),\n  },\n  META: {\n    // Only the match the prefix cause the suffix can be different wether it's xml compatible or not \">\" or \"/>\"\n    // <meta name=\"nxt-icon\"\n    // This is a special mark that will be replaced by the icon insertion script tag.\n    ICON_MARK: new Uint8Array([\n      60, 109, 101, 116, 97, 32, 110, 97, 109, 101, 61, 34, 194, 171, 110, 120,\n      116, 45, 105, 99, 111, 110, 194, 187, 34,\n    ]),\n  },\n} as const\n","/**\n * Find the starting index of Uint8Array `b` within Uint8Array `a`.\n */\nexport function indexOfUint8Array(a: Uint8Array, b: Uint8Array) {\n  if (b.length === 0) return 0\n  if (a.length === 0 || b.length > a.length) return -1\n\n  // start iterating through `a`\n  for (let i = 0; i <= a.length - b.length; i++) {\n    let completeMatch = true\n    // from index `i`, iterate through `b` and check for mismatch\n    for (let j = 0; j < b.length; j++) {\n      // if the values do not match, then this isn't a complete match, exit `b` iteration early and iterate to next index of `a`.\n      if (a[i + j] !== b[j]) {\n        completeMatch = false\n        break\n      }\n    }\n\n    if (completeMatch) {\n      return i\n    }\n  }\n\n  return -1\n}\n\n/**\n * Check if two Uint8Arrays are strictly equivalent.\n */\nexport function isEquivalentUint8Arrays(a: Uint8Array, b: Uint8Array) {\n  if (a.length !== b.length) return false\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false\n  }\n\n  return true\n}\n\n/**\n * Remove Uint8Array `b` from Uint8Array `a`.\n *\n * If `b` is not in `a`, `a` is returned unchanged.\n *\n * Otherwise, the function returns a new Uint8Array instance with size `a.length - b.length`\n */\nexport function removeFromUint8Array(a: Uint8Array, b: Uint8Array) {\n  const tagIndex = indexOfUint8Array(a, b)\n  if (tagIndex === 0) return a.subarray(b.length)\n  if (tagIndex > -1) {\n    const removed = new Uint8Array(a.length - b.length)\n    removed.set(a.slice(0, tagIndex))\n    removed.set(a.slice(tagIndex + b.length), tagIndex)\n    return removed\n  } else {\n    return a\n  }\n}\n","export const MISSING_ROOT_TAGS_ERROR = 'NEXT_MISSING_ROOT_TAGS'\n","// In output: export mode, the build id is added to the start of the HTML\n// document, directly after the doctype declaration. During a prefetch, the\n// client performs a range request to get the build id, so it can check whether\n// the target page belongs to the same build.\n//\n// The first 64 bytes of the document are requested. The exact number isn't\n// too important; it must be larger than the build id + doctype + closing and\n// ending comment markers, but it doesn't need to match the end of the\n// comment exactly.\n//\n// Build ids are 21 bytes long in the default implementation, though this\n// can be overridden in the Next.js config. For the purposes of this check,\n// it's OK to only match the start of the id, so we'll truncate it if exceeds\n// a certain length.\n\nconst DOCTYPE_PREFIX = '<!DOCTYPE html>' // 15 bytes\nconst MAX_BUILD_ID_LENGTH = 24\n\n// Request the first 64 bytes. The Range header is inclusive of the end value.\nexport const DOC_PREFETCH_RANGE_HEADER_VALUE = 'bytes=0-63'\n\nfunction escapeBuildId(buildId: string) {\n  // If the build id is longer than the given limit, it's OK for our purposes\n  // to only match the beginning.\n  const truncated = buildId.slice(0, MAX_BUILD_ID_LENGTH)\n  // Replace hyphens with underscores so it doesn't break the HTML comment.\n  // (Unlikely, but if this did happen it would break the whole document.)\n  return truncated.replace(/-/g, '_')\n}\n\nexport function insertBuildIdComment(originalHtml: string, buildId: string) {\n  if (\n    // Skip if the build id contains a closing comment marker.\n    buildId.includes('-->') ||\n    // React always inserts a doctype at the start of the document. Skip if it\n    // isn't present. Shouldn't happen; suggests an issue elsewhere.\n    !originalHtml.startsWith(DOCTYPE_PREFIX)\n  ) {\n    // Return the original HTML unchanged. This means the document will not\n    // be prefetched.\n    // TODO: The build id comment is currently only used during prefetches, but\n    // if we eventually use this mechanism for regular navigations, we may need\n    // to error during build if we fail to insert it for some reason.\n    return originalHtml\n  }\n  // The comment must be inserted after the doctype.\n  return originalHtml.replace(\n    DOCTYPE_PREFIX,\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n\nexport function doesExportedHtmlMatchBuildId(\n  partialHtmlDocument: string,\n  buildId: string\n) {\n  // Check whether the document starts with the expected buildId.\n  return partialHtmlDocument.startsWith(\n    DOCTYPE_PREFIX + '<!--' + escapeBuildId(buildId) + '-->'\n  )\n}\n","import type { ReactDOMServerReadableStream } from 'react-dom/server'\nimport { getTracer } from '../lib/trace/tracer'\nimport { AppRenderSpan } from '../lib/trace/constants'\nimport { DetachedPromise } from '../../lib/detached-promise'\nimport { scheduleImmediate, atLeastOneTask } from '../../lib/scheduler'\nimport { ENCODED_TAGS } from './encoded-tags'\nimport {\n  indexOfUint8Array,\n  isEquivalentUint8Arrays,\n  removeFromUint8Array,\n} from './uint8array-helpers'\nimport { MISSING_ROOT_TAGS_ERROR } from '../../shared/lib/errors/constants'\nimport { insertBuildIdComment } from '../../shared/lib/segment-cache/output-export-prefetch-encoding'\n\nfunction voidCatch() {\n  // this catcher is designed to be used with pipeTo where we expect the underlying\n  // pipe implementation to forward errors but we don't want the pipeTo promise to reject\n  // and be unhandled\n}\n\n// We can share the same encoder instance everywhere\n// Notably we cannot do the same for TextDecoder because it is stateful\n// when handling streaming data\nconst encoder = new TextEncoder()\n\nexport function chainStreams<T>(\n  ...streams: ReadableStream<T>[]\n): ReadableStream<T> {\n  // If we have no streams, return an empty stream. This behavior is\n  // intentional as we're now providing the `RenderResult.EMPTY` value.\n  if (streams.length === 0) {\n    return new ReadableStream<T>({\n      start(controller) {\n        controller.close()\n      },\n    })\n  }\n\n  // If we only have 1 stream we fast path it by returning just this stream\n  if (streams.length === 1) {\n    return streams[0]\n  }\n\n  const { readable, writable } = new TransformStream()\n\n  // We always initiate pipeTo immediately. We know we have at least 2 streams\n  // so we need to avoid closing the writable when this one finishes.\n  let promise = streams[0].pipeTo(writable, { preventClose: true })\n\n  let i = 1\n  for (; i < streams.length - 1; i++) {\n    const nextStream = streams[i]\n    promise = promise.then(() =>\n      nextStream.pipeTo(writable, { preventClose: true })\n    )\n  }\n\n  // We can omit the length check because we halted before the last stream and there\n  // is at least two streams so the lastStream here will always be defined\n  const lastStream = streams[i]\n  promise = promise.then(() => lastStream.pipeTo(writable))\n\n  // Catch any errors from the streams and ignore them, they will be handled\n  // by whatever is consuming the readable stream.\n  promise.catch(voidCatch)\n\n  return readable\n}\n\nexport function streamFromString(str: string): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(encoder.encode(str))\n      controller.close()\n    },\n  })\n}\n\nexport function streamFromBuffer(chunk: Buffer): ReadableStream<Uint8Array> {\n  return new ReadableStream({\n    start(controller) {\n      controller.enqueue(chunk)\n      controller.close()\n    },\n  })\n}\n\nexport async function streamToBuffer(\n  stream: ReadableStream<Uint8Array>\n): Promise<Buffer> {\n  const reader = stream.getReader()\n  const chunks: Uint8Array[] = []\n\n  while (true) {\n    const { done, value } = await reader.read()\n    if (done) {\n      break\n    }\n\n    chunks.push(value)\n  }\n\n  return Buffer.concat(chunks)\n}\n\nexport async function streamToString(\n  stream: ReadableStream<Uint8Array>,\n  signal?: AbortSignal\n): Promise<string> {\n  const decoder = new TextDecoder('utf-8', { fatal: true })\n  let string = ''\n\n  for await (const chunk of stream) {\n    if (signal?.aborted) {\n      return string\n    }\n\n    string += decoder.decode(chunk, { stream: true })\n  }\n\n  string += decoder.decode()\n\n  return string\n}\n\nexport type BufferedTransformOptions = {\n  /**\n   * Flush synchronously once the buffer reaches this many bytes.\n   */\n  readonly maxBufferByteLength?: number\n}\n\nexport function createBufferedTransformStream(\n  options: BufferedTransformOptions = {}\n): TransformStream<Uint8Array, Uint8Array> {\n  const { maxBufferByteLength = Infinity } = options\n\n  let bufferedChunks: Array<Uint8Array> = []\n  let bufferByteLength: number = 0\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    try {\n      if (bufferedChunks.length === 0) {\n        return\n      }\n\n      const chunk = new Uint8Array(bufferByteLength)\n      let copiedBytes = 0\n\n      for (let i = 0; i < bufferedChunks.length; i++) {\n        const bufferedChunk = bufferedChunks[i]\n        chunk.set(bufferedChunk, copiedBytes)\n        copiedBytes += bufferedChunk.byteLength\n      }\n      // We just wrote all the buffered chunks so we need to reset the bufferedChunks array\n      // and our bufferByteLength to prepare for the next round of buffered chunks\n      bufferedChunks.length = 0\n      bufferByteLength = 0\n      controller.enqueue(chunk)\n    } catch {\n      // If an error occurs while enqueuing, it can't be due to this\n      // transformer. It's most likely caused by the controller having been\n      // errored (for example, if the stream was cancelled).\n    }\n  }\n\n  const scheduleFlush = (controller: TransformStreamDefaultController) => {\n    if (pending) {\n      return\n    }\n\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        flush(controller)\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      // Combine the previous buffer with the new chunk.\n      bufferedChunks.push(chunk)\n      bufferByteLength += chunk.byteLength\n\n      if (bufferByteLength >= maxBufferByteLength) {\n        flush(controller)\n      } else {\n        scheduleFlush(controller)\n      }\n    },\n    flush() {\n      return pending?.promise\n    },\n  })\n}\n\nfunction createPrefetchCommentStream(\n  isBuildTimePrerendering: boolean,\n  buildId: string\n): TransformStream<Uint8Array, Uint8Array> {\n  // Insert an extra comment at the beginning of the HTML document. This must\n  // come after the DOCTYPE, which is inserted by React.\n  //\n  // The first chunk sent by React will contain the doctype. After that, we can\n  // pass through the rest of the chunks as-is.\n  let didTransformFirstChunk = false\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (isBuildTimePrerendering && !didTransformFirstChunk) {\n        didTransformFirstChunk = true\n        const decoder = new TextDecoder('utf-8', { fatal: true })\n        const chunkStr = decoder.decode(chunk, {\n          stream: true,\n        })\n        const updatedChunkStr = insertBuildIdComment(chunkStr, buildId)\n        controller.enqueue(encoder.encode(updatedChunkStr))\n        return\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nexport function renderToInitialFizzStream({\n  ReactDOMServer,\n  element,\n  streamOptions,\n}: {\n  ReactDOMServer: {\n    renderToReadableStream: typeof import('react-dom/server').renderToReadableStream\n  }\n  element: React.ReactElement\n  streamOptions?: Parameters<typeof ReactDOMServer.renderToReadableStream>[1]\n}): Promise<ReactDOMServerReadableStream> {\n  return getTracer().trace(AppRenderSpan.renderToReadableStream, async () =>\n    ReactDOMServer.renderToReadableStream(element, streamOptions)\n  )\n}\n\nfunction createMetadataTransformStream(\n  insert: () => Promise<string> | string\n): TransformStream<Uint8Array, Uint8Array> {\n  let chunkIndex = -1\n  let isMarkRemoved = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      let iconMarkIndex = -1\n      let closedHeadIndex = -1\n      chunkIndex++\n\n      if (isMarkRemoved) {\n        controller.enqueue(chunk)\n        return\n      }\n      let iconMarkLength = 0\n      // Only search for the closed head tag once\n      if (iconMarkIndex === -1) {\n        iconMarkIndex = indexOfUint8Array(chunk, ENCODED_TAGS.META.ICON_MARK)\n        if (iconMarkIndex === -1) {\n          controller.enqueue(chunk)\n          return\n        } else {\n          // When we found the `<meta name=\"nxt-icon\"` tag prefix, we will remove it from the chunk.\n          // Its close tag could either be `/>` or `>`, checking the next char to ensure we cover both cases.\n          iconMarkLength = ENCODED_TAGS.META.ICON_MARK.length\n          // Check if next char is /, this is for xml mode.\n          if (chunk[iconMarkIndex + iconMarkLength] === 47) {\n            iconMarkLength += 2\n          } else {\n            // The last char is `>`\n            iconMarkLength++\n          }\n        }\n      }\n\n      // Check if icon mark is inside <head> tag in the first chunk.\n      if (chunkIndex === 0) {\n        closedHeadIndex = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        if (iconMarkIndex !== -1) {\n          // The mark icon is located in the 1st chunk before the head tag.\n          // We do not need to insert the script tag in this case because it's in the head.\n          // Just remove the icon mark from the chunk.\n          if (iconMarkIndex < closedHeadIndex) {\n            const replaced = new Uint8Array(chunk.length - iconMarkLength)\n\n            // Remove the icon mark from the chunk.\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex\n            )\n            chunk = replaced\n          } else {\n            // The icon mark is after the head tag, replace and insert the script tag at that position.\n            const insertion = await insert()\n            const encodedInsertion = encoder.encode(insertion)\n            const insertionLength = encodedInsertion.length\n            const replaced = new Uint8Array(\n              chunk.length - iconMarkLength + insertionLength\n            )\n            replaced.set(chunk.subarray(0, iconMarkIndex))\n            replaced.set(encodedInsertion, iconMarkIndex)\n            replaced.set(\n              chunk.subarray(iconMarkIndex + iconMarkLength),\n              iconMarkIndex + insertionLength\n            )\n            chunk = replaced\n          }\n          isMarkRemoved = true\n        }\n        // If there's no icon mark located, it will be handled later when if present in the following chunks.\n      } else {\n        // When it's appeared in the following chunks, we'll need to\n        // remove the mark and then insert the script tag at that position.\n        const insertion = await insert()\n        const encodedInsertion = encoder.encode(insertion)\n        const insertionLength = encodedInsertion.length\n        // Replace the icon mark with the hoist script or empty string.\n        const replaced = new Uint8Array(\n          chunk.length - iconMarkLength + insertionLength\n        )\n        // Set the first part of the chunk, before the icon mark.\n        replaced.set(chunk.subarray(0, iconMarkIndex))\n        // Set the insertion after the icon mark.\n        replaced.set(encodedInsertion, iconMarkIndex)\n\n        // Set the rest of the chunk after the icon mark.\n        replaced.set(\n          chunk.subarray(iconMarkIndex + iconMarkLength),\n          iconMarkIndex + insertionLength\n        )\n        chunk = replaced\n        isMarkRemoved = true\n      }\n      controller.enqueue(chunk)\n    },\n  })\n}\n\nfunction createHeadInsertionTransformStream(\n  insert: () => Promise<string>\n): TransformStream<Uint8Array, Uint8Array> {\n  let inserted = false\n\n  // We need to track if this transform saw any bytes because if it didn't\n  // we won't want to insert any server HTML at all\n  let hasBytes = false\n\n  return new TransformStream({\n    async transform(chunk, controller) {\n      hasBytes = true\n\n      const insertion = await insert()\n      if (inserted) {\n        if (insertion) {\n          const encodedInsertion = encoder.encode(insertion)\n          controller.enqueue(encodedInsertion)\n        }\n        controller.enqueue(chunk)\n      } else {\n        // TODO (@Ethan-Arrowood): Replace the generic `indexOfUint8Array` method with something finely tuned for the subset of things actually being checked for.\n        const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.HEAD)\n        // In fully static rendering or non PPR rendering cases:\n        // `/head>` will always be found in the chunk in first chunk rendering.\n        if (index !== -1) {\n          if (insertion) {\n            const encodedInsertion = encoder.encode(insertion)\n            // Get the total count of the bytes in the chunk and the insertion\n            // e.g.\n            // chunk = <head><meta charset=\"utf-8\"></head>\n            // insertion = <script>...</script>\n            // output = <head><meta charset=\"utf-8\"> [ <script>...</script> ] </head>\n            const insertedHeadContent = new Uint8Array(\n              chunk.length + encodedInsertion.length\n            )\n            // Append the first part of the chunk, before the head tag\n            insertedHeadContent.set(chunk.slice(0, index))\n            // Append the server inserted content\n            insertedHeadContent.set(encodedInsertion, index)\n            // Append the rest of the chunk\n            insertedHeadContent.set(\n              chunk.slice(index),\n              index + encodedInsertion.length\n            )\n            controller.enqueue(insertedHeadContent)\n          } else {\n            controller.enqueue(chunk)\n          }\n          inserted = true\n        } else {\n          // This will happens in PPR rendering during next start, when the page is partially rendered.\n          // When the page resumes, the head tag will be found in the middle of the chunk.\n          // Where we just need to append the insertion and chunk to the current stream.\n          // e.g.\n          // PPR-static: <head>...</head><body> [ resume content ] </body>\n          // PPR-resume: [ insertion ] [ rest content ]\n          if (insertion) {\n            controller.enqueue(encoder.encode(insertion))\n          }\n          controller.enqueue(chunk)\n          inserted = true\n        }\n      }\n    },\n    async flush(controller) {\n      // Check before closing if there's anything remaining to insert.\n      if (hasBytes) {\n        const insertion = await insert()\n        if (insertion) {\n          controller.enqueue(encoder.encode(insertion))\n        }\n      }\n    },\n  })\n}\n\n// Suffix after main body content - scripts before </body>,\n// but wait for the major chunks to be enqueued.\nfunction createDeferredSuffixStream(\n  suffix: string\n): TransformStream<Uint8Array, Uint8Array> {\n  let flushed = false\n  let pending: DetachedPromise<void> | undefined\n\n  const flush = (controller: TransformStreamDefaultController) => {\n    const detached = new DetachedPromise<void>()\n    pending = detached\n\n    scheduleImmediate(() => {\n      try {\n        controller.enqueue(encoder.encode(suffix))\n      } catch {\n        // If an error occurs while enqueuing it can't be due to this\n        // transformers fault. It's likely due to the controller being\n        // errored due to the stream being cancelled.\n      } finally {\n        pending = undefined\n        detached.resolve()\n      }\n    })\n  }\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // If we've already flushed, we're done.\n      if (flushed) return\n\n      // Schedule the flush to happen.\n      flushed = true\n      flush(controller)\n    },\n    flush(controller) {\n      if (pending) return pending.promise\n      if (flushed) return\n\n      // Flush now.\n      controller.enqueue(encoder.encode(suffix))\n    },\n  })\n}\n\nfunction createFlightDataInjectionTransformStream(\n  stream: ReadableStream<Uint8Array>,\n  delayDataUntilFirstHtmlChunk: boolean\n): TransformStream<Uint8Array, Uint8Array> {\n  let htmlStreamFinished = false\n\n  let pull: Promise<void> | null = null\n  let donePulling = false\n\n  function startOrContinuePulling(\n    controller: TransformStreamDefaultController\n  ) {\n    if (!pull) {\n      pull = startPulling(controller)\n    }\n    return pull\n  }\n\n  async function startPulling(controller: TransformStreamDefaultController) {\n    const reader = stream.getReader()\n\n    if (delayDataUntilFirstHtmlChunk) {\n      // NOTE: streaming flush\n      // We are buffering here for the inlined data stream because the\n      // \"shell\" stream might be chunkenized again by the underlying stream\n      // implementation, e.g. with a specific high-water mark. To ensure it's\n      // the safe timing to pipe the data stream, this extra tick is\n      // necessary.\n\n      // We don't start reading until we've left the current Task to ensure\n      // that it's inserted after flushing the shell. Note that this implementation\n      // might get stale if impl details of Fizz change in the future.\n      await atLeastOneTask()\n    }\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read()\n        if (done) {\n          donePulling = true\n          return\n        }\n\n        // We want to prioritize HTML over RSC data.\n        // The SSR render is based on the same RSC stream, so when we get a new RSC chunk,\n        // we're likely to produce an HTML chunk as well, so give it a chance to flush first.\n        if (!delayDataUntilFirstHtmlChunk && !htmlStreamFinished) {\n          await atLeastOneTask()\n        }\n        controller.enqueue(value)\n      }\n    } catch (err) {\n      controller.error(err)\n    }\n  }\n\n  return new TransformStream({\n    start(controller) {\n      if (!delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    transform(chunk, controller) {\n      controller.enqueue(chunk)\n\n      // Start the streaming if it hasn't already been started yet.\n      if (delayDataUntilFirstHtmlChunk) {\n        startOrContinuePulling(controller)\n      }\n    },\n    flush(controller) {\n      htmlStreamFinished = true\n      if (donePulling) {\n        return\n      }\n      return startOrContinuePulling(controller)\n    },\n  })\n}\n\nconst CLOSE_TAG = '</body></html>'\n\n/**\n * This transform stream moves the suffix to the end of the stream, so results\n * like `</body></html><script>...</script>` will be transformed to\n * `<script>...</script></body></html>`.\n */\nfunction createMoveSuffixStream(): TransformStream<Uint8Array, Uint8Array> {\n  let foundSuffix = false\n\n  return new TransformStream({\n    transform(chunk, controller) {\n      if (foundSuffix) {\n        return controller.enqueue(chunk)\n      }\n\n      const index = indexOfUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n      if (index > -1) {\n        foundSuffix = true\n\n        // If the whole chunk is the suffix, then don't write anything, it will\n        // be written in the flush.\n        if (chunk.length === ENCODED_TAGS.CLOSED.BODY_AND_HTML.length) {\n          return\n        }\n\n        // Write out the part before the suffix.\n        const before = chunk.slice(0, index)\n        controller.enqueue(before)\n\n        // In the case where the suffix is in the middle of the chunk, we need\n        // to split the chunk into two parts.\n        if (chunk.length > ENCODED_TAGS.CLOSED.BODY_AND_HTML.length + index) {\n          // Write out the part after the suffix.\n          const after = chunk.slice(\n            index + ENCODED_TAGS.CLOSED.BODY_AND_HTML.length\n          )\n          controller.enqueue(after)\n        }\n      } else {\n        controller.enqueue(chunk)\n      }\n    },\n    flush(controller) {\n      // Even if we didn't find the suffix, the HTML is not valid if we don't\n      // add it, so insert it at the end.\n      controller.enqueue(ENCODED_TAGS.CLOSED.BODY_AND_HTML)\n    },\n  })\n}\n\nfunction createStripDocumentClosingTagsTransform(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  return new TransformStream({\n    transform(chunk, controller) {\n      // We rely on the assumption that chunks will never break across a code unit.\n      // This is reasonable because we currently concat all of React's output from a single\n      // flush into one chunk before streaming it forward which means the chunk will represent\n      // a single coherent utf-8 string. This is not safe to use if we change our streaming to no\n      // longer do this large buffered chunk\n      if (\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY_AND_HTML) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.BODY) ||\n        isEquivalentUint8Arrays(chunk, ENCODED_TAGS.CLOSED.HTML)\n      ) {\n        // the entire chunk is the closing tags; return without enqueueing anything.\n        return\n      }\n\n      // We assume these tags will go at together at the end of the document and that\n      // they won't appear anywhere else in the document. This is not really a safe assumption\n      // but until we revamp our streaming infra this is a performant way to string the tags\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.BODY)\n      chunk = removeFromUint8Array(chunk, ENCODED_TAGS.CLOSED.HTML)\n\n      controller.enqueue(chunk)\n    },\n  })\n}\n\n/*\n * Checks if the root layout is missing the html or body tags\n * and if so, it will inject a script tag to throw an error in the browser, showing the user\n * the error message in the error overlay.\n */\nexport function createRootLayoutValidatorStream(): TransformStream<\n  Uint8Array,\n  Uint8Array\n> {\n  let foundHtml = false\n  let foundBody = false\n  return new TransformStream({\n    async transform(chunk, controller) {\n      // Peek into the streamed chunk to see if the tags are present.\n      if (\n        !foundHtml &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.HTML) > -1\n      ) {\n        foundHtml = true\n      }\n\n      if (\n        !foundBody &&\n        indexOfUint8Array(chunk, ENCODED_TAGS.OPENING.BODY) > -1\n      ) {\n        foundBody = true\n      }\n\n      controller.enqueue(chunk)\n    },\n    flush(controller) {\n      const missingTags: ('html' | 'body')[] = []\n      if (!foundHtml) missingTags.push('html')\n      if (!foundBody) missingTags.push('body')\n\n      if (!missingTags.length) return\n\n      controller.enqueue(\n        encoder.encode(\n          `<html id=\"__next_error__\">\n            <template\n              data-next-error-message=\"Missing ${missingTags\n                .map((c) => `<${c}>`)\n                .join(\n                  missingTags.length > 1 ? ' and ' : ''\n                )} tags in the root layout.\\nRead more at https://nextjs.org/docs/messages/missing-root-layout-tags\"\n              data-next-error-digest=\"${MISSING_ROOT_TAGS_ERROR}\"\n              data-next-error-stack=\"\"\n            ></template>\n          `\n        )\n      )\n    },\n  })\n}\n\nfunction chainTransformers<T>(\n  readable: ReadableStream<T>,\n  transformers: ReadonlyArray<TransformStream<T, T> | null>\n): ReadableStream<T> {\n  let stream = readable\n  for (const transformer of transformers) {\n    if (!transformer) continue\n\n    stream = stream.pipeThrough(transformer)\n  }\n  return stream\n}\n\nexport type ContinueStreamOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array> | undefined\n  isStaticGeneration: boolean\n  isBuildTimePrerendering: boolean\n  buildId: string\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  validateRootLayout?: boolean\n  /**\n   * Suffix to inject after the buffered data, but before the close tags.\n   */\n  suffix?: string | undefined\n}\n\nexport async function continueFizzStream(\n  renderStream: ReactDOMServerReadableStream,\n  {\n    suffix,\n    inlinedDataStream,\n    isStaticGeneration,\n    isBuildTimePrerendering,\n    buildId,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    validateRootLayout,\n  }: ContinueStreamOptions\n): Promise<ReadableStream<Uint8Array>> {\n  // Suffix itself might contain close tags at the end, so we need to split it.\n  const suffixUnclosed = suffix ? suffix.split(CLOSE_TAG, 1)[0] : null\n\n  // If we're generating static HTML we need to wait for it to resolve before continuing.\n  if (isStaticGeneration) {\n    await renderStream.allReady\n  }\n\n  return chainTransformers(renderStream, [\n    // Buffer everything to avoid flushing too frequently\n    createBufferedTransformStream(),\n\n    // Add build id comment to start of the HTML document (in export mode)\n    createPrefetchCommentStream(isBuildTimePrerendering, buildId),\n\n    // Transform metadata\n    createMetadataTransformStream(getServerInsertedMetadata),\n\n    // Insert suffix content\n    suffixUnclosed != null && suffixUnclosed.length > 0\n      ? createDeferredSuffixStream(suffixUnclosed)\n      : null,\n\n    // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n    inlinedDataStream\n      ? createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      : null,\n\n    // Validate the root layout for missing html or body tags\n    validateRootLayout ? createRootLayoutValidatorStream() : null,\n\n    // Close tags should always be deferred to the end\n    createMoveSuffixStream(),\n\n    // Special head insertions\n    // TODO-APP: Insert server side html to end of head in app layout rendering, to avoid\n    // hydration errors. Remove this once it's ready to be handled by react itself.\n    createHeadInsertionTransformStream(getServerInsertedHTML),\n  ])\n}\n\ntype ContinueDynamicPrerenderOptions = {\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n}\n\nexport async function continueDynamicPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueDynamicPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      .pipeThrough(createStripDocumentClosingTagsTransform())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n  )\n}\n\ntype ContinueStaticPrerenderOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  isBuildTimePrerendering: boolean\n  buildId: string\n}\n\nexport async function continueStaticPrerender(\n  prerenderStream: ReadableStream<Uint8Array>,\n  {\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n    isBuildTimePrerendering,\n    buildId,\n  }: ContinueStaticPrerenderOptions\n) {\n  return (\n    prerenderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Add build id comment to start of the HTML document (in export mode)\n      .pipeThrough(\n        createPrefetchCommentStream(isBuildTimePrerendering, buildId)\n      )\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(inlinedDataStream, true)\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\ntype ContinueResumeOptions = {\n  inlinedDataStream: ReadableStream<Uint8Array>\n  getServerInsertedHTML: () => Promise<string>\n  getServerInsertedMetadata: () => Promise<string>\n  delayDataUntilFirstHtmlChunk: boolean\n}\n\nexport async function continueDynamicHTMLResume(\n  renderStream: ReadableStream<Uint8Array>,\n  {\n    delayDataUntilFirstHtmlChunk,\n    inlinedDataStream,\n    getServerInsertedHTML,\n    getServerInsertedMetadata,\n  }: ContinueResumeOptions\n) {\n  return (\n    renderStream\n      // Buffer everything to avoid flushing too frequently\n      .pipeThrough(createBufferedTransformStream())\n      // Insert generated tags to head\n      .pipeThrough(createHeadInsertionTransformStream(getServerInsertedHTML))\n      // Transform metadata\n      .pipeThrough(createMetadataTransformStream(getServerInsertedMetadata))\n      // Insert the inlined data (Flight data, form state, etc.) stream into the HTML\n      .pipeThrough(\n        createFlightDataInjectionTransformStream(\n          inlinedDataStream,\n          delayDataUntilFirstHtmlChunk\n        )\n      )\n      // Close tags should always be deferred to the end\n      .pipeThrough(createMoveSuffixStream())\n  )\n}\n\nexport function createDocumentClosingStream(): ReadableStream<Uint8Array> {\n  return streamFromString(CLOSE_TAG)\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nimport 'server-only'\n\n/* eslint-disable import/no-extraneous-dependencies */\nimport { renderToReadableStream } from 'react-server-dom-webpack/server'\n/* eslint-disable import/no-extraneous-dependencies */\nimport { createFromReadableStream } from 'react-server-dom-webpack/client'\n\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport {\n  arrayBufferToString,\n  decrypt,\n  encrypt,\n  getActionEncryptionKey,\n  getClientReferenceManifestForRsc,\n  getServerModuleMap,\n  stringToUint8Array,\n} from './encryption-utils'\nimport {\n  getCacheSignal,\n  getPrerenderResumeDataCache,\n  getRenderResumeDataCache,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { createHangingInputAbortSignal } from './dynamic-rendering'\nimport React from 'react'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\n/**\n * Decrypt the serialized string with the action id as the salt.\n */\nasync function decodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (typeof key === 'undefined') {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get the iv (16 bytes) and the payload from the arg.\n  const originalPayload = atob(arg)\n  const ivValue = originalPayload.slice(0, 16)\n  const payload = originalPayload.slice(16)\n\n  const decrypted = textDecoder.decode(\n    await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload))\n  )\n\n  if (!decrypted.startsWith(actionId)) {\n    throw new Error('Invalid Server Action payload: failed to decrypt.')\n  }\n\n  return decrypted.slice(actionId.length)\n}\n\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */\nasync function encodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (key === undefined) {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get 16 random bytes as iv.\n  const randomBytes = new Uint8Array(16)\n  workUnitAsyncStorage.exit(() => crypto.getRandomValues(randomBytes))\n  const ivValue = arrayBufferToString(randomBytes.buffer)\n\n  const encrypted = await encrypt(\n    key,\n    randomBytes,\n    textEncoder.encode(actionId + arg)\n  )\n\n  return btoa(ivValue + arrayBufferToString(encrypted))\n}\n\nenum ReadStatus {\n  Ready,\n  Pending,\n  Complete,\n}\n\n// Encrypts the action's bound args into a string. For the same combination of\n// actionId and args the same cached promise is returned. This ensures reference\n// equality for returned objects from \"use cache\" functions when they're invoked\n// multiple times within one render pass using the same bound args.\nexport const encryptActionBoundArgs = React.cache(\n  async function encryptActionBoundArgs(actionId: string, ...args: any[]) {\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    const cacheSignal = workUnitStore\n      ? getCacheSignal(workUnitStore)\n      : undefined\n\n    const { clientModules } = getClientReferenceManifestForRsc()\n\n    // Create an error before any asynchronous calls, to capture the original\n    // call stack in case we need it when the serialization errors.\n    const error = new Error()\n    Error.captureStackTrace(error, encryptActionBoundArgs)\n\n    let didCatchError = false\n\n    const hangingInputAbortSignal = workUnitStore\n      ? createHangingInputAbortSignal(workUnitStore)\n      : undefined\n\n    let readStatus = ReadStatus.Ready\n    function startReadOnce() {\n      if (readStatus === ReadStatus.Ready) {\n        readStatus = ReadStatus.Pending\n        cacheSignal?.beginRead()\n      }\n    }\n\n    function endReadIfStarted() {\n      if (readStatus === ReadStatus.Pending) {\n        cacheSignal?.endRead()\n      }\n      readStatus = ReadStatus.Complete\n    }\n\n    // streamToString might take longer than a microtask to resolve and then other things\n    // waiting on the cache signal might not realize there is another cache to fill so if\n    // we are no longer waiting on the bound args serialization via the hangingInputAbortSignal\n    // we should eagerly start the cache read to prevent other readers of the cache signal from\n    // missing this cache fill. We use a idempotent function to only start reading once because\n    // it's also possible that streamToString finishes before the hangingInputAbortSignal aborts.\n    if (hangingInputAbortSignal && cacheSignal) {\n      hangingInputAbortSignal.addEventListener('abort', startReadOnce, {\n        once: true,\n      })\n    }\n\n    // Using Flight to serialize the args into a string.\n    const serialized = await streamToString(\n      renderToReadableStream(args, clientModules, {\n        filterStackFrame,\n        signal: hangingInputAbortSignal,\n        onError(err) {\n          if (hangingInputAbortSignal?.aborted) {\n            return\n          }\n\n          // We're only reporting one error at a time, starting with the first.\n          if (didCatchError) {\n            return\n          }\n\n          didCatchError = true\n\n          // Use the original error message together with the previously created\n          // stack, because err.stack is a useless Flight Server call stack.\n          error.message = err instanceof Error ? err.message : String(err)\n        },\n      }),\n      // We pass the abort signal to `streamToString` so that no chunks are\n      // included that are emitted after the signal was already aborted. This\n      // ensures that we can encode hanging promises.\n      hangingInputAbortSignal\n    )\n\n    if (didCatchError) {\n      if (process.env.NODE_ENV === 'development') {\n        // Logging the error is needed for server functions that are passed to the\n        // client where the decryption is not done during rendering. Console\n        // replaying allows us to still show the error dev overlay in this case.\n        console.error(error)\n      }\n\n      endReadIfStarted()\n      throw error\n    }\n\n    if (!workUnitStore) {\n      // We don't need to call cacheSignal.endRead here because we can't have a cacheSignal\n      // if we do not have a workUnitStore.\n      return encodeActionBoundArg(actionId, serialized)\n    }\n\n    startReadOnce()\n\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n    const cacheKey = actionId + serialized\n\n    const cachedEncrypted =\n      prerenderResumeDataCache?.encryptedBoundArgs.get(cacheKey) ??\n      renderResumeDataCache?.encryptedBoundArgs.get(cacheKey)\n\n    if (cachedEncrypted) {\n      return cachedEncrypted\n    }\n\n    const encrypted = await encodeActionBoundArg(actionId, serialized)\n\n    endReadIfStarted()\n    prerenderResumeDataCache?.encryptedBoundArgs.set(cacheKey, encrypted)\n\n    return encrypted\n  }\n)\n\n// Decrypts the action's bound args from the encrypted string.\nexport async function decryptActionBoundArgs(\n  actionId: string,\n  encryptedPromise: Promise<string>\n) {\n  const encrypted = await encryptedPromise\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  let decrypted: string | undefined\n\n  if (workUnitStore) {\n    const cacheSignal = getCacheSignal(workUnitStore)\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n\n    decrypted =\n      prerenderResumeDataCache?.decryptedBoundArgs.get(encrypted) ??\n      renderResumeDataCache?.decryptedBoundArgs.get(encrypted)\n\n    if (!decrypted) {\n      cacheSignal?.beginRead()\n      decrypted = await decodeActionBoundArg(actionId, encrypted)\n      cacheSignal?.endRead()\n      prerenderResumeDataCache?.decryptedBoundArgs.set(encrypted, decrypted)\n    }\n  } else {\n    decrypted = await decodeActionBoundArg(actionId, encrypted)\n  }\n\n  const { edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifestForRsc()\n\n  // Using Flight to deserialize the args from the string.\n  const deserialized = await createFromReadableStream(\n    new ReadableStream({\n      start(controller) {\n        controller.enqueue(textEncoder.encode(decrypted))\n\n        switch (workUnitStore?.type) {\n          case 'prerender':\n          case 'prerender-runtime':\n            // Explicitly don't close the stream here (until prerendering is\n            // complete) so that hanging promises are not rejected.\n            if (workUnitStore.renderSignal.aborted) {\n              controller.close()\n            } else {\n              workUnitStore.renderSignal.addEventListener(\n                'abort',\n                () => controller.close(),\n                { once: true }\n              )\n            }\n            break\n          case 'prerender-client':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          case 'unstable-cache':\n          case undefined:\n            return controller.close()\n          default:\n            workUnitStore satisfies never\n        }\n      },\n    }),\n    {\n      findSourceMapURL,\n      serverConsumerManifest: {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the current execution. Instead, we'll wait for any ClientReference\n        // to be emitted which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n        serverModuleMap: getServerModuleMap(),\n      },\n    }\n  )\n\n  return deserialized\n}\n","(()=>{\"use strict\";var e={328:e=>{function hash(e){var r=5381,_=e.length;while(_){r=r*33^e.charCodeAt(--_)}return r>>>0}e.exports=hash}};var r={};function __nccwpck_require__(_){var a=r[_];if(a!==undefined){return a.exports}var t=r[_]={exports:{}};var i=true;try{e[_](t,t.exports,__nccwpck_require__);i=false}finally{if(i)delete r[_]}return t.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var _=__nccwpck_require__(328);module.exports=_})();","const invalidServerComponentReactHooks = [\n  'useDeferredValue',\n  'useEffect',\n  'useImperativeHandle',\n  'useInsertionEffect',\n  'useLayoutEffect',\n  'useReducer',\n  'useRef',\n  'useState',\n  'useSyncExternalStore',\n  'useTransition',\n  'experimental_useOptimistic',\n  'useOptimistic',\n]\n\nfunction setMessage(error: Error, message: string): void {\n  error.message = message\n  if (error.stack) {\n    const lines = error.stack.split('\\n')\n    lines[0] = message\n    error.stack = lines.join('\\n')\n  }\n}\n\n/**\n * Input:\n * Error: Something went wrong\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10)\n \n * Output:\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10) \n */\nexport function getStackWithoutErrorMessage(error: Error): string {\n  const stack = error.stack\n  if (!stack) return ''\n  return stack.replace(/^[^\\n]*\\n/, '')\n}\n\nexport function formatServerError(error: Error): void {\n  if (typeof error?.message !== 'string') return\n\n  if (\n    error.message.includes(\n      'Class extends value undefined is not a constructor or null'\n    )\n  ) {\n    const addedMessage =\n      'This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component'\n\n    // If this error instance already has the message, don't add it again\n    if (error.message.includes(addedMessage)) return\n\n    setMessage(\n      error,\n      `${error.message}\n\n${addedMessage}`\n    )\n    return\n  }\n\n  if (error.message.includes('createContext is not a function')) {\n    setMessage(\n      error,\n      'createContext only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component'\n    )\n    return\n  }\n\n  for (const clientHook of invalidServerComponentReactHooks) {\n    const regex = new RegExp(`\\\\b${clientHook}\\\\b.*is not a function`)\n    if (regex.test(error.message)) {\n      setMessage(\n        error,\n        `${clientHook} only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`\n      )\n      return\n    }\n  }\n}\n","/* eslint-disable no-redeclare */\nimport type { IncomingMessage } from 'http'\nimport type { ParsedUrlQuery } from 'querystring'\nimport type { UrlWithParsedQuery } from 'url'\nimport type { BaseNextRequest } from './base-http'\nimport type { CloneableBody } from './body-streams'\nimport type { RouteMatch } from './route-matches/route-match'\nimport type { NEXT_RSC_UNION_QUERY } from '../client/components/app-router-headers'\nimport type {\n  ResponseCacheEntry,\n  ServerComponentsHmrCache,\n} from './response-cache'\nimport type { PagesDevOverlayBridgeType } from '../next-devtools/userspace/pages/pages-dev-overlay-setup'\nimport type { OpaqueFallbackRouteParams } from './request/fallback-params'\nimport type { IncrementalCache } from './lib/incremental-cache'\n\n// FIXME: (wyattjoh) this is a temporary solution to allow us to pass data between bundled modules\nexport const NEXT_REQUEST_META = Symbol.for('NextInternalRequestMeta')\n\nexport type NextIncomingMessage = (BaseNextRequest | IncomingMessage) & {\n  [NEXT_REQUEST_META]?: RequestMeta\n}\n\n/**\n * The callback function to call when a response cache entry was generated or\n * looked up in the cache. When it returns true, the server assumes that the\n * handler has already responded to the request and will not do so itself.\n */\nexport type OnCacheEntryHandler = (\n  /**\n   * The response cache entry that was generated or looked up in the cache.\n   */\n  cacheEntry: ResponseCacheEntry,\n\n  /**\n   * The request metadata.\n   */\n  requestMeta: {\n    /**\n     * The URL that was used to make the request.\n     */\n    url: string | undefined\n  }\n) => Promise<boolean | void> | boolean | void\n\nexport interface RequestMeta {\n  /**\n   * The query that was used to make the request.\n   */\n  initQuery?: ParsedUrlQuery\n\n  /**\n   * The URL that was used to make the request.\n   */\n  initURL?: string\n\n  /**\n   * The protocol that was used to make the request.\n   */\n  initProtocol?: string\n\n  /**\n   * The body that was read from the request. This is used to allow the body to\n   * be read multiple times.\n   */\n  clonableBody?: CloneableBody\n\n  /**\n   * True when the request matched a locale domain that was configured in the\n   * next.config.js file.\n   */\n  isLocaleDomain?: boolean\n\n  /**\n   * True when the request had locale information stripped from the pathname\n   * part of the URL.\n   */\n  didStripLocale?: boolean\n\n  /**\n   * If the request had it's URL rewritten, this is the URL it was rewritten to.\n   */\n  rewroteURL?: string\n\n  /**\n   * The cookies that were added by middleware and were added to the response.\n   */\n  middlewareCookie?: string[]\n\n  /**\n   * The match on the request for a given route.\n   */\n  match?: RouteMatch\n\n  /**\n   * The incremental cache to use for the request.\n   */\n  incrementalCache?: IncrementalCache\n\n  /**\n   * The server components HMR cache, only for dev.\n   */\n  serverComponentsHmrCache?: ServerComponentsHmrCache\n\n  /**\n   * Equals the segment path that was used for the prefetch RSC request.\n   */\n  segmentPrefetchRSCRequest?: string\n\n  /**\n   * True when the request is for the prefetch flight data.\n   */\n  isPrefetchRSCRequest?: true\n\n  /**\n   * True when the request is for the flight data.\n   */\n  isRSCRequest?: true\n\n  /**\n   * A search param set by the Next.js client when performing RSC requests.\n   * Because some CDNs do not vary their cache entries on our custom headers,\n   * this search param represents a hash of the header values. For any cached\n   * RSC request, we should verify that the hash matches before responding.\n   * Otherwise this can lead to cache poisoning.\n   * TODO: Consider not using custom request headers at all, and instead encode\n   * everything into the search param.\n   */\n  cacheBustingSearchParam?: string\n\n  /**\n   * True when the request is for the `/_next/data` route using the pages\n   * router.\n   */\n  isNextDataReq?: true\n\n  /**\n   * Postponed state to use for resumption. If present it's assumed that the\n   * request is for a page that has postponed (there are no guarantees that the\n   * page actually has postponed though as it would incur an additional cache\n   * lookup).\n   */\n  postponed?: string\n\n  /**\n   * If provided, this will be called when a response cache entry was generated\n   * or looked up in the cache.\n   *\n   * @deprecated Use `onCacheEntryV2` instead.\n   */\n  onCacheEntry?: OnCacheEntryHandler\n\n  /**\n   * If provided, this will be called when a response cache entry was generated\n   * or looked up in the cache.\n   */\n  onCacheEntryV2?: OnCacheEntryHandler\n\n  /**\n   * The previous revalidate before rendering 404 page for notFound: true\n   */\n  notFoundRevalidate?: number | false\n\n  /**\n   * In development, the original source page that returned a 404.\n   */\n  developmentNotFoundSourcePage?: string\n\n  /**\n   * The path we routed to and should be invoked\n   */\n  invokePath?: string\n\n  /**\n   * The specific page output we should be matching\n   */\n  invokeOutput?: string\n\n  /**\n   * The status we are invoking the request with from routing\n   */\n  invokeStatus?: number\n\n  /**\n   * The routing error we are invoking with\n   */\n  invokeError?: Error\n\n  /**\n   * The query parsed for the invocation\n   */\n  invokeQuery?: Record<string, undefined | string | string[]>\n\n  /**\n   * Whether the request is a middleware invocation\n   */\n  middlewareInvoke?: boolean\n\n  /**\n   * Whether the request should render the fallback shell or not.\n   */\n  renderFallbackShell?: boolean\n\n  /**\n   * Whether the request is for the custom error page.\n   */\n  customErrorRender?: true\n\n  /**\n   * Whether to bubble up the NoFallbackError to the caller when a 404 is\n   * returned.\n   */\n  bubbleNoFallback?: true\n\n  /**\n   * True when the request had locale information inferred from the default\n   * locale.\n   */\n  localeInferredFromDefault?: true\n\n  /**\n   * The locale that was inferred or explicitly set for the request.\n   */\n  locale?: string\n\n  /**\n   * The default locale that was inferred or explicitly set for the request.\n   */\n  defaultLocale?: string\n\n  /**\n   * The relative project dir the server is running in from project root\n   */\n  relativeProjectDir?: string\n\n  /**\n   * The dist directory the server is currently using\n   */\n  distDir?: string\n\n  /**\n   * The query after resolving routes\n   */\n  query?: ParsedUrlQuery\n\n  /**\n   * The params after resolving routes\n   */\n  params?: ParsedUrlQuery\n\n  /**\n   * ErrorOverlay component to use in development for pages router\n   */\n  PagesErrorDebug?: PagesDevOverlayBridgeType\n\n  /**\n   * Whether server is in minimal mode (this will be replaced with more\n   * specific flags in future)\n   */\n  minimalMode?: boolean\n\n  /**\n   * DEV only: The fallback params that should be used when validating prerenders during dev\n   */\n  devValidatingFallbackParams?: OpaqueFallbackRouteParams\n}\n\n/**\n * Gets the request metadata. If no key is provided, the entire metadata object\n * is returned.\n *\n * @param req the request to get the metadata from\n * @param key the key to get from the metadata (optional)\n * @returns the value for the key or the entire metadata object\n */\nexport function getRequestMeta(\n  req: NextIncomingMessage,\n  key?: undefined\n): RequestMeta\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key: K\n): RequestMeta[K]\nexport function getRequestMeta<K extends keyof RequestMeta>(\n  req: NextIncomingMessage,\n  key?: K\n): RequestMeta | RequestMeta[K] {\n  const meta = req[NEXT_REQUEST_META] || {}\n  return typeof key === 'string' ? meta[key] : meta\n}\n\n/**\n * Sets the request metadata.\n *\n * @param req the request to set the metadata on\n * @param meta the metadata to set\n * @returns the mutated request metadata\n */\nexport function setRequestMeta(req: NextIncomingMessage, meta: RequestMeta) {\n  req[NEXT_REQUEST_META] = meta\n  return meta\n}\n\n/**\n * Adds a value to the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to set\n * @param value the value to set\n * @returns the mutated request metadata\n */\nexport function addRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K,\n  value: RequestMeta[K]\n) {\n  const meta = getRequestMeta(request)\n  meta[key] = value\n  return setRequestMeta(request, meta)\n}\n\n/**\n * Removes a key from the request metadata.\n *\n * @param request the request to mutate\n * @param key the key to remove\n * @returns the mutated request metadata\n */\nexport function removeRequestMeta<K extends keyof RequestMeta>(\n  request: NextIncomingMessage,\n  key: K\n) {\n  const meta = getRequestMeta(request)\n  delete meta[key]\n  return setRequestMeta(request, meta)\n}\n\ntype NextQueryMetadata = {\n  /**\n   * The `_rsc` query parameter used for cache busting to ensure that the RSC\n   * requests do not get cached by the browser explicitly.\n   */\n  [NEXT_RSC_UNION_QUERY]?: string\n}\n\nexport type NextParsedUrlQuery = ParsedUrlQuery & NextQueryMetadata\n\nexport interface NextUrlWithParsedQuery extends UrlWithParsedQuery {\n  query: NextParsedUrlQuery\n}\n","import type { BaseNextRequest, BaseNextResponse } from './'\nimport type { NodeNextRequest, NodeNextResponse } from './node'\nimport type { WebNextRequest, WebNextResponse } from './web'\n\n/**\n * This file provides some helpers that should be used in conjunction with\n * explicit environment checks. When combined with the environment checks, it\n * will ensure that the correct typings are used as well as enable code\n * elimination.\n */\n\n/**\n * Type guard to determine if a request is a WebNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base request is a WebNextRequest.\n */\nexport const isWebNextRequest = (req: BaseNextRequest): req is WebNextRequest =>\n  process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a response is a WebNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the edge runtime, that any\n * base response is a WebNextResponse.\n */\nexport const isWebNextResponse = (\n  res: BaseNextResponse\n): res is WebNextResponse => process.env.NEXT_RUNTIME === 'edge'\n\n/**\n * Type guard to determine if a request is a NodeNextRequest. This does not\n * actually check the type of the request, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base request is a NodeNextRequest.\n */\nexport const isNodeNextRequest = (\n  req: BaseNextRequest\n): req is NodeNextRequest => process.env.NEXT_RUNTIME !== 'edge'\n\n/**\n * Type guard to determine if a response is a NodeNextResponse. This does not\n * actually check the type of the response, but rather the runtime environment.\n * It's expected that when the runtime environment is the node runtime, that any\n * base response is a NodeNextResponse.\n */\nexport const isNodeNextResponse = (\n  res: BaseNextResponse\n): res is NodeNextResponse => process.env.NEXT_RUNTIME !== 'edge'\n","import type { BaseNextRequest } from '../../../base-http'\nimport type { NodeNextRequest } from '../../../base-http/node'\nimport type { WebNextRequest } from '../../../base-http/web'\nimport type { Writable } from 'node:stream'\n\nimport { getRequestMeta } from '../../../request-meta'\nimport { fromNodeOutgoingHttpHeaders } from '../../utils'\nimport { NextRequest } from '../request'\nimport { isNodeNextRequest, isWebNextRequest } from '../../../base-http/helpers'\n\nexport const ResponseAbortedName = 'ResponseAborted'\nexport class ResponseAborted extends Error {\n  public readonly name = ResponseAbortedName\n}\n\n/**\n * Creates an AbortController tied to the closing of a ServerResponse (or other\n * appropriate Writable).\n *\n * If the `close` event is fired before the `finish` event, then we'll send the\n * `abort` signal.\n */\nexport function createAbortController(response: Writable): AbortController {\n  const controller = new AbortController()\n\n  // If `finish` fires first, then `res.end()` has been called and the close is\n  // just us finishing the stream on our side. If `close` fires first, then we\n  // know the client disconnected before we finished.\n  response.once('close', () => {\n    if (response.writableFinished) return\n\n    controller.abort(new ResponseAborted())\n  })\n\n  return controller\n}\n\n/**\n * Creates an AbortSignal tied to the closing of a ServerResponse (or other\n * appropriate Writable).\n *\n * This cannot be done with the request (IncomingMessage or Readable) because\n * the `abort` event will not fire if to data has been fully read (because that\n * will \"close\" the readable stream and nothing fires after that).\n */\nexport function signalFromNodeResponse(response: Writable): AbortSignal {\n  const { errored, destroyed } = response\n  if (errored || destroyed) {\n    return AbortSignal.abort(errored ?? new ResponseAborted())\n  }\n\n  const { signal } = createAbortController(response)\n  return signal\n}\n\nexport class NextRequestAdapter {\n  public static fromBaseNextRequest(\n    request: BaseNextRequest,\n    signal: AbortSignal\n  ): NextRequest {\n    if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME === 'edge' &&\n      isWebNextRequest(request)\n    ) {\n      return NextRequestAdapter.fromWebNextRequest(request)\n    } else if (\n      // The type check here ensures that `req` is correctly typed, and the\n      // environment variable check provides dead code elimination.\n      process.env.NEXT_RUNTIME !== 'edge' &&\n      isNodeNextRequest(request)\n    ) {\n      return NextRequestAdapter.fromNodeNextRequest(request, signal)\n    } else {\n      throw new Error('Invariant: Unsupported NextRequest type')\n    }\n  }\n\n  public static fromNodeNextRequest(\n    request: NodeNextRequest,\n    signal: AbortSignal\n  ): NextRequest {\n    // HEAD and GET requests can not have a body.\n    let body: BodyInit | null = null\n    if (request.method !== 'GET' && request.method !== 'HEAD' && request.body) {\n      // @ts-expect-error - this is handled by undici, when streams/web land use it instead\n      body = request.body\n    }\n\n    let url: URL\n    if (request.url.startsWith('http')) {\n      url = new URL(request.url)\n    } else {\n      // Grab the full URL from the request metadata.\n      const base = getRequestMeta(request, 'initURL')\n      if (!base || !base.startsWith('http')) {\n        // Because the URL construction relies on the fact that the URL provided\n        // is absolute, we need to provide a base URL. We can't use the request\n        // URL because it's relative, so we use a dummy URL instead.\n        url = new URL(request.url, 'http://n')\n      } else {\n        url = new URL(request.url, base)\n      }\n    }\n\n    return new NextRequest(url, {\n      method: request.method,\n      headers: fromNodeOutgoingHttpHeaders(request.headers),\n      duplex: 'half',\n      signal,\n      // geo\n      // ip\n      // nextConfig\n\n      // body can not be passed if request was aborted\n      // or we get a Request body was disturbed error\n      ...(signal.aborted\n        ? {}\n        : {\n            body,\n          }),\n    })\n  }\n\n  public static fromWebNextRequest(request: WebNextRequest): NextRequest {\n    // HEAD and GET requests can not have a body.\n    let body: ReadableStream | null = null\n    if (request.method !== 'GET' && request.method !== 'HEAD') {\n      body = request.body\n    }\n\n    return new NextRequest(request.url, {\n      method: request.method,\n      headers: fromNodeOutgoingHttpHeaders(request.headers),\n      duplex: 'half',\n      signal: request.request.signal,\n      // geo\n      // ip\n      // nextConfig\n\n      // body can not be passed if request was aborted\n      // or we get a Request body was disturbed error\n      ...(request.request.signal.aborted\n        ? {}\n        : {\n            body,\n          }),\n    })\n  }\n}\n","import type { AppPageModule } from './route-modules/app-page/module'\n\n// Combined load times for loading client components\nlet clientComponentLoadStart = 0\nlet clientComponentLoadTimes = 0\nlet clientComponentLoadCount = 0\n\nexport function wrapClientComponentLoader(\n  ComponentMod: AppPageModule\n): AppPageModule['__next_app__'] {\n  if (!('performance' in globalThis)) {\n    return ComponentMod.__next_app__\n  }\n\n  return {\n    require: (...args) => {\n      const startTime = performance.now()\n\n      if (clientComponentLoadStart === 0) {\n        clientComponentLoadStart = startTime\n      }\n\n      try {\n        clientComponentLoadCount += 1\n        return ComponentMod.__next_app__.require(...args)\n      } finally {\n        clientComponentLoadTimes += performance.now() - startTime\n      }\n    },\n    loadChunk: (...args) => {\n      const startTime = performance.now()\n      const result = ComponentMod.__next_app__.loadChunk(...args)\n      // Avoid wrapping `loadChunk`'s result in an extra promise in case something like React depends on its identity.\n      // We only need to know when it's settled.\n      result.finally(() => {\n        clientComponentLoadTimes += performance.now() - startTime\n      })\n      return result\n    },\n  }\n}\n\nexport function getClientComponentLoaderMetrics(\n  options: { reset?: boolean } = {}\n) {\n  const metrics =\n    clientComponentLoadStart === 0\n      ? undefined\n      : {\n          clientComponentLoadStart,\n          clientComponentLoadTimes,\n          clientComponentLoadCount,\n        }\n\n  if (options.reset) {\n    clientComponentLoadStart = 0\n    clientComponentLoadTimes = 0\n    clientComponentLoadCount = 0\n  }\n\n  return metrics\n}\n","import type { ServerResponse } from 'node:http'\n\nimport {\n  ResponseAbortedName,\n  createAbortController,\n} from './web/spec-extension/adapters/next-request'\nimport { DetachedPromise } from '../lib/detached-promise'\nimport { getTracer } from './lib/trace/tracer'\nimport { NextNodeServerSpan } from './lib/trace/constants'\nimport { getClientComponentLoaderMetrics } from './client-component-renderer-logger'\n\nexport function isAbortError(e: any): e is Error & { name: 'AbortError' } {\n  return e?.name === 'AbortError' || e?.name === ResponseAbortedName\n}\n\nfunction createWriterFromResponse(\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n): WritableStream<Uint8Array> {\n  let started = false\n\n  // Create a promise that will resolve once the response has drained. See\n  // https://nodejs.org/api/stream.html#stream_event_drain\n  let drained = new DetachedPromise<void>()\n  function onDrain() {\n    drained.resolve()\n  }\n  res.on('drain', onDrain)\n\n  // If the finish event fires, it means we shouldn't block and wait for the\n  // drain event.\n  res.once('close', () => {\n    res.off('drain', onDrain)\n    drained.resolve()\n  })\n\n  // Create a promise that will resolve once the response has finished. See\n  // https://nodejs.org/api/http.html#event-finish_1\n  const finished = new DetachedPromise<void>()\n  res.once('finish', () => {\n    finished.resolve()\n  })\n\n  // Create a writable stream that will write to the response.\n  return new WritableStream<Uint8Array>({\n    write: async (chunk) => {\n      // You'd think we'd want to use `start` instead of placing this in `write`\n      // but this ensures that we don't actually flush the headers until we've\n      // started writing chunks.\n      if (!started) {\n        started = true\n\n        if (\n          'performance' in globalThis &&\n          process.env.NEXT_OTEL_PERFORMANCE_PREFIX\n        ) {\n          const metrics = getClientComponentLoaderMetrics()\n          if (metrics) {\n            performance.measure(\n              `${process.env.NEXT_OTEL_PERFORMANCE_PREFIX}:next-client-component-loading`,\n              {\n                start: metrics.clientComponentLoadStart,\n                end:\n                  metrics.clientComponentLoadStart +\n                  metrics.clientComponentLoadTimes,\n              }\n            )\n          }\n        }\n\n        res.flushHeaders()\n        getTracer().trace(\n          NextNodeServerSpan.startResponse,\n          {\n            spanName: 'start response',\n          },\n          () => undefined\n        )\n      }\n\n      try {\n        const ok = res.write(chunk)\n\n        // Added by the `compression` middleware, this is a function that will\n        // flush the partially-compressed response to the client.\n        if ('flush' in res && typeof res.flush === 'function') {\n          res.flush()\n        }\n\n        // If the write returns false, it means there's some backpressure, so\n        // wait until it's streamed before continuing.\n        if (!ok) {\n          await drained.promise\n\n          // Reset the drained promise so that we can wait for the next drain event.\n          drained = new DetachedPromise<void>()\n        }\n      } catch (err) {\n        res.end()\n        throw new Error('failed to write chunk to response', { cause: err })\n      }\n    },\n    abort: (err) => {\n      if (res.writableFinished) return\n\n      res.destroy(err)\n    },\n    close: async () => {\n      // if a waitUntil promise was passed, wait for it to resolve before\n      // ending the response.\n      if (waitUntilForEnd) {\n        await waitUntilForEnd\n      }\n\n      if (res.writableFinished) return\n\n      res.end()\n      return finished.promise\n    },\n  })\n}\n\nexport async function pipeToNodeResponse(\n  readable: ReadableStream<Uint8Array>,\n  res: ServerResponse,\n  waitUntilForEnd?: Promise<unknown>\n) {\n  try {\n    // If the response has already errored, then just return now.\n    const { errored, destroyed } = res\n    if (errored || destroyed) return\n\n    // Create a new AbortController so that we can abort the readable if the\n    // client disconnects.\n    const controller = createAbortController(res)\n\n    const writer = createWriterFromResponse(res, waitUntilForEnd)\n\n    await readable.pipeTo(writer, { signal: controller.signal })\n  } catch (err: any) {\n    // If this isn't related to an abort error, re-throw it.\n    if (isAbortError(err)) return\n\n    throw new Error('failed to pipe response', { cause: err })\n  }\n}\n","export const HTTPAccessErrorStatus = {\n  NOT_FOUND: 404,\n  FORBIDDEN: 403,\n  UNAUTHORIZED: 401,\n}\n\nconst ALLOWED_CODES = new Set(Object.values(HTTPAccessErrorStatus))\n\nexport const HTTP_ERROR_FALLBACK_ERROR_CODE = 'NEXT_HTTP_ERROR_FALLBACK'\n\nexport type HTTPAccessFallbackError = Error & {\n  digest: `${typeof HTTP_ERROR_FALLBACK_ERROR_CODE};${string}`\n}\n\n/**\n * Checks an error to determine if it's an error generated by\n * the HTTP navigation APIs `notFound()`, `forbidden()` or `unauthorized()`.\n *\n * @param error the error that may reference a HTTP access error\n * @returns true if the error is a HTTP access error\n */\nexport function isHTTPAccessFallbackError(\n  error: unknown\n): error is HTTPAccessFallbackError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n  const [prefix, httpStatus] = error.digest.split(';')\n\n  return (\n    prefix === HTTP_ERROR_FALLBACK_ERROR_CODE &&\n    ALLOWED_CODES.has(Number(httpStatus))\n  )\n}\n\nexport function getAccessFallbackHTTPStatus(\n  error: HTTPAccessFallbackError\n): number {\n  const httpStatus = error.digest.split(';')[1]\n  return Number(httpStatus)\n}\n\nexport function getAccessFallbackErrorTypeByStatus(\n  status: number\n): 'not-found' | 'forbidden' | 'unauthorized' | undefined {\n  switch (status) {\n    case 401:\n      return 'unauthorized'\n    case 403:\n      return 'forbidden'\n    case 404:\n      return 'not-found'\n    default:\n      return\n  }\n}\n","export enum RedirectStatusCode {\n  SeeOther = 303,\n  TemporaryRedirect = 307,\n  PermanentRedirect = 308,\n}\n","import { RedirectStatusCode } from './redirect-status-code'\n\nexport const REDIRECT_ERROR_CODE = 'NEXT_REDIRECT'\n\nexport enum RedirectType {\n  push = 'push',\n  replace = 'replace',\n}\n\nexport type RedirectError = Error & {\n  digest: `${typeof REDIRECT_ERROR_CODE};${RedirectType};${string};${RedirectStatusCode};`\n}\n\n/**\n * Checks an error to determine if it's an error generated by the\n * `redirect(url)` helper.\n *\n * @param error the error that may reference a redirect error\n * @returns true if the error is a redirect error\n */\nexport function isRedirectError(error: unknown): error is RedirectError {\n  if (\n    typeof error !== 'object' ||\n    error === null ||\n    !('digest' in error) ||\n    typeof error.digest !== 'string'\n  ) {\n    return false\n  }\n\n  const digest = error.digest.split(';')\n  const [errorCode, type] = digest\n  const destination = digest.slice(2, -2).join(';')\n  const status = digest.at(-2)\n\n  const statusCode = Number(status)\n\n  return (\n    errorCode === REDIRECT_ERROR_CODE &&\n    (type === 'replace' || type === 'push') &&\n    typeof destination === 'string' &&\n    !isNaN(statusCode) &&\n    statusCode in RedirectStatusCode\n  )\n}\n","import {\n  isHTTPAccessFallbackError,\n  type HTTPAccessFallbackError,\n} from './http-access-fallback/http-access-fallback'\nimport { isRedirectError, type RedirectError } from './redirect-error'\n\n/**\n * Returns true if the error is a navigation signal error. These errors are\n * thrown by user code to perform navigation operations and interrupt the React\n * render.\n */\nexport function isNextRouterError(\n  error: unknown\n): error is RedirectError | HTTPAccessFallbackError {\n  return isRedirectError(error) || isHTTPAccessFallbackError(error)\n}\n","export function getObjectClassLabel(value: any): string {\n  return Object.prototype.toString.call(value)\n}\n\nexport function isPlainObject(value: any): boolean {\n  if (getObjectClassLabel(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n\n  /**\n   * this used to be previously:\n   *\n   * `return prototype === null || prototype === Object.prototype`\n   *\n   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.\n   *\n   * It was changed to the current implementation since it's resilient to serialization.\n   */\n  return prototype === null || prototype.hasOwnProperty('isPrototypeOf')\n}\n","import { isPlainObject } from '../shared/lib/is-plain-object'\n\n// We allow some additional attached properties for Next.js errors\nexport interface NextError extends Error {\n  type?: string\n  page?: string\n  code?: string | number\n  cancelled?: boolean\n  digest?: number\n}\n\n/**\n * Checks whether the given value is a NextError.\n * This can be used to print a more detailed error message with properties like `code` & `digest`.\n */\nexport default function isError(err: unknown): err is NextError {\n  return (\n    typeof err === 'object' && err !== null && 'name' in err && 'message' in err\n  )\n}\n\n/**\n * This is a safe stringify function that handles circular references.\n */\nexport function safeStringify(obj: any) {\n  const seen = new WeakSet()\n\n  return JSON.stringify(obj, (_key, value) => {\n    // If value is an object and already seen, replace with \"[Circular]\"\n    if (typeof value === 'object' && value !== null) {\n      if (seen.has(value)) {\n        return '[Circular]'\n      }\n      seen.add(value)\n    }\n    return value\n  })\n}\n\nexport function getProperError(err: unknown): Error {\n  if (isError(err)) {\n    return err\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // provide better error for case where `throw undefined`\n    // is called in development\n    if (typeof err === 'undefined') {\n      return new Error(\n        'An undefined error was thrown, ' +\n          'see here for more info: https://nextjs.org/docs/messages/threw-undefined'\n      )\n    }\n\n    if (err === null) {\n      return new Error(\n        'A null error was thrown, ' +\n          'see here for more info: https://nextjs.org/docs/messages/threw-undefined'\n      )\n    }\n  }\n\n  return new Error(isPlainObject(err) ? safeStringify(err) : err + '')\n}\n","const ERROR_CODE_DELIMITER = '@'\n\n/**\n * Augments the digest field of errors thrown in React Server Components (RSC) with an error code.\n * Since RSC errors can only be serialized through the digest field, this provides a way to include\n * an additional error code that can be extracted client-side via `extractNextErrorCode`.\n *\n * The error code is appended to the digest string with a semicolon separator, allowing it to be\n * parsed out later while preserving the original digest value.\n */\nexport const createDigestWithErrorCode = (\n  thrownValue: unknown,\n  originalDigest: string\n): string => {\n  if (\n    typeof thrownValue === 'object' &&\n    thrownValue !== null &&\n    '__NEXT_ERROR_CODE' in thrownValue\n  ) {\n    return `${originalDigest}${ERROR_CODE_DELIMITER}${thrownValue.__NEXT_ERROR_CODE}`\n  }\n  return originalDigest\n}\n\nexport const extractNextErrorCode = (error: unknown): string | undefined => {\n  if (\n    typeof error === 'object' &&\n    error !== null &&\n    '__NEXT_ERROR_CODE' in error &&\n    typeof error.__NEXT_ERROR_CODE === 'string'\n  ) {\n    return error.__NEXT_ERROR_CODE\n  }\n\n  if (\n    typeof error === 'object' &&\n    error !== null &&\n    'digest' in error &&\n    typeof error.digest === 'string'\n  ) {\n    const segments = error.digest.split(ERROR_CODE_DELIMITER)\n    const errorCode = segments.find((segment) => segment.startsWith('E'))\n    return errorCode\n  }\n\n  return undefined\n}\n","// TODO: isWellKnownError -> isNextInternalError\n// isReactLargeShellError -> isWarning\nexport function isReactLargeShellError(\n  error: unknown\n): error is Error & { digest?: string } {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'message' in error &&\n    typeof error.message === 'string' &&\n    error.message.startsWith('This rendered a large document (>')\n  )\n}\n","import type { ErrorInfo } from 'react'\n\nimport stringHash from 'next/dist/compiled/string-hash'\nimport { formatServerError } from '../../lib/format-server-error'\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer'\nimport { isAbortError } from '../pipe-readable'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport { isNextRouterError } from '../../client/components/is-next-router-error'\nimport { isPrerenderInterruptedError } from './dynamic-rendering'\nimport { getProperError } from '../../lib/is-error'\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils'\nimport { isReactLargeShellError } from './react-large-shell-error'\n\ndeclare global {\n  var __next_log_error__: undefined | ((err: unknown) => void)\n}\n\ntype RSCErrorHandler = (err: unknown) => string | undefined\ntype SSRErrorHandler = (\n  err: unknown,\n  errorInfo?: ErrorInfo\n) => string | undefined\n\nexport type DigestedError = Error & { digest: string }\n\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */\nexport function getDigestForWellKnownError(error: unknown): string | undefined {\n  // If we're bailing out to CSR, we don't need to log the error.\n  if (isBailoutToCSRError(error)) return error.digest\n\n  // If this is a navigation error, we don't need to log the error.\n  if (isNextRouterError(error)) return error.digest\n\n  // If this error occurs, we know that we should be stopping the static\n  // render. This is only thrown in static generation when PPR is not enabled,\n  // which causes the whole page to be marked as dynamic. We don't need to\n  // tell the user about this error, as it's not actionable.\n  if (isDynamicServerError(error)) return error.digest\n\n  // If this is a prerender interrupted error, we don't need to log the error.\n  if (isPrerenderInterruptedError(error)) return error.digest\n\n  return undefined\n}\n\nexport function createFlightReactServerErrorHandler(\n  shouldFormatError: boolean,\n  onReactServerRenderError: (err: DigestedError) => void\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (!err.digest) {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      err.digest = stringHash(err.message + err.stack || '').toString()\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Record exception in an active span, if available.\n    const span = getTracer().getActiveScopeSpan()\n    if (span) {\n      span.recordException(err)\n      span.setAttribute('error.type', err.name)\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err.message,\n      })\n    }\n\n    onReactServerRenderError(err)\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function createHTMLReactServerErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  silenceLogger: boolean,\n  onReactServerRenderError: undefined | ((err: DigestedError) => void)\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (!err.digest) {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      err.digest = stringHash(err.message + (err.stack || '')).toString()\n    }\n\n    // @TODO by putting this here and not at the top it is possible that\n    // we don't error the build in places we actually expect to\n    if (!reactServerErrors.has(err.digest)) {\n      reactServerErrors.set(err.digest, err)\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception in an active span, if available.\n      const span = getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setAttribute('error.type', err.name)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      if (!silenceLogger) {\n        onReactServerRenderError?.(err)\n      }\n    }\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function createHTMLErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  allCapturedErrors: Array<unknown>,\n  silenceLogger: boolean,\n  onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) => void\n): SSRErrorHandler {\n  return (thrownValue: unknown, errorInfo?: ErrorInfo) => {\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    let isSSRError = true\n\n    allCapturedErrors.push(thrownValue)\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (reactServerErrors.has(err.digest)) {\n        // This error is likely an obfuscated error from react-server.\n        // We recover the original error here.\n        thrownValue = reactServerErrors.get(err.digest)\n        isSSRError = false\n      } else {\n        // The error is not from react-server but has a digest\n        // from other means so we don't need to produce a new one\n      }\n    } else {\n      err.digest = stringHash(\n        err.message + (errorInfo?.componentStack || err.stack || '')\n      ).toString()\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception in an active span, if available.\n      const span = getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setAttribute('error.type', err.name)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      if (\n        !silenceLogger &&\n        // HTML errors contain RSC errors as well, filter them out before reporting\n        isSSRError\n      ) {\n        onHTMLRenderSSRError(err, errorInfo)\n      }\n    }\n\n    return createDigestWithErrorCode(thrownValue, err.digest)\n  }\n}\n\nexport function isUserLandError(err: any): boolean {\n  return (\n    !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err)\n  )\n}\n","export const DYNAMIC_EXPIRE = 300 // 5 minutes\nexport const RUNTIME_PREFETCH_DYNAMIC_STALE = 30 // 30 seconds\n","import DefaultCacheHandler from '../lib/cache-handlers/default.external'\nimport type { CacheHandler } from '../lib/cache-handlers/types'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? (message: string, ...args: any[]) => {\n      console.log(`use-cache: ${message}`, ...args)\n    }\n  : undefined\n\nconst handlersSymbol = Symbol.for('@next/cache-handlers')\nconst handlersMapSymbol = Symbol.for('@next/cache-handlers-map')\nconst handlersSetSymbol = Symbol.for('@next/cache-handlers-set')\n\n/**\n * The reference to the cache handlers. We store the cache handlers on the\n * global object so that we can access the same instance across different\n * boundaries (such as different copies of the same module).\n */\nconst reference: typeof globalThis & {\n  [handlersSymbol]?: {\n    RemoteCache?: CacheHandler\n    DefaultCache?: CacheHandler\n  }\n  [handlersMapSymbol]?: Map<string, CacheHandler>\n  [handlersSetSymbol]?: Set<CacheHandler>\n} = globalThis\n\n/**\n * Initialize the cache handlers.\n * @returns `true` if the cache handlers were initialized, `false` if they were already initialized.\n */\nexport function initializeCacheHandlers(): boolean {\n  // If the cache handlers have already been initialized, don't do it again.\n  if (reference[handlersMapSymbol]) {\n    debug?.('cache handlers already initialized')\n    return false\n  }\n\n  debug?.('initializing cache handlers')\n  reference[handlersMapSymbol] = new Map<string, CacheHandler>()\n\n  // Initialize the cache from the symbol contents first.\n  if (reference[handlersSymbol]) {\n    let fallback: CacheHandler\n    if (reference[handlersSymbol].DefaultCache) {\n      debug?.('setting \"default\" cache handler from symbol')\n      fallback = reference[handlersSymbol].DefaultCache\n    } else {\n      debug?.('setting \"default\" cache handler from default')\n      fallback = DefaultCacheHandler\n    }\n\n    reference[handlersMapSymbol].set('default', fallback)\n\n    if (reference[handlersSymbol].RemoteCache) {\n      debug?.('setting \"remote\" cache handler from symbol')\n      reference[handlersMapSymbol].set(\n        'remote',\n        reference[handlersSymbol].RemoteCache\n      )\n    } else {\n      debug?.('setting \"remote\" cache handler from default')\n      reference[handlersMapSymbol].set('remote', fallback)\n    }\n  } else {\n    debug?.('setting \"default\" cache handler from default')\n    reference[handlersMapSymbol].set('default', DefaultCacheHandler)\n    debug?.('setting \"remote\" cache handler from default')\n    reference[handlersMapSymbol].set('remote', DefaultCacheHandler)\n  }\n\n  // Create a set of the cache handlers.\n  reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())\n\n  return true\n}\n\n/**\n * Get a cache handler by kind.\n * @param kind - The kind of cache handler to get.\n * @returns The cache handler, or `undefined` if it does not exist.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandler(kind: string): CacheHandler | undefined {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  return reference[handlersMapSymbol].get(kind)\n}\n\n/**\n * Get a set iterator over the cache handlers.\n * @returns An iterator over the cache handlers, or `undefined` if they are not\n * initialized.\n */\nexport function getCacheHandlers(): SetIterator<CacheHandler> | undefined {\n  if (!reference[handlersSetSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersSetSymbol].values()\n}\n\n/**\n * Get a map iterator over the cache handlers (keyed by kind).\n * @returns An iterator over the cache handler entries, or `undefined` if they\n * are not initialized.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandlerEntries():\n  | MapIterator<[string, CacheHandler]>\n  | undefined {\n  if (!reference[handlersMapSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersMapSymbol].entries()\n}\n\n/**\n * Set a cache handler by kind.\n * @param kind - The kind of cache handler to set.\n * @param cacheHandler - The cache handler to set.\n */\nexport function setCacheHandler(\n  kind: string,\n  cacheHandler: CacheHandler\n): void {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  debug?.('setting cache handler for \"%s\"', kind)\n  reference[handlersMapSymbol].set(kind, cacheHandler)\n  reference[handlersSetSymbol].add(cacheHandler)\n}\n","const USE_CACHE_TIMEOUT_ERROR_CODE = 'USE_CACHE_TIMEOUT'\n\nexport class UseCacheTimeoutError extends Error {\n  digest: typeof USE_CACHE_TIMEOUT_ERROR_CODE = USE_CACHE_TIMEOUT_ERROR_CODE\n\n  constructor() {\n    super(\n      'Filling a cache during prerender timed out, likely because request-specific arguments such as params, searchParams, cookies() or dynamic data were used inside \"use cache\".'\n    )\n  }\n}\n\nexport function isUseCacheTimeoutError(\n  err: unknown\n): err is UseCacheTimeoutError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === USE_CACHE_TIMEOUT_ERROR_CODE\n}\n","// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `_` is a valid identifier it's ok to print `searchParams['_']`\n// even if this would have been fine too `searchParams._`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/\n\nexport function describeStringPropertyAccess(target: string, prop: string) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``\n}\n\nexport function describeHasCheckingStringProperty(\n  target: string,\n  prop: string\n) {\n  const stringifiedProp = JSON.stringify(prop)\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`\n}\n\nexport const wellKnownProperties = new Set([\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toString',\n  'valueOf',\n  'toLocaleString',\n\n  // Promise prototype\n  // fallthrough\n  'then',\n  'catch',\n  'finally',\n\n  // React Promise extension\n  // fallthrough\n  'status',\n\n  // React introspection\n  'displayName',\n  '_debugInfo',\n\n  // Common tested properties\n  // fallthrough\n  'toJSON',\n  '$$typeof',\n  '__esModule',\n])\n","import type { WorkStore } from '../app-render/work-async-storage.external'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  annotateDynamicAccess,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreLegacy,\n  type PrerenderStorePPR,\n  type PrerenderStoreModern,\n  type PrerenderStoreModernRuntime,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  throwWithStaticGenerationBailoutErrorWithDynamicError,\n  throwForSearchParamsAccessInUseCache,\n} from './utils'\n\nexport type SearchParams = { [key: string]: string | string[] | undefined }\n\nexport function createSearchParamsFromClient(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in cache contexts.'\n        )\n      case 'request':\n        return createRenderSearchParams(underlyingSearchParams, workStore)\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport const createServerSearchParamsForMetadata =\n  createServerSearchParamsForServerPage\n\nexport function createServerSearchParamsForServerPage(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerSearchParamsForServerPage should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderSearchParams(\n          underlyingSearchParams,\n          workUnitStore\n        )\n      case 'request':\n        return createRenderSearchParams(underlyingSearchParams, workStore)\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderSearchParamsForClientPage(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        // We're prerendering in a mode that aborts (cacheComponents) and should stall\n        // the promise to ensure the RSC side is considered dynamic\n        return makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          '`searchParams`'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n        return Promise.resolve({})\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nfunction createStaticPrerenderSearchParams(\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n      // We are in a cacheComponents (PPR or otherwise) prerender\n      return makeHangingSearchParams(workStore, prerenderStore)\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // We are in a legacy static generation and need to interrupt the\n      // prerender when search params are accessed.\n      return makeErroringSearchParams(workStore, prerenderStore)\n    default:\n      return prerenderStore satisfies never\n  }\n}\n\nfunction createRuntimePrerenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<SearchParams> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    makeUntrackedSearchParams(underlyingSearchParams)\n  )\n}\n\nfunction createRenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      // Semantically we only need the dev tracking when running in `next dev`\n      // but since you would never use next dev with production NODE_ENV we use this\n      // as a proxy so we can statically exclude this code from production builds.\n      return makeUntrackedSearchParamsWithDevWarnings(\n        underlyingSearchParams,\n        workStore\n      )\n    } else {\n      return makeUntrackedSearchParams(underlyingSearchParams)\n    }\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nconst CachedSearchParamsForUseCache = new WeakMap<\n  CacheLifetime,\n  Promise<SearchParams>\n>()\n\nfunction makeHangingSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = makeHangingPromise<SearchParams>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`searchParams`'\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        default: {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n  })\n\n  CachedSearchParams.set(prerenderStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeErroringSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const underlyingSearchParams = {}\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (typeof prop === 'string' && prop === 'then') {\n        const expression =\n          '`await searchParams`, `searchParams.then`, or similar'\n        if (workStore.dynamicShouldError) {\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no cacheComponents)\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            prerenderStore.dynamicTracking\n          )\n        } else {\n          // Legacy Prerender\n          throwToInterruptStaticGeneration(\n            expression,\n            workStore,\n            prerenderStore\n          )\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedSearchParams.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\n/**\n * This is a variation of `makeErroringSearchParams` that always throws an\n * error on access, because accessing searchParams inside of `\"use cache\"` is\n * not allowed.\n */\nexport function makeErroringSearchParamsForUseCache(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve({})\n\n  const proxiedPromise = new Proxy(promise, {\n    get: function get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it. We know it\n        // isn't a dynamic access because it can only be something that was\n        // previously written to the promise and thus not an underlying\n        // searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore, get)\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedSearchParamsForUseCache.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeUntrackedSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  return promise\n}\n\nfunction makeUntrackedSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  store: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  // Track which properties we should warn for.\n  const proxiedProperties = new Set<string>()\n\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  let promiseInitialized = false\n  const proxiedUnderlying = new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized) {\n        if (store.dynamicShouldError) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            store.route,\n            expression\n          )\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (store.dynamicShouldError) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            store.route,\n            expression\n          )\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      if (store.dynamicShouldError) {\n        const expression =\n          '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          store.route,\n          expression\n        )\n      }\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  // We don't use makeResolvedReactPromise here because searchParams\n  // supports copying with spread and we don't want to unnecessarily\n  // instrument the promise with spreadable properties of ReactPromise.\n  const promise = makeDevtoolsIOAwarePromise(proxiedUnderlying)\n  promise.then(() => {\n    promiseInitialized = true\n  })\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (prop === 'then' && store.dynamicShouldError) {\n        const expression = '`searchParams.then`'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          store.route,\n          expression\n        )\n      }\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(store.route, expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar'\n      warnForSyncAccess(store.route, expression)\n      return Reflect.ownKeys(target)\n    },\n  })\n\n  CachedSearchParams.set(underlyingSearchParams, proxiedPromise)\n  return proxiedPromise\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createSearchAccessError\n)\n\nfunction createSearchAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","export type LazyResult<TValue> = PromiseLike<TValue> & { value?: TValue }\nexport type ResolvedLazyResult<TValue> = PromiseLike<TValue> & { value: TValue }\n\n/**\n * Calls the given async function only when the returned promise-like object is\n * awaited. Afterwards, it provides the resolved value synchronously as `value`\n * property.\n */\nexport function createLazyResult<TValue>(\n  fn: () => Promise<TValue>\n): LazyResult<TValue> {\n  let pendingResult: Promise<TValue> | undefined\n\n  const result: LazyResult<TValue> = {\n    then(onfulfilled, onrejected) {\n      if (!pendingResult) {\n        pendingResult = fn()\n      }\n\n      pendingResult\n        .then((value) => {\n          result.value = value\n        })\n        .catch(() => {\n          // The externally awaited result will be rejected via `onrejected`. We\n          // don't need to handle it here. But we do want to avoid an unhandled\n          // rejection.\n        })\n\n      return pendingResult.then(onfulfilled, onrejected)\n    },\n  }\n\n  return result\n}\n\nexport function isResolvedLazyResult<TValue>(\n  result: LazyResult<TValue>\n): result is ResolvedLazyResult<TValue> {\n  return result.hasOwnProperty('value')\n}\n","import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n/* eslint-disable import/no-extraneous-dependencies */\nimport {\n  renderToReadableStream,\n  decodeReply,\n  decodeReplyFromAsyncIterable,\n  createTemporaryReferenceSet as createServerTemporaryReferenceSet,\n} from 'react-server-dom-webpack/server'\nimport {\n  createFromReadableStream,\n  encodeReply,\n  createTemporaryReferenceSet as createClientTemporaryReferenceSet,\n} from 'react-server-dom-webpack/client'\nimport { prerender } from 'react-server-dom-webpack/static'\n/* eslint-enable import/no-extraneous-dependencies */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport type {\n  PrerenderStoreModernClient,\n  PrerenderStoreModernRuntime,\n  PrivateUseCacheStore,\n  RequestStore,\n  RevalidateStore,\n  UseCacheStore,\n  WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  getHmrRefreshHash,\n  getRenderResumeDataCache,\n  getPrerenderResumeDataCache,\n  workUnitAsyncStorage,\n  getDraftModeProviderForCacheScope,\n  getCacheSignal,\n  isHmrRefresh,\n  getServerComponentsHmrCache,\n  getRuntimeStagePromise,\n} from '../app-render/work-unit-async-storage.external'\n\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\n\nimport type { ClientReferenceManifestForRsc } from '../../build/webpack/plugins/flight-manifest-plugin'\n\nimport {\n  getClientReferenceManifestForRsc,\n  getServerModuleMap,\n} from '../app-render/encryption-utils'\nimport type { CacheEntry } from '../lib/cache-handlers/types'\nimport type { CacheSignal } from '../app-render/cache-signal'\nimport { decryptActionBoundArgs } from '../app-render/encryption'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { getDigestForWellKnownError } from '../app-render/create-error-handler'\nimport { DYNAMIC_EXPIRE, RUNTIME_PREFETCH_DYNAMIC_STALE } from './constants'\nimport { getCacheHandler } from './handlers'\nimport { UseCacheTimeoutError } from './use-cache-errors'\nimport {\n  createHangingInputAbortSignal,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n} from '../app-render/dynamic-rendering'\nimport {\n  makeErroringSearchParamsForUseCache,\n  type SearchParams,\n} from '../request/search-params'\nimport type { Params } from '../request/params'\nimport React from 'react'\nimport { createLazyResult, isResolvedLazyResult } from '../lib/lazy-result'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\nimport { isReactLargeShellError } from '../app-render/react-large-shell-error'\nimport type { CacheLife } from './cache-life'\n\ninterface PrivateCacheContext {\n  readonly kind: 'private'\n  readonly outerWorkUnitStore:\n    | RequestStore\n    | PrivateUseCacheStore\n    | PrerenderStoreModernRuntime\n}\n\ninterface PublicCacheContext {\n  readonly kind: 'public'\n  // TODO: We should probably forbid nesting \"use cache\" inside unstable_cache.\n  readonly outerWorkUnitStore:\n    | Exclude<WorkUnitStore, PrerenderStoreModernClient>\n    | undefined\n}\n\ntype CacheContext = PrivateCacheContext | PublicCacheContext\n\ntype CacheKeyParts =\n  | [buildId: string, id: string, args: unknown[]]\n  | [buildId: string, id: string, args: unknown[], hmrRefreshHash: string]\n\ninterface UseCachePageInnerProps {\n  params: Promise<Params>\n  searchParams?: Promise<SearchParams>\n}\n\nexport interface UseCachePageProps {\n  params: Promise<Params>\n  searchParams: Promise<SearchParams>\n  $$isPage: true\n}\n\nexport type UseCacheLayoutProps = {\n  params: Promise<Params>\n  $$isLayout: true\n} & {\n  // The value type should be React.ReactNode. But such an index signature would\n  // be incompatible with the other two props.\n  [slot: string]: any\n}\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? console.debug.bind(console, 'use-cache:')\n  : undefined\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\nfunction generateCacheEntry(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifestForRsc>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  sharedErrorStack: string | undefined\n) {\n  // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n  // generation cannot read anything from the context we're currently executing which\n  // might include request specific things like cookies() inside a React.cache().\n  // Note: It is important that we await at least once before this because it lets us\n  // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n  return workStore.runInCleanSnapshot(\n    generateCacheEntryWithRestoredWorkStore,\n    workStore,\n    cacheContext,\n    clientReferenceManifest,\n    encodedArguments,\n    fn,\n    sharedErrorStack\n  )\n}\n\nfunction generateCacheEntryWithRestoredWorkStore(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifestForRsc>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  sharedErrorStack: string | undefined\n) {\n  // Since we cleared the AsyncLocalStorage we need to restore the workStore.\n  // Note: We explicitly don't restore the RequestStore nor the PrerenderStore.\n  // We don't want any request specific information leaking an we don't want to create a\n  // bloated fake request mock for every cache call. So any feature that currently lives\n  // in RequestStore but should be available to Caches need to move to WorkStore.\n  // PrerenderStore is not needed inside the cache scope because the outer most one will\n  // be the one to report its result to the outer Prerender.\n  return workAsyncStorage.run(\n    workStore,\n    generateCacheEntryWithCacheContext,\n    workStore,\n    cacheContext,\n    clientReferenceManifest,\n    encodedArguments,\n    fn,\n    sharedErrorStack\n  )\n}\n\nfunction createUseCacheStore(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  defaultCacheLife: Required<CacheLife>\n): UseCacheStore {\n  if (cacheContext.kind === 'private') {\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    return {\n      type: 'private-cache',\n      phase: 'render',\n      implicitTags: outerWorkUnitStore?.implicitTags,\n      revalidate: defaultCacheLife.revalidate,\n      expire: defaultCacheLife.expire,\n      stale: defaultCacheLife.stale,\n      explicitRevalidate: undefined,\n      explicitExpire: undefined,\n      explicitStale: undefined,\n      tags: null,\n      hmrRefreshHash: getHmrRefreshHash(workStore, outerWorkUnitStore),\n      isHmrRefresh: isHmrRefresh(workStore, outerWorkUnitStore),\n      serverComponentsHmrCache: getServerComponentsHmrCache(\n        workStore,\n        outerWorkUnitStore\n      ),\n      forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n      runtimeStagePromise: getRuntimeStagePromise(outerWorkUnitStore),\n      draftMode: getDraftModeProviderForCacheScope(\n        workStore,\n        outerWorkUnitStore\n      ),\n      rootParams: outerWorkUnitStore.rootParams,\n      headers: outerWorkUnitStore.headers,\n      cookies: outerWorkUnitStore.cookies,\n    }\n  } else {\n    let useCacheOrRequestStore: RequestStore | UseCacheStore | undefined\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    if (outerWorkUnitStore) {\n      switch (outerWorkUnitStore?.type) {\n        case 'cache':\n        case 'private-cache':\n        case 'request':\n          useCacheOrRequestStore = outerWorkUnitStore\n          break\n        case 'prerender-runtime':\n        case 'prerender':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'unstable-cache':\n          break\n        default:\n          outerWorkUnitStore satisfies never\n      }\n    }\n\n    return {\n      type: 'cache',\n      phase: 'render',\n      implicitTags: outerWorkUnitStore?.implicitTags,\n      revalidate: defaultCacheLife.revalidate,\n      expire: defaultCacheLife.expire,\n      stale: defaultCacheLife.stale,\n      explicitRevalidate: undefined,\n      explicitExpire: undefined,\n      explicitStale: undefined,\n      tags: null,\n      hmrRefreshHash:\n        outerWorkUnitStore && getHmrRefreshHash(workStore, outerWorkUnitStore),\n      isHmrRefresh: useCacheOrRequestStore?.isHmrRefresh ?? false,\n      serverComponentsHmrCache:\n        useCacheOrRequestStore?.serverComponentsHmrCache,\n      forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n      draftMode:\n        outerWorkUnitStore &&\n        getDraftModeProviderForCacheScope(workStore, outerWorkUnitStore),\n    }\n  }\n}\n\nfunction assertDefaultCacheLife(\n  defaultCacheLife: CacheLife | undefined\n): asserts defaultCacheLife is Required<CacheLife> {\n  if (\n    !defaultCacheLife ||\n    defaultCacheLife.revalidate == null ||\n    defaultCacheLife.expire == null ||\n    defaultCacheLife.stale == null\n  ) {\n    throw new InvariantError(\n      'A default cacheLife profile must always be provided.'\n    )\n  }\n}\n\nfunction generateCacheEntryWithCacheContext(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifestForRsc>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  sharedErrorStack: string | undefined\n) {\n  if (!workStore.cacheLifeProfiles) {\n    throw new InvariantError('cacheLifeProfiles should always be provided.')\n  }\n  const defaultCacheLife = workStore.cacheLifeProfiles['default']\n  assertDefaultCacheLife(defaultCacheLife)\n\n  // Initialize the Store for this Cache entry.\n  const cacheStore = createUseCacheStore(\n    workStore,\n    cacheContext,\n    defaultCacheLife\n  )\n\n  return workUnitAsyncStorage.run(cacheStore, () =>\n    dynamicAccessAsyncStorage.run(\n      { abortController: new AbortController() },\n      generateCacheEntryImpl,\n      workStore,\n      cacheContext,\n      cacheStore,\n      clientReferenceManifest,\n      encodedArguments,\n      fn,\n      sharedErrorStack\n    )\n  )\n}\n\nfunction propagateCacheLifeAndTagsToRevalidateStore(\n  revalidateStore: RevalidateStore,\n  entry: CacheEntry\n): void {\n  const outerTags = (revalidateStore.tags ??= [])\n\n  for (const tag of entry.tags) {\n    if (!outerTags.includes(tag)) {\n      outerTags.push(tag)\n    }\n  }\n\n  if (revalidateStore.stale > entry.stale) {\n    revalidateStore.stale = entry.stale\n  }\n\n  if (revalidateStore.revalidate > entry.revalidate) {\n    revalidateStore.revalidate = entry.revalidate\n  }\n\n  if (revalidateStore.expire > entry.expire) {\n    revalidateStore.expire = entry.expire\n  }\n}\n\nfunction propagateCacheLifeAndTags(\n  cacheContext: CacheContext,\n  entry: CacheEntry\n): void {\n  if (cacheContext.kind === 'private') {\n    switch (cacheContext.outerWorkUnitStore.type) {\n      case 'prerender-runtime':\n      case 'private-cache':\n        propagateCacheLifeAndTagsToRevalidateStore(\n          cacheContext.outerWorkUnitStore,\n          entry\n        )\n        break\n      case 'request':\n      case undefined:\n        break\n      default:\n        cacheContext.outerWorkUnitStore satisfies never\n    }\n  } else {\n    switch (cacheContext.outerWorkUnitStore?.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'prerender':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        propagateCacheLifeAndTagsToRevalidateStore(\n          cacheContext.outerWorkUnitStore,\n          entry\n        )\n        break\n      case 'request':\n      case 'unstable-cache':\n      case undefined:\n        break\n      default:\n        cacheContext.outerWorkUnitStore satisfies never\n    }\n  }\n}\n\nasync function collectResult(\n  savedStream: ReadableStream<Uint8Array>,\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  innerCacheStore: UseCacheStore,\n  startTime: number,\n  errors: Array<unknown> // This is a live array that gets pushed into.\n): Promise<CacheEntry> {\n  // We create a buffered stream that collects all chunks until the end to\n  // ensure that RSC has finished rendering and therefore we have collected\n  // all tags. In the future the RSC API might allow for the equivalent of\n  // the allReady Promise that exists on SSR streams.\n  //\n  // If something errored or rejected anywhere in the render, we close\n  // the stream as errored. This lets a CacheHandler choose to save the\n  // partial result up until that point for future hits for a while to avoid\n  // unnecessary retries or not to retry. We use the end of the stream for\n  // this to avoid another complicated side-channel. A receiver has to consider\n  // that the stream might also error for other reasons anyway such as losing\n  // connection.\n\n  const buffer: Uint8Array[] = []\n  const reader = savedStream.getReader()\n\n  try {\n    for (let entry; !(entry = await reader.read()).done; ) {\n      buffer.push(entry.value)\n    }\n  } catch (error) {\n    errors.push(error)\n  }\n\n  let idx = 0\n  const bufferStream = new ReadableStream<Uint8Array>({\n    pull(controller) {\n      if (workStore.invalidDynamicUsageError) {\n        controller.error(workStore.invalidDynamicUsageError)\n      } else if (idx < buffer.length) {\n        controller.enqueue(buffer[idx++])\n      } else if (errors.length > 0) {\n        // TODO: Should we use AggregateError here?\n        controller.error(errors[0])\n      } else {\n        controller.close()\n      }\n    },\n  })\n\n  const collectedTags = innerCacheStore.tags\n  // If cacheLife() was used to set an explicit revalidate time we use that.\n  // Otherwise, we use the lowest of all inner fetch()/unstable_cache() or nested \"use cache\".\n  // If they're lower than our default.\n  const collectedRevalidate =\n    innerCacheStore.explicitRevalidate !== undefined\n      ? innerCacheStore.explicitRevalidate\n      : innerCacheStore.revalidate\n  const collectedExpire =\n    innerCacheStore.explicitExpire !== undefined\n      ? innerCacheStore.explicitExpire\n      : innerCacheStore.expire\n  const collectedStale =\n    innerCacheStore.explicitStale !== undefined\n      ? innerCacheStore.explicitStale\n      : innerCacheStore.stale\n\n  const entry: CacheEntry = {\n    value: bufferStream,\n    timestamp: startTime,\n    revalidate: collectedRevalidate,\n    expire: collectedExpire,\n    stale: collectedStale,\n    tags: collectedTags === null ? [] : collectedTags,\n  }\n\n  if (cacheContext.outerWorkUnitStore) {\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    // Propagate cache life & tags to the parent context if appropriate.\n    switch (outerWorkUnitStore.type) {\n      case 'prerender':\n      case 'prerender-runtime': {\n        // If we've just created a cache result, and we're filling caches for a\n        // Cache Components prerender, then we don't want to propagate cache\n        // life & tags yet, in case the entry ends up being omitted from the\n        // final prerender due to short expire/stale times. If it is omitted,\n        // then it shouldn't have any effects on the prerender. We'll decide\n        // whether or not this cache should have its life & tags propagated when\n        // we read the entry in the final prerender from the resume data cache.\n        break\n      }\n      case 'request':\n      case 'private-cache':\n      case 'cache':\n      case 'unstable-cache':\n      case 'prerender-legacy':\n      case 'prerender-ppr': {\n        propagateCacheLifeAndTags(cacheContext, entry)\n        break\n      }\n      default: {\n        outerWorkUnitStore satisfies never\n      }\n    }\n\n    const cacheSignal = getCacheSignal(outerWorkUnitStore)\n    if (cacheSignal) {\n      cacheSignal.endRead()\n    }\n  }\n\n  return entry\n}\n\ntype GenerateCacheEntryResult =\n  | {\n      readonly type: 'cached'\n      readonly stream: ReadableStream\n      readonly pendingCacheEntry: Promise<CacheEntry>\n    }\n  | {\n      readonly type: 'prerender-dynamic'\n      readonly hangingPromise: Promise<never>\n    }\n\nasync function generateCacheEntryImpl(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  innerCacheStore: UseCacheStore,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifestForRsc>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  sharedErrorStack: string | undefined\n): Promise<GenerateCacheEntryResult> {\n  const temporaryReferences = createServerTemporaryReferenceSet()\n  const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n  const [, , args] =\n    typeof encodedArguments === 'string'\n      ? await decodeReply<CacheKeyParts>(\n          encodedArguments,\n          getServerModuleMap(),\n          { temporaryReferences }\n        )\n      : await decodeReplyFromAsyncIterable<CacheKeyParts>(\n          {\n            async *[Symbol.asyncIterator]() {\n              for (const entry of encodedArguments) {\n                yield entry\n              }\n\n              if (outerWorkUnitStore) {\n                switch (outerWorkUnitStore.type) {\n                  case 'prerender-runtime':\n                  case 'prerender':\n                    // The encoded arguments might contain hanging promises. In\n                    // this case we don't want to reject with \"Error: Connection\n                    // closed.\", so we intentionally keep the iterable alive.\n                    // This is similar to the halting trick that we do while\n                    // rendering.\n                    await new Promise<void>((resolve) => {\n                      if (outerWorkUnitStore.renderSignal.aborted) {\n                        resolve()\n                      } else {\n                        outerWorkUnitStore.renderSignal.addEventListener(\n                          'abort',\n                          () => resolve(),\n                          { once: true }\n                        )\n                      }\n                    })\n                    break\n                  case 'prerender-ppr':\n                  case 'prerender-legacy':\n                  case 'request':\n                  case 'cache':\n                  case 'private-cache':\n                  case 'unstable-cache':\n                    break\n                  default:\n                    outerWorkUnitStore satisfies never\n                }\n              }\n            },\n          },\n          getServerModuleMap(),\n          { temporaryReferences }\n        )\n\n  // Track the timestamp when we started computing the result.\n  const startTime = performance.timeOrigin + performance.now()\n\n  // Invoke the inner function to load a new result. We delay the invocation\n  // though, until React awaits the promise so that React's request store (ALS)\n  // is available when the function is invoked. This allows us, for example, to\n  // capture logs so that we can later replay them.\n  const resultPromise = createLazyResult(() => fn.apply(null, args))\n\n  let errors: Array<unknown> = []\n\n  // In the \"Cache\" environment, we only need to make sure that the error\n  // digests are handled correctly. Error formatting and reporting is not\n  // necessary here; the errors are encoded in the stream, and will be reported\n  // in the \"Server\" environment.\n  const handleError = (error: unknown): string | undefined => {\n    const digest = getDigestForWellKnownError(error)\n\n    if (digest) {\n      return digest\n    }\n\n    if (isReactLargeShellError(error)) {\n      // TODO: Aggregate\n      console.error(error)\n      return undefined\n    }\n\n    if (process.env.NODE_ENV !== 'development') {\n      // TODO: For now we're also reporting the error here, because in\n      // production, the \"Server\" environment will only get the obfuscated\n      // error (created by the Flight Client in the cache wrapper).\n      console.error(error)\n    }\n\n    errors.push(error)\n  }\n\n  let stream: ReadableStream<Uint8Array>\n\n  switch (outerWorkUnitStore?.type) {\n    case 'prerender-runtime':\n    case 'prerender':\n      const timeoutAbortController = new AbortController()\n\n      // If we're prerendering, we give you 50 seconds to fill a cache entry.\n      // Otherwise we assume you stalled on hanging input and de-opt. This needs\n      // to be lower than just the general timeout of 60 seconds.\n      const timer = setTimeout(() => {\n        const error = new UseCacheTimeoutError()\n        if (sharedErrorStack) {\n          error.stack = error.name + ': ' + error.message + sharedErrorStack\n        }\n        workStore.invalidDynamicUsageError = error\n        timeoutAbortController.abort(error)\n      }, 50000)\n\n      const dynamicAccessAbortSignal =\n        dynamicAccessAsyncStorage.getStore()?.abortController.signal\n\n      const abortSignal = dynamicAccessAbortSignal\n        ? AbortSignal.any([\n            dynamicAccessAbortSignal,\n            outerWorkUnitStore.renderSignal,\n            timeoutAbortController.signal,\n          ])\n        : timeoutAbortController.signal\n\n      const { prelude } = await prerender(\n        resultPromise,\n        clientReferenceManifest.clientModules,\n        {\n          environmentName: 'Cache',\n          filterStackFrame,\n          signal: abortSignal,\n          temporaryReferences,\n          onError(error) {\n            if (abortSignal.aborted && abortSignal.reason === error) {\n              return undefined\n            }\n\n            return handleError(error)\n          },\n        }\n      )\n\n      clearTimeout(timer)\n\n      if (timeoutAbortController.signal.aborted) {\n        // When the timeout is reached we always error the stream. Even for\n        // fallback shell prerenders we don't want to return a hanging promise,\n        // which would allow the function to become a dynamic hole. Because that\n        // would mean that a non-empty shell could be generated which would be\n        // subject to revalidation, and we don't want to create long\n        // revalidation times.\n        stream = new ReadableStream({\n          start(controller) {\n            controller.error(timeoutAbortController.signal.reason)\n          },\n        })\n      } else if (dynamicAccessAbortSignal?.aborted) {\n        // If the prerender is aborted because of dynamic access (e.g. reading\n        // fallback params), we return a hanging promise. This essentially makes\n        // the \"use cache\" function dynamic.\n        const hangingPromise = makeHangingPromise<never>(\n          outerWorkUnitStore.renderSignal,\n          workStore.route,\n          abortSignal.reason\n        )\n\n        if (outerWorkUnitStore.cacheSignal) {\n          outerWorkUnitStore.cacheSignal.endRead()\n        }\n\n        return { type: 'prerender-dynamic', hangingPromise }\n      } else {\n        stream = prelude\n      }\n      break\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case undefined:\n      stream = renderToReadableStream(\n        resultPromise,\n        clientReferenceManifest.clientModules,\n        {\n          environmentName: 'Cache',\n          filterStackFrame,\n          temporaryReferences,\n          onError: handleError,\n        }\n      )\n      break\n    default:\n      return outerWorkUnitStore satisfies never\n  }\n\n  const [returnStream, savedStream] = stream.tee()\n\n  const pendingCacheEntry = collectResult(\n    savedStream,\n    workStore,\n    cacheContext,\n    innerCacheStore,\n    startTime,\n    errors\n  )\n\n  return {\n    type: 'cached',\n    // Return the stream as we're creating it. This means that if it ends up\n    // erroring we cannot return a stale-if-error version but it allows\n    // streaming back the result earlier.\n    stream: returnStream,\n    pendingCacheEntry,\n  }\n}\n\nfunction cloneCacheEntry(entry: CacheEntry): [CacheEntry, CacheEntry] {\n  const [streamA, streamB] = entry.value.tee()\n  entry.value = streamA\n  const clonedEntry: CacheEntry = {\n    value: streamB,\n    timestamp: entry.timestamp,\n    revalidate: entry.revalidate,\n    expire: entry.expire,\n    stale: entry.stale,\n    tags: entry.tags,\n  }\n  return [entry, clonedEntry]\n}\n\nasync function clonePendingCacheEntry(\n  pendingCacheEntry: Promise<CacheEntry>\n): Promise<[CacheEntry, CacheEntry]> {\n  const entry = await pendingCacheEntry\n  return cloneCacheEntry(entry)\n}\n\nasync function getNthCacheEntry(\n  split: Promise<[CacheEntry, CacheEntry]>,\n  i: number\n): Promise<CacheEntry> {\n  return (await split)[i]\n}\n\nasync function encodeFormData(formData: FormData): Promise<string> {\n  let result = ''\n  for (let [key, value] of formData) {\n    // We don't need this key to be serializable but from a security perspective it should not be\n    // possible to generate a string that looks the same from a different structure. To ensure this\n    // we need a delimeter between fields but just using a delimeter is not enough since a string\n    // might contain that delimeter. We use the length of each field as the delimeter to avoid\n    // escaping the values.\n    result += key.length.toString(16) + ':' + key\n    let stringValue\n    if (typeof value === 'string') {\n      stringValue = value\n    } else {\n      // The FormData might contain binary data that is not valid UTF-8 so this cache\n      // key may generate a UCS-2 string. Passing this to another service needs to be\n      // aware that the key might not be compatible.\n      const arrayBuffer = await value.arrayBuffer()\n      if (arrayBuffer.byteLength % 2 === 0) {\n        stringValue = String.fromCodePoint(...new Uint16Array(arrayBuffer))\n      } else {\n        stringValue =\n          String.fromCodePoint(\n            ...new Uint16Array(arrayBuffer, 0, (arrayBuffer.byteLength - 1) / 2)\n          ) +\n          String.fromCodePoint(\n            new Uint8Array(arrayBuffer, arrayBuffer.byteLength - 1, 1)[0]\n          )\n      }\n    }\n    result += stringValue.length.toString(16) + ':' + stringValue\n  }\n  return result\n}\n\nfunction createTrackedReadableStream(\n  stream: ReadableStream,\n  cacheSignal: CacheSignal\n) {\n  const reader = stream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await reader.read()\n      if (done) {\n        controller.close()\n        cacheSignal.endRead()\n      } else {\n        controller.enqueue(value)\n      }\n    },\n  })\n}\n\nfunction wrapAsInvalidDynamicUsageError(\n  error: Error,\n  sharedErrorStack: string | undefined,\n  workStore: WorkStore\n) {\n  if (sharedErrorStack) {\n    error.stack = error.name + ': ' + error.message + sharedErrorStack\n  }\n\n  workStore.invalidDynamicUsageError ??= error\n\n  return error\n}\n\nexport function cache(\n  kind: string,\n  id: string,\n  boundArgsLength: number,\n  originalFn: (...args: unknown[]) => Promise<unknown>\n) {\n  const isPrivate = kind === 'private'\n\n  // Private caches are currently only stored in the Resume Data Cache (RDC),\n  // and not in cache handlers.\n  const cacheHandler = isPrivate ? undefined : getCacheHandler(kind)\n\n  if (!isPrivate && !cacheHandler) {\n    throw new Error('Unknown cache handler: ' + kind)\n  }\n\n  // Capture a better error stack in this scope.\n  const sharedError = new Error()\n  Error.captureStackTrace(sharedError, cache)\n  const sharedErrorStack = sharedError.stack?.slice(\n    sharedError.stack.indexOf('\\n')\n  )\n\n  const name = originalFn.name\n  const cachedFn = {\n    [name]: async function (...args: any[]) {\n      const workStore = workAsyncStorage.getStore()\n      if (workStore === undefined) {\n        throw new Error(\n          '\"use cache\" cannot be used outside of App Router. Expected a WorkStore.'\n        )\n      }\n\n      let fn = originalFn\n\n      const workUnitStore = workUnitAsyncStorage.getStore()\n\n      let cacheContext: CacheContext\n\n      if (isPrivate) {\n        const expression = '\"use cache: private\"'\n\n        switch (workUnitStore?.type) {\n          // \"use cache: private\" is dynamic in prerendering contexts.\n          case 'prerender':\n            return makeHangingPromise(\n              workUnitStore.renderSignal,\n              workStore.route,\n              expression\n            )\n          case 'prerender-ppr':\n            return postponeWithTracking(\n              workStore.route,\n              expression,\n              workUnitStore.dynamicTracking\n            )\n          case 'prerender-legacy':\n            return throwToInterruptStaticGeneration(\n              expression,\n              workStore,\n              workUnitStore\n            )\n          case 'prerender-client':\n            throw new InvariantError(\n              `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`\n            )\n          case 'unstable-cache': {\n            throw wrapAsInvalidDynamicUsageError(\n              new Error(\n                // TODO: Add a link to an error documentation page when we have one.\n                `${expression} must not be used within \\`unstable_cache()\\`.`\n              ),\n              sharedErrorStack,\n              workStore\n            )\n          }\n          case 'cache': {\n            throw wrapAsInvalidDynamicUsageError(\n              new Error(\n                // TODO: Add a link to an error documentation page when we have one.\n                `${expression} must not be used within \"use cache\". It can only be nested inside of another ${expression}.`\n              ),\n              sharedErrorStack,\n              workStore\n            )\n          }\n          case 'request':\n          case 'prerender-runtime':\n          case 'private-cache':\n            cacheContext = {\n              kind: 'private',\n              outerWorkUnitStore: workUnitStore,\n            }\n            break\n          case undefined:\n            throw wrapAsInvalidDynamicUsageError(\n              new Error(\n                // TODO: Add a link to an error documentation page when we have one.\n                `${expression} cannot be used outside of a request context.`\n              ),\n              sharedErrorStack,\n              workStore\n            )\n          default:\n            workUnitStore satisfies never\n            // This is dead code, but without throwing an error here, TypeScript\n            // will assume that cacheContext is used before being assigned.\n            throw new InvariantError(`Unexpected work unit store.`)\n        }\n      } else {\n        switch (workUnitStore?.type) {\n          case 'prerender-client':\n            const expression = '\"use cache\"'\n            throw new InvariantError(\n              `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`\n            )\n          case 'prerender':\n          case 'prerender-runtime':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          // TODO: We should probably forbid nesting \"use cache\" inside\n          // unstable_cache. (fallthrough)\n          case 'unstable-cache':\n          case undefined:\n            cacheContext = {\n              kind: 'public',\n              outerWorkUnitStore: workUnitStore,\n            }\n            break\n          default:\n            workUnitStore satisfies never\n            // This is dead code, but without throwing an error here, TypeScript\n            // will assume that cacheContext is used before being assigned.\n            throw new InvariantError(`Unexpected work unit store.`)\n        }\n      }\n\n      // Get the clientReferenceManifest while we're still in the outer Context.\n      // In case getClientReferenceManifestSingleton is implemented using AsyncLocalStorage.\n      const clientReferenceManifest = getClientReferenceManifestForRsc()\n\n      // Because the Action ID is not yet unique per implementation of that Action we can't\n      // safely reuse the results across builds yet. In the meantime we add the buildId to the\n      // arguments as a seed to ensure they're not reused. Remove this once Action IDs hash\n      // the implementation.\n      const buildId = workStore.buildId\n\n      // In dev mode, when the HMR refresh hash is set, we include it in the\n      // cache key. This ensures that cache entries are not reused when server\n      // components have been edited. This is a very coarse approach. But it's\n      // also only a temporary solution until Action IDs are unique per\n      // implementation. Remove this once Action IDs hash the implementation.\n      const hmrRefreshHash =\n        workUnitStore && getHmrRefreshHash(workStore, workUnitStore)\n\n      const hangingInputAbortSignal = workUnitStore\n        ? createHangingInputAbortSignal(workUnitStore)\n        : undefined\n\n      // In a runtime prerender, we have to make sure that APIs that would hang during a static prerender\n      // are resolved with a delay, in the runtime stage. Private caches are one of these.\n      if (cacheContext.kind === 'private') {\n        const runtimeStagePromise = getRuntimeStagePromise(\n          cacheContext.outerWorkUnitStore\n        )\n        if (runtimeStagePromise) {\n          await runtimeStagePromise\n        }\n      }\n\n      let isPageOrLayoutSegmentFunction = false\n\n      // For page and layout segment functions (i.e. the page/layout component,\n      // or generateMetadata/generateViewport), the cache function is\n      // overwritten, which allows us to apply special handling for params and\n      // searchParams. For pages and layouts we're using the outer params prop,\n      // and not the inner one that was serialized/deserialized. While it's not\n      // generally true for \"use cache\" args, in the case of `params` the inner\n      // and outer object are essentially equivalent, so this is safe to do\n      // (including fallback params that are hanging promises). It allows us to\n      // avoid waiting for the timeout, when prerendering a fallback shell of a\n      // cached page or layout that awaits params.\n      if (isPageSegmentFunction(args)) {\n        isPageOrLayoutSegmentFunction = true\n\n        const [\n          { params: outerParams, searchParams: outerSearchParams },\n          ...otherOuterArgs\n        ] = args\n\n        const props: UseCachePageInnerProps = {\n          params: outerParams,\n          // Omit searchParams and $$isPage.\n        }\n\n        if (isPrivate) {\n          // Private caches allow accessing search params. We need to include\n          // them in the serialized args and when generating the cache key.\n          props.searchParams = outerSearchParams\n        }\n\n        args = [props, ...otherOuterArgs]\n\n        fn = {\n          [name]: async (\n            {\n              params: _innerParams,\n              searchParams: innerSearchParams,\n            }: UseCachePageInnerProps,\n            ...otherInnerArgs: unknown[]\n          ) =>\n            originalFn.apply(null, [\n              {\n                params: outerParams,\n                searchParams:\n                  innerSearchParams ??\n                  // For public caches, search params are omitted from the cache\n                  // key (and the serialized args) to avoid mismatches between\n                  // prerendering and resuming a cached page that does not\n                  // access search params. This is also the reason why we're not\n                  // using a hanging promise for search params. For cached pages\n                  // that do access them, which is an invalid dynamic usage, we\n                  // need to ensure that an error is shown.\n                  makeErroringSearchParamsForUseCache(workStore),\n              },\n              ...otherInnerArgs,\n            ]),\n        }[name] as (...args: unknown[]) => Promise<unknown>\n      } else if (isLayoutSegmentFunction(args)) {\n        isPageOrLayoutSegmentFunction = true\n\n        const [\n          { params: outerParams, $$isLayout, ...outerSlots },\n          ...otherOuterArgs\n        ] = args\n\n        // Overwrite the props to omit $$isLayout. Note that slots are only\n        // passed to the layout component (if any are defined), and not to\n        // generateMetadata nor generateViewport. For those functions,\n        // outerSlots/innerSlots is an empty object, which is fine because we're\n        // just spreading it into the props.\n        args = [{ params: outerParams, ...outerSlots }, ...otherOuterArgs]\n\n        fn = {\n          [name]: async (\n            {\n              params: _innerParams,\n              ...innerSlots\n            }: Omit<UseCacheLayoutProps, '$$isLayout'>,\n            ...otherInnerArgs: unknown[]\n          ) =>\n            originalFn.apply(null, [\n              { params: outerParams, ...innerSlots },\n              ...otherInnerArgs,\n            ]),\n        }[name] as (...args: unknown[]) => Promise<unknown>\n      }\n\n      if (boundArgsLength > 0) {\n        if (args.length === 0) {\n          throw new InvariantError(\n            `Expected the \"use cache\" function ${JSON.stringify(fn.name)} to receive its encrypted bound arguments as the first argument.`\n          )\n        }\n\n        const encryptedBoundArgs = args.shift()\n        const boundArgs = await decryptActionBoundArgs(id, encryptedBoundArgs)\n\n        if (!Array.isArray(boundArgs)) {\n          throw new InvariantError(\n            `Expected the bound arguments of \"use cache\" function ${JSON.stringify(fn.name)} to deserialize into an array, got ${typeof boundArgs} instead.`\n          )\n        }\n\n        if (boundArgsLength !== boundArgs.length) {\n          throw new InvariantError(\n            `Expected the \"use cache\" function ${JSON.stringify(fn.name)} to receive ${boundArgsLength} bound arguments, got ${boundArgs.length} instead.`\n          )\n        }\n\n        args.unshift(boundArgs)\n      }\n\n      const temporaryReferences = createClientTemporaryReferenceSet()\n\n      // For private caches, which are allowed to read cookies, we still don't\n      // need to include the cookies in the cache key. This is because we don't\n      // store the cache entries in a cache handler, but only in the Resume Data\n      // Cache (RDC). Private caches are only used during dynamic requests and\n      // runtime prefetches. For dynamic requests, the RDC is immutable, so it\n      // does not include any private caches. For runtime prefetches, the RDC is\n      // mutable, but only lives as long as the request, so the key does not\n      // need to include cookies.\n      const cacheKeyParts: CacheKeyParts = hmrRefreshHash\n        ? [buildId, id, args, hmrRefreshHash]\n        : [buildId, id, args]\n\n      const encodeCacheKeyParts = () =>\n        encodeReply(cacheKeyParts, {\n          temporaryReferences,\n          signal: hangingInputAbortSignal,\n        })\n\n      let encodedCacheKeyParts: FormData | string\n\n      switch (workUnitStore?.type) {\n        case 'prerender-runtime':\n        // We're currently only using `dynamicAccessAsyncStorage` for params,\n        // which are always available in a runtime prerender, so they will never hang,\n        // effectively making the tracking below a no-op.\n        // However, a runtime prerender shares a lot of the semantics with a static prerender,\n        // and might need to follow this codepath in the future\n        // if we start using `dynamicAccessAsyncStorage` for other APIs.\n        //\n        // fallthrough\n        case 'prerender':\n          if (!isPageOrLayoutSegmentFunction) {\n            // If the \"use cache\" function is not a page or layout segment\n            // function, we need to track dynamic access already when encoding\n            // the arguments. If params are passed explicitly into a \"use cache\"\n            // function (as opposed to receiving them automatically in a page or\n            // layout), we assume that the params are also accessed. This allows\n            // us to abort early, and treat the function as dynamic, instead of\n            // waiting for the timeout to be reached.\n            const dynamicAccessAbortController = new AbortController()\n\n            encodedCacheKeyParts = await dynamicAccessAsyncStorage.run(\n              { abortController: dynamicAccessAbortController },\n              encodeCacheKeyParts\n            )\n\n            if (dynamicAccessAbortController.signal.aborted) {\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                dynamicAccessAbortController.signal.reason.message\n              )\n            }\n            break\n          }\n        // fallthrough\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n        case undefined:\n          encodedCacheKeyParts = await encodeCacheKeyParts()\n          break\n        default:\n          return workUnitStore satisfies never\n      }\n\n      const serializedCacheKey =\n        typeof encodedCacheKeyParts === 'string'\n          ? // Fast path for the simple case for simple inputs. We let the CacheHandler\n            // Convert it to an ArrayBuffer if it wants to.\n            encodedCacheKeyParts\n          : await encodeFormData(encodedCacheKeyParts)\n\n      let stream: undefined | ReadableStream = undefined\n\n      // Get an immutable and mutable versions of the resume data cache.\n      const prerenderResumeDataCache = workUnitStore\n        ? getPrerenderResumeDataCache(workUnitStore)\n        : null\n      const renderResumeDataCache = workUnitStore\n        ? getRenderResumeDataCache(workUnitStore)\n        : null\n\n      if (renderResumeDataCache) {\n        const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n\n        if (cacheSignal) {\n          cacheSignal.beginRead()\n        }\n        const cachedEntry = renderResumeDataCache.cache.get(serializedCacheKey)\n        if (cachedEntry !== undefined) {\n          const existingEntry = await cachedEntry\n          if (workUnitStore !== undefined && existingEntry !== undefined) {\n            if (\n              existingEntry.revalidate === 0 ||\n              existingEntry.expire < DYNAMIC_EXPIRE\n            ) {\n              switch (workUnitStore.type) {\n                case 'prerender':\n                  // In a Dynamic I/O prerender, if the cache entry has\n                  // revalidate: 0 or if the expire time is under 5 minutes,\n                  // then we consider this cache entry dynamic as it's not worth\n                  // generating static pages for such data. It's better to leave\n                  // a dynamic hole that can be filled in during the resume with\n                  // a potentially cached entry.\n                  if (cacheSignal) {\n                    cacheSignal.endRead()\n                  }\n                  return makeHangingPromise(\n                    workUnitStore.renderSignal,\n                    workStore.route,\n                    'dynamic \"use cache\"'\n                  )\n                case 'prerender-runtime': {\n                  // In the final phase of a runtime prerender, we have to make\n                  // sure that APIs that would hang during a static prerender\n                  // are resolved with a delay, in the runtime stage.\n                  if (workUnitStore.runtimeStagePromise) {\n                    await workUnitStore.runtimeStagePromise\n                  }\n                  break\n                }\n                case 'prerender-ppr':\n                case 'prerender-legacy':\n                case 'request':\n                case 'cache':\n                case 'private-cache':\n                case 'unstable-cache':\n                  break\n                default:\n                  workUnitStore satisfies never\n              }\n            }\n\n            if (existingEntry.stale < RUNTIME_PREFETCH_DYNAMIC_STALE) {\n              switch (workUnitStore.type) {\n                case 'prerender-runtime':\n                  // In a runtime prerender, if the cache entry will become\n                  // stale in less then 30 seconds, we consider this cache entry\n                  // dynamic as it's not worth prefetching. It's better to leave\n                  // a dynamic hole that can be filled during the navigation.\n                  if (cacheSignal) {\n                    cacheSignal.endRead()\n                  }\n                  return makeHangingPromise(\n                    workUnitStore.renderSignal,\n                    workStore.route,\n                    'dynamic \"use cache\"'\n                  )\n                case 'prerender':\n                case 'prerender-ppr':\n                case 'prerender-legacy':\n                case 'request':\n                case 'cache':\n                case 'private-cache':\n                case 'unstable-cache':\n                  break\n                default:\n                  workUnitStore satisfies never\n              }\n            }\n          }\n\n          // We want to make sure we only propagate cache life & tags if the\n          // entry was *not* omitted from the prerender. So we only do this\n          // after the above early returns.\n          propagateCacheLifeAndTags(cacheContext, existingEntry)\n\n          const [streamA, streamB] = existingEntry.value.tee()\n          existingEntry.value = streamB\n\n          if (cacheSignal) {\n            // When we have a cacheSignal we need to block on reading the cache\n            // entry before ending the read.\n            stream = createTrackedReadableStream(streamA, cacheSignal)\n          } else {\n            stream = streamA\n          }\n        } else {\n          if (cacheSignal) {\n            cacheSignal.endRead()\n          }\n\n          if (workUnitStore) {\n            switch (workUnitStore.type) {\n              case 'prerender':\n                // If `allowEmptyStaticShell` is true, and thus a prefilled\n                // resume data cache was provided, then a cache miss means that\n                // params were part of the cache key. In this case, we can make\n                // this cache function a dynamic hole in the shell (or produce\n                // an empty shell if there's no parent suspense boundary).\n                // Currently, this also includes layouts and pages that don't\n                // read params, which will be improved when we implement\n                // NAR-136. Otherwise, we assume that if params are passed\n                // explicitly into a \"use cache\" function, that the params are\n                // also accessed. This allows us to abort early, and treat the\n                // function as dynamic, instead of waiting for the timeout to be\n                // reached. Compared to the instrumentation-based params bailout\n                // we do here, this also covers the case where params are\n                // transformed with an async function, before being passed into\n                // the \"use cache\" function, which escapes the instrumentation.\n                if (workUnitStore.allowEmptyStaticShell) {\n                  return makeHangingPromise(\n                    workUnitStore.renderSignal,\n                    workStore.route,\n                    'dynamic \"use cache\"'\n                  )\n                }\n                break\n              case 'prerender-runtime':\n              case 'prerender-ppr':\n              case 'prerender-legacy':\n              case 'request':\n              case 'cache':\n              case 'private-cache':\n              case 'unstable-cache':\n                break\n              default:\n                workUnitStore satisfies never\n            }\n          }\n        }\n      }\n\n      if (stream === undefined) {\n        const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n        if (cacheSignal) {\n          // Either the cache handler or the generation can be using I/O at this point.\n          // We need to track when they start and when they complete.\n          cacheSignal.beginRead()\n        }\n\n        const lazyRefreshTags = workStore.refreshTagsByCacheKind.get(kind)\n\n        if (lazyRefreshTags && !isResolvedLazyResult(lazyRefreshTags)) {\n          await lazyRefreshTags\n        }\n\n        let entry: CacheEntry | undefined\n\n        // We ignore existing cache entries when force revalidating.\n        if (cacheHandler && !shouldForceRevalidate(workStore, workUnitStore)) {\n          entry = await cacheHandler.get(\n            serializedCacheKey,\n            workUnitStore?.implicitTags?.tags ?? []\n          )\n        }\n\n        if (entry) {\n          const implicitTags = workUnitStore?.implicitTags?.tags ?? []\n          let implicitTagsExpiration = 0\n\n          if (workUnitStore?.implicitTags) {\n            const lazyExpiration =\n              workUnitStore.implicitTags.expirationsByCacheKind.get(kind)\n\n            if (lazyExpiration) {\n              const expiration = isResolvedLazyResult(lazyExpiration)\n                ? lazyExpiration.value\n                : await lazyExpiration\n\n              // If a cache handler returns an expiration time of Infinity, it\n              // signals to Next.js that it handles checking cache entries for\n              // staleness based on the expiration of the implicit tags passed\n              // into the `get` method. In this case, we keep the default of 0,\n              // which means that the implicit tags are not considered expired.\n              if (expiration < Infinity) {\n                implicitTagsExpiration = expiration\n              }\n            }\n          }\n\n          if (\n            shouldDiscardCacheEntry(\n              entry,\n              workStore,\n              workUnitStore,\n              implicitTags,\n              implicitTagsExpiration\n            )\n          ) {\n            debug?.('discarding expired entry', serializedCacheKey)\n            entry = undefined\n          }\n        }\n\n        const currentTime = performance.timeOrigin + performance.now()\n        if (\n          workUnitStore !== undefined &&\n          entry !== undefined &&\n          (entry.revalidate === 0 || entry.expire < DYNAMIC_EXPIRE)\n        ) {\n          switch (workUnitStore.type) {\n            case 'prerender':\n              // In a Dynamic I/O prerender, if the cache entry has revalidate:\n              // 0 or if the expire time is under 5 minutes, then we consider\n              // this cache entry dynamic as it's not worth generating static\n              // pages for such data. It's better to leave a dynamic hole that\n              // can be filled in during the resume with a potentially cached\n              // entry.\n              if (cacheSignal) {\n                cacheSignal.endRead()\n              }\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'dynamic \"use cache\"'\n              )\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'request':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n\n        if (\n          entry === undefined ||\n          currentTime > entry.timestamp + entry.expire * 1000 ||\n          (workStore.isStaticGeneration &&\n            currentTime > entry.timestamp + entry.revalidate * 1000)\n        ) {\n          // Miss. Generate a new result.\n\n          // If the cache entry is stale and we're prerendering, we don't want to use the\n          // stale entry since it would unnecessarily need to shorten the lifetime of the\n          // prerender. We're not time constrained here so we can re-generated it now.\n\n          // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n          // generation cannot read anything from the context we're currently executing which\n          // might include request specific things like cookies() inside a React.cache().\n          // Note: It is important that we await at least once before this because it lets us\n          // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n\n          if (entry) {\n            if (currentTime > entry.timestamp + entry.expire * 1000) {\n              debug?.('entry is expired', serializedCacheKey)\n            }\n\n            if (\n              workStore.isStaticGeneration &&\n              currentTime > entry.timestamp + entry.revalidate * 1000\n            ) {\n              debug?.('static generation, entry is stale', serializedCacheKey)\n            }\n          }\n\n          const result = await generateCacheEntry(\n            workStore,\n            cacheContext,\n            clientReferenceManifest,\n            encodedCacheKeyParts,\n            fn,\n            sharedErrorStack\n          )\n\n          if (result.type === 'prerender-dynamic') {\n            return result.hangingPromise\n          }\n\n          const { stream: newStream, pendingCacheEntry } = result\n\n          // When draft mode is enabled, we must not save the cache entry.\n          if (!workStore.isDraftMode) {\n            let savedCacheEntry\n\n            if (prerenderResumeDataCache) {\n              // Create a clone that goes into the cache scope memory cache.\n              const split = clonePendingCacheEntry(pendingCacheEntry)\n              savedCacheEntry = getNthCacheEntry(split, 0)\n              prerenderResumeDataCache.cache.set(\n                serializedCacheKey,\n                getNthCacheEntry(split, 1)\n              )\n            } else {\n              savedCacheEntry = pendingCacheEntry\n            }\n\n            if (cacheHandler) {\n              const promise = cacheHandler.set(\n                serializedCacheKey,\n                savedCacheEntry\n              )\n\n              workStore.pendingRevalidateWrites ??= []\n              workStore.pendingRevalidateWrites.push(promise)\n            }\n          }\n\n          stream = newStream\n        } else {\n          // If we have an entry at this point, this can't be a private cache\n          // entry.\n          if (cacheContext.kind === 'private') {\n            throw new InvariantError(\n              `A private cache entry must not be retrieved from the cache handler.`\n            )\n          }\n\n          propagateCacheLifeAndTags(cacheContext, entry)\n\n          // We want to return this stream, even if it's stale.\n          stream = entry.value\n\n          // If we have a cache scope, we need to clone the entry and set it on\n          // the inner cache scope.\n          if (prerenderResumeDataCache) {\n            const [entryLeft, entryRight] = cloneCacheEntry(entry)\n            if (cacheSignal) {\n              stream = createTrackedReadableStream(entryLeft.value, cacheSignal)\n            } else {\n              stream = entryLeft.value\n            }\n\n            prerenderResumeDataCache.cache.set(\n              serializedCacheKey,\n              Promise.resolve(entryRight)\n            )\n          } else {\n            // If we're not regenerating we need to signal that we've finished\n            // putting the entry into the cache scope at this point. Otherwise we do\n            // that inside generateCacheEntry.\n            cacheSignal?.endRead()\n          }\n\n          if (currentTime > entry.timestamp + entry.revalidate * 1000) {\n            // If this is stale, and we're not in a prerender (i.e. this is\n            // dynamic render), then we should warm up the cache with a fresh\n            // revalidated entry.\n            const result = await generateCacheEntry(\n              workStore,\n              // This is not running within the context of this unit.\n              { kind: cacheContext.kind, outerWorkUnitStore: undefined },\n              clientReferenceManifest,\n              encodedCacheKeyParts,\n              fn,\n              sharedErrorStack\n            )\n\n            if (result.type === 'cached') {\n              const { stream: ignoredStream, pendingCacheEntry } = result\n              let savedCacheEntry: Promise<CacheEntry>\n\n              if (prerenderResumeDataCache) {\n                const split = clonePendingCacheEntry(pendingCacheEntry)\n                savedCacheEntry = getNthCacheEntry(split, 0)\n                prerenderResumeDataCache.cache.set(\n                  serializedCacheKey,\n                  getNthCacheEntry(split, 1)\n                )\n              } else {\n                savedCacheEntry = pendingCacheEntry\n              }\n\n              if (cacheHandler) {\n                const promise = cacheHandler.set(\n                  serializedCacheKey,\n                  savedCacheEntry\n                )\n\n                workStore.pendingRevalidateWrites ??= []\n                workStore.pendingRevalidateWrites.push(promise)\n              }\n\n              await ignoredStream.cancel()\n            }\n          }\n        }\n      }\n\n      // Logs are replayed even if it's a hit - to ensure we see them on the client eventually.\n      // If we didn't then the client wouldn't see the logs if it was seeded from a prewarm that\n      // never made it to the client. However, this also means that you see logs even when the\n      // cached function isn't actually re-executed. We should instead ensure prewarms always\n      // make it to the client. Another issue is that this will cause double logging in the\n      // server terminal. Once while generating the cache entry and once when replaying it on\n      // the server, which is required to pick it up for replaying again on the client.\n      const replayConsoleLogs = true\n\n      const serverConsumerManifest = {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n        // which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime\n          ? clientReferenceManifest.edgeRscModuleMapping\n          : clientReferenceManifest.rscModuleMapping,\n        serverModuleMap: getServerModuleMap(),\n      }\n\n      return createFromReadableStream(stream, {\n        findSourceMapURL,\n        serverConsumerManifest,\n        temporaryReferences,\n        replayConsoleLogs,\n        environmentName: 'Cache',\n      })\n    },\n  }[name]\n\n  return React.cache(cachedFn)\n}\n\n/**\n * Returns `true` if the `'use cache'` function is the page component itself,\n * or `generateMetadata`/`generateViewport` in a page file.\n */\nfunction isPageSegmentFunction(\n  args: any[]\n): args is [UseCachePageProps, ...unknown[]] {\n  const [maybeProps] = args\n\n  return (\n    maybeProps !== null &&\n    typeof maybeProps === 'object' &&\n    (maybeProps as UseCachePageProps).$$isPage === true\n  )\n}\n\n/**\n * Returns `true` if the `'use cache'` function is the layout component itself,\n * or `generateMetadata`/`generateViewport` in a layout file.\n */\nfunction isLayoutSegmentFunction(\n  args: any[]\n): args is [UseCacheLayoutProps, ...unknown[]] {\n  const [maybeProps] = args\n\n  return (\n    maybeProps !== null &&\n    typeof maybeProps === 'object' &&\n    (maybeProps as UseCacheLayoutProps).$$isLayout === true\n  )\n}\n\nfunction shouldForceRevalidate(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore | undefined\n): boolean {\n  if (workStore.isOnDemandRevalidate || workStore.isDraftMode) {\n    return true\n  }\n\n  if (workStore.dev && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'request':\n        return workUnitStore.headers.get('cache-control') === 'no-cache'\n      case 'cache':\n      case 'private-cache':\n        return workUnitStore.forceRevalidate\n      case 'prerender-runtime':\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return false\n}\n\nfunction shouldDiscardCacheEntry(\n  entry: CacheEntry,\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore | undefined,\n  implicitTags: string[],\n  implicitTagsExpiration: number\n): boolean {\n  // If the cache entry was created before any of the implicit tags were\n  // revalidated last, we need to discard it.\n  if (entry.timestamp <= implicitTagsExpiration) {\n    debug?.(\n      'entry was created at',\n      entry.timestamp,\n      'before implicit tags were revalidated at',\n      implicitTagsExpiration\n    )\n\n    return true\n  }\n\n  // During prerendering, we ignore recently revalidated tags. In dev mode, we\n  // can assume that the dynamic dev rendering will have discarded and recreated\n  // the affected cache entries, and we don't want to discard those again during\n  // the prerender validation. During build-time prerendering, there will never\n  // be any pending revalidated tags.\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n        return false\n      case 'prerender-runtime':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If the cache entry contains revalidated tags that the cache handler might\n  // not know about yet, we need to discard it.\n  if (entry.tags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n    return true\n  }\n\n  // Finally, if any of the implicit tags have been revalidated recently, we\n  // also need to discard the cache entry.\n  if (implicitTags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n    return true\n  }\n\n  return false\n}\n\nfunction isRecentlyRevalidatedTag(tag: string, workStore: WorkStore): boolean {\n  const { previouslyRevalidatedTags, pendingRevalidatedTags } = workStore\n\n  // Was the tag previously revalidated (e.g. by a redirecting server action)?\n  if (previouslyRevalidatedTags.includes(tag)) {\n    debug?.('tag', tag, 'was previously revalidated')\n\n    return true\n  }\n\n  // It could also have been revalidated by the currently running server action.\n  // In this case the revalidation might not have been fully propagated by a\n  // remote cache handler yet, so we read it from the pending tags in the work\n  // store.\n  if (pendingRevalidatedTags?.some((item) => item.tag === tag)) {\n    debug?.('tag', tag, 'was just revalidated')\n\n    return true\n  }\n\n  return false\n}\n","export { cache } from '../../../../server/use-cache/use-cache-wrapper'\n","const noop = () => {}\n\nlet registry: FinalizationRegistry<WeakRef<ReadableStream>> | undefined\n\nif (globalThis.FinalizationRegistry) {\n  registry = new FinalizationRegistry((weakRef: WeakRef<ReadableStream>) => {\n    const stream = weakRef.deref()\n    if (stream && !stream.locked) {\n      stream.cancel('Response object has been garbage collected').then(noop)\n    }\n  })\n}\n\n/**\n * Clones a response by teeing the body so we can return two independent\n * ReadableStreams from it. This avoids the bug in the undici library around\n * response cloning.\n *\n * After cloning, the original response's body will be consumed and closed.\n *\n * @see https://github.com/vercel/next.js/pull/73274\n *\n * @param original - The original response to clone.\n * @returns A tuple containing two independent clones of the original response.\n */\nexport function cloneResponse(original: Response): [Response, Response] {\n  // If the response has no body, then we can just return the original response\n  // twice because it's immutable.\n  if (!original.body) {\n    return [original, original]\n  }\n\n  const [body1, body2] = original.body.tee()\n\n  const cloned1 = new Response(body1, {\n    status: original.status,\n    statusText: original.statusText,\n    headers: original.headers,\n  })\n\n  Object.defineProperty(cloned1, 'url', {\n    value: original.url,\n    // How the original response.url behaves\n    configurable: true,\n    enumerable: true,\n    writable: false,\n  })\n\n  // The Fetch Standard allows users to skip consuming the response body by\n  // relying on garbage collection to release connection resources.\n  // https://github.com/nodejs/undici?tab=readme-ov-file#garbage-collection\n  //\n  // To cancel the stream you then need to cancel both resulting branches.\n  // Teeing a stream will generally lock it for the duration, preventing other\n  // readers from locking it.\n  // https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/tee\n\n  // cloned2 is stored in a react cache and cloned for subsequent requests.\n  // It is the original request, and is is garbage collected by a\n  // FinalizationRegistry in Undici, but since we're tee-ing the stream\n  // ourselves, we need to cancel clone1's stream (the response returned from\n  // our dedupe fetch) when clone1 is reclaimed, otherwise we leak memory.\n  if (registry && cloned1.body) {\n    registry.register(cloned1, new WeakRef(cloned1.body))\n  }\n\n  const cloned2 = new Response(body2, {\n    status: original.status,\n    statusText: original.statusText,\n    headers: original.headers,\n  })\n\n  Object.defineProperty(cloned2, 'url', {\n    value: original.url,\n    // How the original response.url behaves\n    configurable: true,\n    enumerable: true,\n    writable: false,\n  })\n\n  return [cloned1, cloned2]\n}\n","/**\n * Based on https://github.com/facebook/react/blob/d4e78c42a94be027b4dc7ed2659a5fddfbf9bd4e/packages/react/src/ReactFetch.js\n */\nimport * as React from 'react'\nimport { cloneResponse } from './clone-response'\nimport { InvariantError } from '../../shared/lib/invariant-error'\n\nconst simpleCacheKey = '[\"GET\",[],null,\"follow\",null,null,null,null]' // generateCacheKey(new Request('https://blank'));\n\n// Headers that should not affect deduplication\n// traceparent and tracestate are used for distributed tracing and should not affect cache keys\nconst headersToExcludeInCacheKey = new Set(['traceparent', 'tracestate'])\n\nfunction generateCacheKey(request: Request): string {\n  // We pick the fields that goes into the key used to dedupe requests.\n  // We don't include the `cache` field, because we end up using whatever\n  // caching resulted from the first request.\n  // Notably we currently don't consider non-standard (or future) options.\n  // This might not be safe. TODO: warn for non-standard extensions differing.\n  // IF YOU CHANGE THIS UPDATE THE simpleCacheKey ABOVE.\n\n  const filteredHeaders = Array.from(request.headers.entries()).filter(\n    ([key]) => !headersToExcludeInCacheKey.has(key.toLowerCase())\n  )\n\n  return JSON.stringify([\n    request.method,\n    filteredHeaders,\n    request.mode,\n    request.redirect,\n    request.credentials,\n    request.referrer,\n    request.referrerPolicy,\n    request.integrity,\n  ])\n}\n\ntype CacheEntry = [\n  key: string,\n  promise: Promise<Response>,\n  response: Response | null,\n]\n\nexport function createDedupeFetch(originalFetch: typeof fetch) {\n  const getCacheEntries = React.cache(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars -- url is the cache key\n    (url: string): CacheEntry[] => []\n  )\n\n  return function dedupeFetch(\n    resource: URL | RequestInfo,\n    options?: RequestInit\n  ): Promise<Response> {\n    if (options && options.signal) {\n      // If we're passed a signal, then we assume that\n      // someone else controls the lifetime of this object and opts out of\n      // caching. It's effectively the opt-out mechanism.\n      // Ideally we should be able to check this on the Request but\n      // it always gets initialized with its own signal so we don't\n      // know if it's supposed to override - unless we also override the\n      // Request constructor.\n      return originalFetch(resource, options)\n    }\n    // Normalize the Request\n    let url: string\n    let cacheKey: string\n    if (typeof resource === 'string' && !options) {\n      // Fast path.\n      cacheKey = simpleCacheKey\n      url = resource\n    } else {\n      // Normalize the request.\n      // if resource is not a string or a URL (its an instance of Request)\n      // then do not instantiate a new Request but instead\n      // reuse the request as to not disturb the body in the event it's a ReadableStream.\n      const request =\n        typeof resource === 'string' || resource instanceof URL\n          ? new Request(resource, options)\n          : resource\n      if (\n        (request.method !== 'GET' && request.method !== 'HEAD') ||\n        request.keepalive\n      ) {\n        // We currently don't dedupe requests that might have side-effects. Those\n        // have to be explicitly cached. We assume that the request doesn't have a\n        // body if it's GET or HEAD.\n        // keepalive gets treated the same as if you passed a custom cache signal.\n        return originalFetch(resource, options)\n      }\n      cacheKey = generateCacheKey(request)\n      url = request.url\n    }\n\n    const cacheEntries = getCacheEntries(url)\n    for (let i = 0, j = cacheEntries.length; i < j; i += 1) {\n      const [key, promise] = cacheEntries[i]\n      if (key === cacheKey) {\n        return promise.then(() => {\n          const response = cacheEntries[i][2]\n          if (!response) throw new InvariantError('No cached response')\n\n          // We're cloning the response using this utility because there exists\n          // a bug in the undici library around response cloning. See the\n          // following pull request for more details:\n          // https://github.com/vercel/next.js/pull/73274\n          const [cloned1, cloned2] = cloneResponse(response)\n          cacheEntries[i][2] = cloned2\n          return cloned1\n        })\n      }\n    }\n\n    // We pass the original arguments here in case normalizing the Request\n    // doesn't include all the options in this environment.\n    const promise = originalFetch(resource, options)\n    const entry: CacheEntry = [cacheKey, promise, null]\n    cacheEntries.push(entry)\n\n    return promise.then((response) => {\n      // We're cloning the response using this utility because there exists\n      // a bug in the undici library around response cloning. See the\n      // following pull request for more details:\n      // https://github.com/vercel/next.js/pull/73274\n      const [cloned1, cloned2] = cloneResponse(response)\n      entry[2] = cloned2\n      return cloned1\n    })\n  }\n}\n","import type { OutgoingHttpHeaders } from 'http'\nimport type RenderResult from '../render-result'\nimport type { CacheControl, Revalidate } from '../lib/cache-control'\nimport type { RouteKind } from '../route-kind'\n\nexport interface ResponseCacheBase {\n  get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalCache\n      /**\n       * This is a hint to the cache to help it determine what kind of route\n       * this is so it knows where to look up the cache entry from. If not\n       * provided it will test the filesystem to check.\n       */\n      routeKind: RouteKind\n\n      /**\n       * True if this is a fallback request.\n       */\n      isFallback?: boolean\n\n      /**\n       * True if the route is enabled for PPR.\n       */\n      isRoutePPREnabled?: boolean\n    }\n  ): Promise<ResponseCacheEntry | null>\n}\n\n// The server components HMR cache might store other data as well in the future,\n// at which point this should be refactored to a discriminated union type.\nexport interface ServerComponentsHmrCache {\n  get(key: string): CachedFetchData | undefined\n  set(key: string, data: CachedFetchData): void\n}\n\nexport type CachedFetchData = {\n  headers: Record<string, string>\n  body: string\n  url: string\n  status?: number\n}\n\nexport const enum CachedRouteKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  REDIRECT = 'REDIRECT',\n  IMAGE = 'IMAGE',\n}\n\nexport interface CachedFetchValue {\n  kind: CachedRouteKind.FETCH\n  data: CachedFetchData\n  // tags are only present with file-system-cache\n  // fetch cache stores tags outside of cache entry\n  tags?: string[]\n  revalidate: number\n}\n\nexport interface CachedRedirectValue {\n  kind: CachedRouteKind.REDIRECT\n  props: Object\n}\n\nexport interface CachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  rscData: Buffer | undefined\n  status: number | undefined\n  postponed: string | undefined\n  headers: OutgoingHttpHeaders | undefined\n  segmentData: Map<string, Buffer> | undefined\n}\n\nexport interface CachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  html: RenderResult\n  pageData: Object\n  status: number | undefined\n  headers: OutgoingHttpHeaders | undefined\n}\n\nexport interface CachedRouteValue {\n  kind: CachedRouteKind.APP_ROUTE\n  // this needs to be a RenderResult so since renderResponse\n  // expects that type instead of a string\n  body: Buffer\n  status: number\n  headers: OutgoingHttpHeaders\n}\n\nexport interface CachedImageValue {\n  kind: CachedRouteKind.IMAGE\n  etag: string\n  upstreamEtag: string\n  buffer: Buffer\n  extension: string\n  isMiss?: boolean\n  isStale?: boolean\n}\n\nexport interface IncrementalCachedAppPageValue {\n  kind: CachedRouteKind.APP_PAGE\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  rscData: Buffer | undefined\n  headers: OutgoingHttpHeaders | undefined\n  postponed: string | undefined\n  status: number | undefined\n  segmentData: Map<string, Buffer> | undefined\n}\n\nexport interface IncrementalCachedPageValue {\n  kind: CachedRouteKind.PAGES\n  // this needs to be a string since the cache expects to store\n  // the string value\n  html: string\n  pageData: Object\n  headers: OutgoingHttpHeaders | undefined\n  status: number | undefined\n}\n\nexport interface IncrementalResponseCacheEntry {\n  cacheControl?: CacheControl\n  /**\n   * timestamp in milliseconds to revalidate after\n   */\n  revalidateAfter?: Revalidate\n  /**\n   * `-1` here dictates a blocking revalidate should be used\n   */\n  isStale?: boolean | -1\n  isMiss?: boolean\n  value: Exclude<IncrementalCacheValue, CachedFetchValue> | null\n}\n\nexport interface IncrementalFetchCacheEntry {\n  /**\n   * `-1` here dictates a blocking revalidate should be used\n   */\n  isStale?: boolean | -1\n  value: CachedFetchValue\n}\n\nexport type IncrementalCacheEntry =\n  | IncrementalResponseCacheEntry\n  | IncrementalFetchCacheEntry\n\nexport type IncrementalCacheValue =\n  | CachedRedirectValue\n  | IncrementalCachedPageValue\n  | IncrementalCachedAppPageValue\n  | CachedImageValue\n  | CachedFetchValue\n  | CachedRouteValue\n\nexport type ResponseCacheValue =\n  | CachedRedirectValue\n  | CachedPageValue\n  | CachedAppPageValue\n  | CachedImageValue\n  | CachedRouteValue\n\nexport type ResponseCacheEntry = {\n  cacheControl?: CacheControl\n  value: ResponseCacheValue | null\n  isStale?: boolean | -1\n  isMiss?: boolean\n}\n\n/**\n * @param hasResolved whether the responseGenerator has resolved it's promise\n * @param previousCacheEntry the previous cache entry if it exists or the current\n */\nexport type ResponseGenerator = (state: {\n  hasResolved: boolean\n  previousCacheEntry?: IncrementalResponseCacheEntry | null\n  isRevalidating?: boolean\n  span?: any\n\n  /**\n   * When true, this indicates that the response generator is being called in a\n   * context where the response must be generated statically.\n   *\n   * CRITICAL: This should only currently be used when revalidating due to a\n   * dynamic RSC request.\n   */\n  forceStaticRender?: boolean\n}) => Promise<ResponseCacheEntry | null>\n\nexport const enum IncrementalCacheKind {\n  APP_PAGE = 'APP_PAGE',\n  APP_ROUTE = 'APP_ROUTE',\n  PAGES = 'PAGES',\n  FETCH = 'FETCH',\n  IMAGE = 'IMAGE',\n}\n\nexport interface GetIncrementalFetchCacheContext {\n  kind: IncrementalCacheKind.FETCH\n  revalidate?: Revalidate\n  fetchUrl?: string\n  fetchIdx?: number\n  tags?: string[]\n  softTags?: string[]\n}\n\nexport interface GetIncrementalResponseCacheContext {\n  kind: Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH>\n\n  /**\n   * True if the route is enabled for PPR.\n   */\n  isRoutePPREnabled?: boolean\n\n  /**\n   * True if this is a fallback request.\n   */\n  isFallback: boolean\n\n  /**\n   * True if stale data is allowed to be returned.\n   */\n  allowStale?: boolean\n}\n\nexport interface SetIncrementalFetchCacheContext {\n  fetchCache: true\n  fetchUrl?: string\n  fetchIdx?: number\n  tags?: string[]\n  isImplicitBuildTimeCache?: boolean\n}\n\nexport interface SetIncrementalResponseCacheContext {\n  fetchCache?: false\n  cacheControl?: CacheControl\n\n  /**\n   * True if the route is enabled for PPR.\n   */\n  isRoutePPREnabled?: boolean\n\n  /**\n   * True if this is a fallback request.\n   */\n  isFallback?: boolean\n}\n\nexport interface IncrementalResponseCache {\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  set(\n    key: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n}\n\nexport interface IncrementalCache extends IncrementalResponseCache {\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalFetchCacheContext\n  ): Promise<IncrementalFetchCacheEntry | null>\n  get(\n    cacheKey: string,\n    ctx: GetIncrementalResponseCacheContext\n  ): Promise<IncrementalResponseCacheEntry | null>\n  set(\n    key: string,\n    data: CachedFetchValue | null,\n    ctx: SetIncrementalFetchCacheContext\n  ): Promise<void>\n  set(\n    key: string,\n    data: Exclude<IncrementalCacheValue, CachedFetchValue> | null,\n    ctx: SetIncrementalResponseCacheContext\n  ): Promise<void>\n  revalidateTag(\n    tags: string | string[],\n    durations?: { expire?: number }\n  ): Promise<void>\n}\n","import type { SchedulerFn } from './scheduler'\n\nimport { DetachedPromise } from './detached-promise'\n\ntype CacheKeyFn<K, C extends string | number | null> = (\n  key: K\n) => PromiseLike<C> | C\n\ntype BatcherOptions<K, C extends string | number | null> = {\n  cacheKeyFn?: CacheKeyFn<K, C>\n  schedulerFn?: SchedulerFn<void>\n}\n\ntype WorkFnContext<V, K> = {\n  resolve: (value: V | PromiseLike<V>) => void\n  key: K\n}\n\ntype WorkFn<V, K> = (context: WorkFnContext<V, K>) => Promise<V>\n\n/**\n * A wrapper for a function that will only allow one call to the function to\n * execute at a time.\n */\nexport class Batcher<K, V, C extends string | number | null> {\n  private readonly pending = new Map<C, Promise<V>>()\n\n  protected constructor(\n    private readonly cacheKeyFn?: CacheKeyFn<K, C>,\n    /**\n     * A function that will be called to schedule the wrapped function to be\n     * executed. This defaults to a function that will execute the function\n     * immediately.\n     */\n    private readonly schedulerFn: SchedulerFn<void> = (fn) => fn()\n  ) {}\n\n  /**\n   * Creates a new instance of PendingWrapper. If the key extends a string or\n   * number, the key will be used as the cache key. If the key is an object, a\n   * cache key function must be provided.\n   */\n  public static create<K extends string | number | null, V>(\n    options?: BatcherOptions<K, K>\n  ): Batcher<K, V, K>\n  public static create<K, V, C extends string | number | null>(\n    options: BatcherOptions<K, C> &\n      Required<Pick<BatcherOptions<K, C>, 'cacheKeyFn'>>\n  ): Batcher<K, V, C>\n  public static create<K, V, C extends string | number | null>(\n    options?: BatcherOptions<K, C>\n  ): Batcher<K, V, C> {\n    return new Batcher<K, V, C>(options?.cacheKeyFn, options?.schedulerFn)\n  }\n\n  /**\n   * Wraps a function in a promise that will be resolved or rejected only once\n   * for a given key. This will allow multiple calls to the function to be\n   * made, but only one will be executed at a time. The result of the first\n   * call will be returned to all callers.\n   *\n   * @param key the key to use for the cache\n   * @param fn the function to wrap\n   * @returns a promise that resolves to the result of the function\n   */\n  public async batch(key: K, fn: WorkFn<V, K>): Promise<V> {\n    const cacheKey = (this.cacheKeyFn ? await this.cacheKeyFn(key) : key) as C\n    if (cacheKey === null) {\n      return fn({ resolve: (value) => Promise.resolve(value), key })\n    }\n\n    const pending = this.pending.get(cacheKey)\n    if (pending) return pending\n\n    const { promise, resolve, reject } = new DetachedPromise<V>()\n    this.pending.set(cacheKey, promise)\n\n    this.schedulerFn(async () => {\n      try {\n        const result = await fn({ resolve, key })\n\n        // Resolving a promise multiple times is a no-op, so we can safely\n        // resolve all pending promises with the same result.\n        resolve(result)\n      } catch (err) {\n        reject(err)\n      } finally {\n        this.pending.delete(cacheKey)\n      }\n    })\n\n    return promise\n  }\n}\n","import type { OutgoingHttpHeaders, ServerResponse } from 'http'\nimport type { CacheControl } from './lib/cache-control'\nimport type { FetchMetrics } from './base-http'\n\nimport {\n  chainStreams,\n  streamFromBuffer,\n  streamFromString,\n  streamToString,\n} from './stream-utils/node-web-streams-helper'\nimport { isAbortError, pipeToNodeResponse } from './pipe-readable'\nimport type { RenderResumeDataCache } from './resume-data-cache/resume-data-cache'\nimport { InvariantError } from '../shared/lib/invariant-error'\nimport type {\n  HTML_CONTENT_TYPE_HEADER,\n  JSON_CONTENT_TYPE_HEADER,\n  TEXT_PLAIN_CONTENT_TYPE_HEADER,\n} from '../lib/constants'\nimport type { RSC_CONTENT_TYPE_HEADER } from '../client/components/app-router-headers'\n\ntype ContentTypeOption =\n  | typeof RSC_CONTENT_TYPE_HEADER // For App Page RSC responses\n  | typeof HTML_CONTENT_TYPE_HEADER // For App Page, Pages HTML responses\n  | typeof JSON_CONTENT_TYPE_HEADER // For API routes, Next.js data requests\n  | typeof TEXT_PLAIN_CONTENT_TYPE_HEADER // For simplified errors\n\nexport type AppPageRenderResultMetadata = {\n  flightData?: Buffer\n  cacheControl?: CacheControl\n  staticBailoutInfo?: {\n    stack?: string\n    description?: string\n  }\n\n  /**\n   * The postponed state if the render had postponed and needs to be resumed.\n   */\n  postponed?: string\n\n  /**\n   * The headers to set on the response that were added by the render.\n   */\n  headers?: OutgoingHttpHeaders\n  statusCode?: number\n  fetchTags?: string\n  fetchMetrics?: FetchMetrics\n\n  segmentData?: Map<string, Buffer>\n\n  /**\n   * In development, the resume data cache is warmed up before the render. This\n   * is attached to the metadata so that it can be used during the render. When\n   * prerendering, the filled resume data cache is also attached to the metadata\n   * so that it can be used when prerendering matching fallback shells.\n   */\n  renderResumeDataCache?: RenderResumeDataCache\n}\n\nexport type PagesRenderResultMetadata = {\n  pageData?: any\n  cacheControl?: CacheControl\n  assetQueryString?: string\n  isNotFound?: boolean\n  isRedirect?: boolean\n}\n\nexport type StaticRenderResultMetadata = {}\n\nexport type RenderResultMetadata = AppPageRenderResultMetadata &\n  PagesRenderResultMetadata &\n  StaticRenderResultMetadata\n\nexport type RenderResultResponse =\n  | ReadableStream<Uint8Array>[]\n  | ReadableStream<Uint8Array>\n  | string\n  | Buffer\n  | null\n\nexport type RenderResultOptions<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> = {\n  contentType: ContentTypeOption | null\n  waitUntil?: Promise<unknown>\n  metadata: Metadata\n}\n\nexport default class RenderResult<\n  Metadata extends RenderResultMetadata = RenderResultMetadata,\n> {\n  /**\n   * The detected content type for the response. This is used to set the\n   * `Content-Type` header.\n   */\n  public readonly contentType: ContentTypeOption | null\n\n  /**\n   * The metadata for the response. This is used to set the revalidation times\n   * and other metadata.\n   */\n  public readonly metadata: Readonly<Metadata>\n\n  /**\n   * The response itself. This can be a string, a stream, or null. If it's a\n   * string, then it's a static response. If it's a stream, then it's a\n   * dynamic response. If it's null, then the response was not found or was\n   * already sent.\n   */\n  private response: RenderResultResponse\n\n  /**\n   * A render result that represents an empty response. This is used to\n   * represent a response that was not found or was already sent.\n   */\n  public static readonly EMPTY = new RenderResult<StaticRenderResultMetadata>(\n    null,\n    { metadata: {}, contentType: null }\n  )\n\n  /**\n   * Creates a new RenderResult instance from a static response.\n   *\n   * @param value the static response value\n   * @param contentType the content type of the response\n   * @returns a new RenderResult instance\n   */\n  public static fromStatic(\n    value: string | Buffer,\n    contentType: ContentTypeOption\n  ) {\n    return new RenderResult<StaticRenderResultMetadata>(value, {\n      metadata: {},\n      contentType,\n    })\n  }\n\n  private readonly waitUntil?: Promise<unknown>\n\n  constructor(\n    response: RenderResultResponse,\n    { contentType, waitUntil, metadata }: RenderResultOptions<Metadata>\n  ) {\n    this.response = response\n    this.contentType = contentType\n    this.metadata = metadata\n    this.waitUntil = waitUntil\n  }\n\n  public assignMetadata(metadata: Metadata) {\n    Object.assign(this.metadata, metadata)\n  }\n\n  /**\n   * Returns true if the response is null. It can be null if the response was\n   * not found or was already sent.\n   */\n  public get isNull(): boolean {\n    return this.response === null\n  }\n\n  /**\n   * Returns false if the response is a string. It can be a string if the page\n   * was prerendered. If it's not, then it was generated dynamically.\n   */\n  public get isDynamic(): boolean {\n    return typeof this.response !== 'string'\n  }\n\n  /**\n   * Returns the response if it is a string. If the page was dynamic, this will\n   * return a promise if the `stream` option is true, or it will throw an error.\n   *\n   * @param stream Whether or not to return a promise if the response is dynamic\n   * @returns The response as a string\n   */\n  public toUnchunkedString(stream?: false): string\n  public toUnchunkedString(stream: true): Promise<string>\n  public toUnchunkedString(stream = false): Promise<string> | string {\n    if (this.response === null) {\n      // If the response is null, return an empty string. This behavior is\n      // intentional as we're now providing the `RenderResult.EMPTY` value.\n      return ''\n    }\n\n    if (typeof this.response !== 'string') {\n      if (!stream) {\n        throw new InvariantError(\n          'dynamic responses cannot be unchunked. This is a bug in Next.js'\n        )\n      }\n\n      return streamToString(this.readable)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Returns a readable stream of the response.\n   */\n  private get readable(): ReadableStream<Uint8Array> {\n    if (this.response === null) {\n      // If the response is null, return an empty stream. This behavior is\n      // intentional as we're now providing the `RenderResult.EMPTY` value.\n      return new ReadableStream<Uint8Array>({\n        start(controller) {\n          controller.close()\n        },\n      })\n    }\n\n    if (typeof this.response === 'string') {\n      return streamFromString(this.response)\n    }\n\n    if (Buffer.isBuffer(this.response)) {\n      return streamFromBuffer(this.response)\n    }\n\n    // If the response is an array of streams, then chain them together.\n    if (Array.isArray(this.response)) {\n      return chainStreams(...this.response)\n    }\n\n    return this.response\n  }\n\n  /**\n   * Coerces the response to an array of streams. This will convert the response\n   * to an array of streams if it is not already one.\n   *\n   * @returns An array of streams\n   */\n  private coerce(): ReadableStream<Uint8Array>[] {\n    if (this.response === null) {\n      // If the response is null, return an empty stream. This behavior is\n      // intentional as we're now providing the `RenderResult.EMPTY` value.\n      return []\n    }\n\n    if (typeof this.response === 'string') {\n      return [streamFromString(this.response)]\n    } else if (Array.isArray(this.response)) {\n      return this.response\n    } else if (Buffer.isBuffer(this.response)) {\n      return [streamFromBuffer(this.response)]\n    } else {\n      return [this.response]\n    }\n  }\n\n  /**\n   * Unshifts a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the start of the array. When this response is piped, all of the streams\n   * will be piped one after the other.\n   *\n   * @param readable The new stream to unshift\n   */\n  public unshift(readable: ReadableStream<Uint8Array>): void {\n    // Coerce the response to an array of streams.\n    this.response = this.coerce()\n\n    // Add the new stream to the start of the array.\n    this.response.unshift(readable)\n  }\n\n  /**\n   * Chains a new stream to the response. This will convert the response to an\n   * array of streams if it is not already one and will add the new stream to\n   * the end. When this response is piped, all of the streams will be piped\n   * one after the other.\n   *\n   * @param readable The new stream to chain\n   */\n  public push(readable: ReadableStream<Uint8Array>): void {\n    // Coerce the response to an array of streams.\n    this.response = this.coerce()\n\n    // Add the new stream to the end of the array.\n    this.response.push(readable)\n  }\n\n  /**\n   * Pipes the response to a writable stream. This will close/cancel the\n   * writable stream if an error is encountered. If this doesn't throw, then\n   * the writable stream will be closed or aborted.\n   *\n   * @param writable Writable stream to pipe the response to\n   */\n  public async pipeTo(writable: WritableStream<Uint8Array>): Promise<void> {\n    try {\n      await this.readable.pipeTo(writable, {\n        // We want to close the writable stream ourselves so that we can wait\n        // for the waitUntil promise to resolve before closing it. If an error\n        // is encountered, we'll abort the writable stream if we swallowed the\n        // error.\n        preventClose: true,\n      })\n\n      // If there is a waitUntil promise, wait for it to resolve before\n      // closing the writable stream.\n      if (this.waitUntil) await this.waitUntil\n\n      // Close the writable stream.\n      await writable.close()\n    } catch (err) {\n      // If this is an abort error, we should abort the writable stream (as we\n      // took ownership of it when we started piping). We don't need to re-throw\n      // because we handled the error.\n      if (isAbortError(err)) {\n        // Abort the writable stream if an error is encountered.\n        await writable.abort(err)\n\n        return\n      }\n\n      // We're not aborting the writer here as when this method throws it's not\n      // clear as to how so the caller should assume it's their responsibility\n      // to clean up the writer.\n      throw err\n    }\n  }\n\n  /**\n   * Pipes the response to a node response. This will close/cancel the node\n   * response if an error is encountered.\n   *\n   * @param res\n   */\n  public async pipeToNodeResponse(res: ServerResponse) {\n    await pipeToNodeResponse(this.readable, res, this.waitUntil)\n  }\n}\n","export const enum RouteKind {\n  /**\n   * `PAGES` represents all the React pages that are under `pages/`.\n   */\n  PAGES = 'PAGES',\n  /**\n   * `PAGES_API` represents all the API routes under `pages/api/`.\n   */\n  PAGES_API = 'PAGES_API',\n  /**\n   * `APP_PAGE` represents all the React pages that are under `app/` with the\n   * filename of `page.{j,t}s{,x}`.\n   */\n  APP_PAGE = 'APP_PAGE',\n  /**\n   * `APP_ROUTE` represents all the API routes and metadata routes that are under `app/` with the\n   * filename of `route.{j,t}s{,x}`.\n   */\n  APP_ROUTE = 'APP_ROUTE',\n\n  /**\n   * `IMAGE` represents all the images that are generated by `next/image`.\n   */\n  IMAGE = 'IMAGE',\n}\n","import {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedAppPageValue,\n  type CachedPageValue,\n  type IncrementalResponseCacheEntry,\n  type ResponseCacheEntry,\n} from './types'\n\nimport RenderResult from '../render-result'\nimport { RouteKind } from '../route-kind'\nimport { HTML_CONTENT_TYPE_HEADER } from '../../lib/constants'\n\nexport async function fromResponseCacheEntry(\n  cacheEntry: ResponseCacheEntry\n): Promise<IncrementalResponseCacheEntry> {\n  return {\n    ...cacheEntry,\n    value:\n      cacheEntry.value?.kind === CachedRouteKind.PAGES\n        ? {\n            kind: CachedRouteKind.PAGES,\n            html: await cacheEntry.value.html.toUnchunkedString(true),\n            pageData: cacheEntry.value.pageData,\n            headers: cacheEntry.value.headers,\n            status: cacheEntry.value.status,\n          }\n        : cacheEntry.value?.kind === CachedRouteKind.APP_PAGE\n          ? {\n              kind: CachedRouteKind.APP_PAGE,\n              html: await cacheEntry.value.html.toUnchunkedString(true),\n              postponed: cacheEntry.value.postponed,\n              rscData: cacheEntry.value.rscData,\n              headers: cacheEntry.value.headers,\n              status: cacheEntry.value.status,\n              segmentData: cacheEntry.value.segmentData,\n            }\n          : cacheEntry.value,\n  }\n}\n\nexport async function toResponseCacheEntry(\n  response: IncrementalResponseCacheEntry | null\n): Promise<ResponseCacheEntry | null> {\n  if (!response) return null\n\n  return {\n    isMiss: response.isMiss,\n    isStale: response.isStale,\n    cacheControl: response.cacheControl,\n    value:\n      response.value?.kind === CachedRouteKind.PAGES\n        ? ({\n            kind: CachedRouteKind.PAGES,\n            html: RenderResult.fromStatic(\n              response.value.html,\n              HTML_CONTENT_TYPE_HEADER\n            ),\n            pageData: response.value.pageData,\n            headers: response.value.headers,\n            status: response.value.status,\n          } satisfies CachedPageValue)\n        : response.value?.kind === CachedRouteKind.APP_PAGE\n          ? ({\n              kind: CachedRouteKind.APP_PAGE,\n              html: RenderResult.fromStatic(\n                response.value.html,\n                HTML_CONTENT_TYPE_HEADER\n              ),\n              rscData: response.value.rscData,\n              headers: response.value.headers,\n              status: response.value.status,\n              postponed: response.value.postponed,\n              segmentData: response.value.segmentData,\n            } satisfies CachedAppPageValue)\n          : response.value,\n  }\n}\n\nexport function routeKindToIncrementalCacheKind(\n  routeKind: RouteKind\n): Exclude<IncrementalCacheKind, IncrementalCacheKind.FETCH> {\n  switch (routeKind) {\n    case RouteKind.PAGES:\n      return IncrementalCacheKind.PAGES\n    case RouteKind.APP_PAGE:\n      return IncrementalCacheKind.APP_PAGE\n    case RouteKind.IMAGE:\n      return IncrementalCacheKind.IMAGE\n    case RouteKind.APP_ROUTE:\n      return IncrementalCacheKind.APP_ROUTE\n    case RouteKind.PAGES_API:\n      // Pages Router API routes are not cached in the incremental cache.\n      throw new Error(`Unexpected route kind ${routeKind}`)\n    default:\n      return routeKind satisfies never\n  }\n}\n","import type {\n  ResponseCacheEntry,\n  ResponseGenerator,\n  ResponseCacheBase,\n  IncrementalResponseCacheEntry,\n  IncrementalResponseCache,\n} from './types'\n\nimport { Batcher } from '../../lib/batcher'\nimport { scheduleOnNextTick } from '../../lib/scheduler'\nimport {\n  fromResponseCacheEntry,\n  routeKindToIncrementalCacheKind,\n  toResponseCacheEntry,\n} from './utils'\nimport type { RouteKind } from '../route-kind'\n\nexport * from './types'\n\nexport default class ResponseCache implements ResponseCacheBase {\n  private readonly getBatcher = Batcher.create<\n    { key: string; isOnDemandRevalidate: boolean },\n    IncrementalResponseCacheEntry | null,\n    string\n  >({\n    // Ensure on-demand revalidate doesn't block normal requests, it should be\n    // safe to run an on-demand revalidate for the same key as a normal request.\n    cacheKeyFn: ({ key, isOnDemandRevalidate }) =>\n      `${key}-${isOnDemandRevalidate ? '1' : '0'}`,\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private readonly revalidateBatcher = Batcher.create<\n    string,\n    IncrementalResponseCacheEntry | null\n  >({\n    // We wait to do any async work until after we've added our promise to\n    // `pendingResponses` to ensure that any any other calls will reuse the\n    // same promise until we've fully finished our work.\n    schedulerFn: scheduleOnNextTick,\n  })\n\n  private previousCacheItem?: {\n    key: string\n    entry: IncrementalResponseCacheEntry | null\n    expiresAt: number\n  }\n\n  // we don't use minimal_mode name here as this.minimal_mode is\n  // statically replace for server runtimes but we need it to\n  // be dynamic here\n  private minimal_mode?: boolean\n\n  constructor(minimal_mode: boolean) {\n    this.minimal_mode = minimal_mode\n  }\n\n  /**\n   * Gets the response cache entry for the given key.\n   *\n   * @param key - The key to get the response cache entry for.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param context - The context for the get request.\n   * @returns The response cache entry.\n   */\n  public async get(\n    key: string | null,\n    responseGenerator: ResponseGenerator,\n    context: {\n      routeKind: RouteKind\n      isOnDemandRevalidate?: boolean\n      isPrefetch?: boolean\n      incrementalCache: IncrementalResponseCache\n      isRoutePPREnabled?: boolean\n      isFallback?: boolean\n      waitUntil?: (prom: Promise<any>) => void\n    }\n  ): Promise<ResponseCacheEntry | null> {\n    // If there is no key for the cache, we can't possibly look this up in the\n    // cache so just return the result of the response generator.\n    if (!key) {\n      return responseGenerator({\n        hasResolved: false,\n        previousCacheEntry: null,\n      })\n    }\n\n    // Check minimal mode cache before doing any other work\n    if (\n      this.minimal_mode &&\n      this.previousCacheItem?.key === key &&\n      this.previousCacheItem.expiresAt > Date.now()\n    ) {\n      return toResponseCacheEntry(this.previousCacheItem.entry)\n    }\n\n    const {\n      incrementalCache,\n      isOnDemandRevalidate = false,\n      isFallback = false,\n      isRoutePPREnabled = false,\n      isPrefetch = false,\n      waitUntil,\n      routeKind,\n    } = context\n\n    const response = await this.getBatcher.batch(\n      { key, isOnDemandRevalidate },\n      ({ resolve }) => {\n        const promise = this.handleGet(\n          key,\n          responseGenerator,\n          {\n            incrementalCache,\n            isOnDemandRevalidate,\n            isFallback,\n            isRoutePPREnabled,\n            isPrefetch,\n            routeKind,\n          },\n          resolve\n        )\n\n        // We need to ensure background revalidates are passed to waitUntil.\n        if (waitUntil) waitUntil(promise)\n\n        return promise\n      }\n    )\n\n    return toResponseCacheEntry(response)\n  }\n\n  /**\n   * Handles the get request for the response cache.\n   *\n   * @param key - The key to get the response cache entry for.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param context - The context for the get request.\n   * @param resolve - The resolve function to use to resolve the response cache entry.\n   * @returns The response cache entry.\n   */\n  private async handleGet(\n    key: string,\n    responseGenerator: ResponseGenerator,\n    context: {\n      incrementalCache: IncrementalResponseCache\n      isOnDemandRevalidate: boolean\n      isFallback: boolean\n      isRoutePPREnabled: boolean\n      isPrefetch: boolean\n      routeKind: RouteKind\n    },\n    resolve: (value: IncrementalResponseCacheEntry | null) => void\n  ): Promise<IncrementalResponseCacheEntry | null> {\n    let previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null =\n      null\n    let resolved = false\n\n    try {\n      // Get the previous cache entry if not in minimal mode\n      previousIncrementalCacheEntry = !this.minimal_mode\n        ? await context.incrementalCache.get(key, {\n            kind: routeKindToIncrementalCacheKind(context.routeKind),\n            isRoutePPREnabled: context.isRoutePPREnabled,\n            isFallback: context.isFallback,\n          })\n        : null\n\n      if (previousIncrementalCacheEntry && !context.isOnDemandRevalidate) {\n        resolve(previousIncrementalCacheEntry)\n        resolved = true\n\n        if (!previousIncrementalCacheEntry.isStale || context.isPrefetch) {\n          // The cached value is still valid, so we don't need to update it yet.\n          return previousIncrementalCacheEntry\n        }\n      }\n\n      // Revalidate the cache entry\n      const incrementalResponseCacheEntry = await this.revalidate(\n        key,\n        context.incrementalCache,\n        context.isRoutePPREnabled,\n        context.isFallback,\n        responseGenerator,\n        previousIncrementalCacheEntry,\n        previousIncrementalCacheEntry !== null && !context.isOnDemandRevalidate\n      )\n\n      // Handle null response\n      if (!incrementalResponseCacheEntry) {\n        // Unset the previous cache item if it was set so we don't use it again.\n        if (this.minimal_mode) this.previousCacheItem = undefined\n        return null\n      }\n\n      // Resolve for on-demand revalidation or if not already resolved\n      if (context.isOnDemandRevalidate && !resolved) {\n        return incrementalResponseCacheEntry\n      }\n\n      return incrementalResponseCacheEntry\n    } catch (err) {\n      // If we've already resolved the cache entry, we can't reject as we\n      // already resolved the cache entry so log the error here.\n      if (resolved) {\n        console.error(err)\n        return null\n      }\n\n      throw err\n    }\n  }\n\n  /**\n   * Revalidates the cache entry for the given key.\n   *\n   * @param key - The key to revalidate the cache entry for.\n   * @param incrementalCache - The incremental cache to use to revalidate the cache entry.\n   * @param isRoutePPREnabled - Whether the route is PPR enabled.\n   * @param isFallback - Whether the route is a fallback.\n   * @param responseGenerator - The response generator to use to generate the response cache entry.\n   * @param previousIncrementalCacheEntry - The previous cache entry to use to revalidate the cache entry.\n   * @param hasResolved - Whether the response has been resolved.\n   * @returns The revalidated cache entry.\n   */\n  public async revalidate(\n    key: string,\n    incrementalCache: IncrementalResponseCache,\n    isRoutePPREnabled: boolean,\n    isFallback: boolean,\n    responseGenerator: ResponseGenerator,\n    previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null,\n    hasResolved: boolean,\n    waitUntil?: (prom: Promise<any>) => void\n  ) {\n    return this.revalidateBatcher.batch(key, () => {\n      const promise = this.handleRevalidate(\n        key,\n        incrementalCache,\n        isRoutePPREnabled,\n        isFallback,\n        responseGenerator,\n        previousIncrementalCacheEntry,\n        hasResolved\n      )\n\n      // We need to ensure background revalidates are passed to waitUntil.\n      if (waitUntil) waitUntil(promise)\n\n      return promise\n    })\n  }\n\n  private async handleRevalidate(\n    key: string,\n    incrementalCache: IncrementalResponseCache,\n    isRoutePPREnabled: boolean,\n    isFallback: boolean,\n    responseGenerator: ResponseGenerator,\n    previousIncrementalCacheEntry: IncrementalResponseCacheEntry | null,\n    hasResolved: boolean\n  ) {\n    try {\n      // Generate the response cache entry using the response generator.\n      const responseCacheEntry = await responseGenerator({\n        hasResolved,\n        previousCacheEntry: previousIncrementalCacheEntry,\n        isRevalidating: true,\n      })\n      if (!responseCacheEntry) {\n        return null\n      }\n\n      // Convert the response cache entry to an incremental response cache entry.\n      const incrementalResponseCacheEntry = await fromResponseCacheEntry({\n        ...responseCacheEntry,\n        isMiss: !previousIncrementalCacheEntry,\n      })\n\n      // We want to persist the result only if it has a cache control value\n      // defined.\n      if (incrementalResponseCacheEntry.cacheControl) {\n        if (this.minimal_mode) {\n          this.previousCacheItem = {\n            key,\n            entry: incrementalResponseCacheEntry,\n            expiresAt: Date.now() + 1000,\n          }\n        } else {\n          await incrementalCache.set(key, incrementalResponseCacheEntry.value, {\n            cacheControl: incrementalResponseCacheEntry.cacheControl,\n            isRoutePPREnabled,\n            isFallback,\n          })\n        }\n      }\n\n      return incrementalResponseCacheEntry\n    } catch (err) {\n      // When a path is erroring we automatically re-set the existing cache\n      // with new revalidate and expire times to prevent non-stop retrying.\n      if (previousIncrementalCacheEntry?.cacheControl) {\n        const revalidate = Math.min(\n          Math.max(\n            previousIncrementalCacheEntry.cacheControl.revalidate || 3,\n            3\n          ),\n          30\n        )\n        const expire =\n          previousIncrementalCacheEntry.cacheControl.expire === undefined\n            ? undefined\n            : Math.max(\n                revalidate + 3,\n                previousIncrementalCacheEntry.cacheControl.expire\n              )\n\n        await incrementalCache.set(key, previousIncrementalCacheEntry.value, {\n          cacheControl: { revalidate: revalidate, expire: expire },\n          isRoutePPREnabled,\n          isFallback,\n        })\n      }\n\n      // We haven't resolved yet, so let's throw to indicate an error.\n      throw err\n    }\n  }\n}\n","import type {\n  WorkAsyncStorage,\n  WorkStore,\n} from '../app-render/work-async-storage.external'\n\nimport { AppRenderSpan, NextNodeServerSpan } from './trace/constants'\nimport { getTracer, SpanKind } from './trace/tracer'\nimport {\n  CACHE_ONE_YEAR,\n  INFINITE_CACHE,\n  NEXT_CACHE_TAG_MAX_ITEMS,\n  NEXT_CACHE_TAG_MAX_LENGTH,\n} from '../../lib/constants'\nimport { markCurrentScopeAsDynamic } from '../app-render/dynamic-rendering'\nimport { makeHangingPromise } from '../dynamic-rendering-utils'\nimport type { FetchMetric } from '../base-http'\nimport { createDedupeFetch } from './dedupe-fetch'\nimport {\n  getCacheSignal,\n  type RevalidateStore,\n  type WorkUnitAsyncStorage,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedFetchData,\n  type ServerComponentsHmrCache,\n  type SetIncrementalFetchCacheContext,\n} from '../response-cache'\nimport { cloneResponse } from './clone-response'\nimport type { IncrementalCache } from './incremental-cache'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\ntype Fetcher = typeof fetch\n\ntype PatchedFetcher = Fetcher & {\n  readonly __nextPatched: true\n  readonly __nextGetStaticStore: () => WorkAsyncStorage\n  readonly _nextOriginalFetch: Fetcher\n}\n\nexport const NEXT_PATCH_SYMBOL = Symbol.for('next-patch')\n\nfunction isFetchPatched() {\n  return (globalThis as Record<symbol, unknown>)[NEXT_PATCH_SYMBOL] === true\n}\n\nexport function validateRevalidate(\n  revalidateVal: unknown,\n  route: string\n): undefined | number {\n  try {\n    let normalizedRevalidate: number | undefined = undefined\n\n    if (revalidateVal === false) {\n      normalizedRevalidate = INFINITE_CACHE\n    } else if (\n      typeof revalidateVal === 'number' &&\n      !isNaN(revalidateVal) &&\n      revalidateVal > -1\n    ) {\n      normalizedRevalidate = revalidateVal\n    } else if (typeof revalidateVal !== 'undefined') {\n      throw new Error(\n        `Invalid revalidate value \"${revalidateVal}\" on \"${route}\", must be a non-negative number or false`\n      )\n    }\n    return normalizedRevalidate\n  } catch (err: any) {\n    // handle client component error from attempting to check revalidate value\n    if (err instanceof Error && err.message.includes('Invalid revalidate')) {\n      throw err\n    }\n    return undefined\n  }\n}\n\nexport function validateTags(tags: any[], description: string) {\n  const validTags: string[] = []\n  const invalidTags: Array<{\n    tag: any\n    reason: string\n  }> = []\n\n  for (let i = 0; i < tags.length; i++) {\n    const tag = tags[i]\n\n    if (typeof tag !== 'string') {\n      invalidTags.push({ tag, reason: 'invalid type, must be a string' })\n    } else if (tag.length > NEXT_CACHE_TAG_MAX_LENGTH) {\n      invalidTags.push({\n        tag,\n        reason: `exceeded max length of ${NEXT_CACHE_TAG_MAX_LENGTH}`,\n      })\n    } else {\n      validTags.push(tag)\n    }\n\n    if (validTags.length > NEXT_CACHE_TAG_MAX_ITEMS) {\n      console.warn(\n        `Warning: exceeded max tag count for ${description}, dropped tags:`,\n        tags.slice(i).join(', ')\n      )\n      break\n    }\n  }\n\n  if (invalidTags.length > 0) {\n    console.warn(`Warning: invalid tags passed to ${description}: `)\n\n    for (const { tag, reason } of invalidTags) {\n      console.log(`tag: \"${tag}\" ${reason}`)\n    }\n  }\n  return validTags\n}\n\nfunction trackFetchMetric(\n  workStore: WorkStore,\n  ctx: Omit<FetchMetric, 'end' | 'idx'>\n) {\n  if (!workStore.shouldTrackFetchMetrics) {\n    return\n  }\n\n  workStore.fetchMetrics ??= []\n\n  workStore.fetchMetrics.push({\n    ...ctx,\n    end: performance.timeOrigin + performance.now(),\n    idx: workStore.nextFetchId || 0,\n  })\n}\n\nasync function createCachedPrerenderResponse(\n  res: Response,\n  cacheKey: string,\n  incrementalCacheContext: SetIncrementalFetchCacheContext | undefined,\n  incrementalCache: IncrementalCache,\n  revalidate: number,\n  handleUnlock: () => Promise<void> | void\n): Promise<Response> {\n  // We are prerendering at build time or revalidate time with cacheComponents so we\n  // need to buffer the response so we can guarantee it can be read in a\n  // microtask.\n  const bodyBuffer = await res.arrayBuffer()\n\n  const fetchedData = {\n    headers: Object.fromEntries(res.headers.entries()),\n    body: Buffer.from(bodyBuffer).toString('base64'),\n    status: res.status,\n    url: res.url,\n  }\n\n  // We can skip setting the serverComponentsHmrCache because we aren't in dev\n  // mode.\n\n  if (incrementalCacheContext) {\n    await incrementalCache.set(\n      cacheKey,\n      { kind: CachedRouteKind.FETCH, data: fetchedData, revalidate },\n      incrementalCacheContext\n    )\n  }\n\n  await handleUnlock()\n\n  // We return a new Response to the caller.\n  return new Response(bodyBuffer, {\n    headers: res.headers,\n    status: res.status,\n    statusText: res.statusText,\n  })\n}\n\nasync function createCachedDynamicResponse(\n  workStore: WorkStore,\n  res: Response,\n  cacheKey: string,\n  incrementalCacheContext: SetIncrementalFetchCacheContext | undefined,\n  incrementalCache: IncrementalCache,\n  serverComponentsHmrCache: ServerComponentsHmrCache | undefined,\n  revalidate: number,\n  input: RequestInfo | URL,\n  handleUnlock: () => Promise<void> | void\n): Promise<Response> {\n  // We're cloning the response using this utility because there exists a bug in\n  // the undici library around response cloning. See the following pull request\n  // for more details: https://github.com/vercel/next.js/pull/73274\n  const [cloned1, cloned2] = cloneResponse(res)\n\n  // We are dynamically rendering including dev mode. We want to return the\n  // response to the caller as soon as possible because it might stream over a\n  // very long time.\n  const cacheSetPromise = cloned1\n    .arrayBuffer()\n    .then(async (arrayBuffer) => {\n      const bodyBuffer = Buffer.from(arrayBuffer)\n\n      const fetchedData = {\n        headers: Object.fromEntries(cloned1.headers.entries()),\n        body: bodyBuffer.toString('base64'),\n        status: cloned1.status,\n        url: cloned1.url,\n      }\n\n      serverComponentsHmrCache?.set(cacheKey, fetchedData)\n\n      if (incrementalCacheContext) {\n        await incrementalCache.set(\n          cacheKey,\n          { kind: CachedRouteKind.FETCH, data: fetchedData, revalidate },\n          incrementalCacheContext\n        )\n      }\n    })\n    .catch((error) => console.warn(`Failed to set fetch cache`, input, error))\n    .finally(handleUnlock)\n\n  const pendingRevalidateKey = `cache-set-${cacheKey}`\n  workStore.pendingRevalidates ??= {}\n\n  if (pendingRevalidateKey in workStore.pendingRevalidates) {\n    // there is already a pending revalidate entry that we need to await to\n    // avoid race conditions\n    await workStore.pendingRevalidates[pendingRevalidateKey]\n  }\n\n  workStore.pendingRevalidates[pendingRevalidateKey] = cacheSetPromise.finally(\n    () => {\n      // If the pending revalidate is not present in the store, then we have\n      // nothing to delete.\n      if (!workStore.pendingRevalidates?.[pendingRevalidateKey]) {\n        return\n      }\n\n      delete workStore.pendingRevalidates[pendingRevalidateKey]\n    }\n  )\n\n  return cloned2\n}\n\ninterface PatchableModule {\n  workAsyncStorage: WorkAsyncStorage\n  workUnitAsyncStorage: WorkUnitAsyncStorage\n}\n\nexport function createPatchedFetcher(\n  originFetch: Fetcher,\n  { workAsyncStorage, workUnitAsyncStorage }: PatchableModule\n): PatchedFetcher {\n  // Create the patched fetch function.\n  const patched = async function fetch(\n    input: RequestInfo | URL,\n    init: RequestInit | undefined\n  ): Promise<Response> {\n    let url: URL | undefined\n    try {\n      url = new URL(input instanceof Request ? input.url : input)\n      url.username = ''\n      url.password = ''\n    } catch {\n      // Error caused by malformed URL should be handled by native fetch\n      url = undefined\n    }\n    const fetchUrl = url?.href ?? ''\n    const method = init?.method?.toUpperCase() || 'GET'\n\n    // Do create a new span trace for internal fetches in the\n    // non-verbose mode.\n    const isInternal = (init?.next as any)?.internal === true\n    const hideSpan = process.env.NEXT_OTEL_FETCH_DISABLED === '1'\n    // We don't track fetch metrics for internal fetches\n    // so it's not critical that we have a start time, as it won't be recorded.\n    // This is to workaround a flaky issue where performance APIs might\n    // not be available and will require follow-up investigation.\n    const fetchStart: number | undefined = isInternal\n      ? undefined\n      : performance.timeOrigin + performance.now()\n\n    const workStore = workAsyncStorage.getStore()\n    const workUnitStore = workUnitAsyncStorage.getStore()\n\n    // During static generation we track cache reads so we can reason about when they fill\n    let cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n    if (cacheSignal) {\n      cacheSignal.beginRead()\n    }\n\n    const result = getTracer().trace(\n      isInternal ? NextNodeServerSpan.internalFetch : AppRenderSpan.fetch,\n      {\n        hideSpan,\n        kind: SpanKind.CLIENT,\n        spanName: ['fetch', method, fetchUrl].filter(Boolean).join(' '),\n        attributes: {\n          'http.url': fetchUrl,\n          'http.method': method,\n          'net.peer.name': url?.hostname,\n          'net.peer.port': url?.port || undefined,\n        },\n      },\n      async () => {\n        // If this is an internal fetch, we should not do any special treatment.\n        if (isInternal) {\n          return originFetch(input, init)\n        }\n\n        // If the workStore is not available, we can't do any\n        // special treatment of fetch, therefore fallback to the original\n        // fetch implementation.\n        if (!workStore) {\n          return originFetch(input, init)\n        }\n\n        // We should also fallback to the original fetch implementation if we\n        // are in draft mode, it does not constitute a static generation.\n        if (workStore.isDraftMode) {\n          return originFetch(input, init)\n        }\n\n        const isRequestInput =\n          input &&\n          typeof input === 'object' &&\n          typeof (input as Request).method === 'string'\n\n        const getRequestMeta = (field: string) => {\n          // If request input is present but init is not, retrieve from input first.\n          const value = (init as any)?.[field]\n          return value || (isRequestInput ? (input as any)[field] : null)\n        }\n\n        let finalRevalidate: number | undefined = undefined\n        const getNextField = (field: 'revalidate' | 'tags') => {\n          return typeof init?.next?.[field] !== 'undefined'\n            ? init?.next?.[field]\n            : isRequestInput\n              ? (input as any).next?.[field]\n              : undefined\n        }\n        // RequestInit doesn't keep extra fields e.g. next so it's\n        // only available if init is used separate\n        const originalFetchRevalidate = getNextField('revalidate')\n        let currentFetchRevalidate = originalFetchRevalidate\n        const tags: string[] = validateTags(\n          getNextField('tags') || [],\n          `fetch ${input.toString()}`\n        )\n\n        let revalidateStore: RevalidateStore | undefined\n\n        if (workUnitStore) {\n          switch (workUnitStore.type) {\n            case 'prerender':\n            case 'prerender-runtime':\n            // TODO: Stop accumulating tags in client prerender. (fallthrough)\n            case 'prerender-client':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n              revalidateStore = workUnitStore\n              break\n            case 'request':\n            case 'unstable-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n\n        if (revalidateStore) {\n          if (Array.isArray(tags)) {\n            // Collect tags onto parent caches or parent prerenders.\n            const collectedTags =\n              revalidateStore.tags ?? (revalidateStore.tags = [])\n            for (const tag of tags) {\n              if (!collectedTags.includes(tag)) {\n                collectedTags.push(tag)\n              }\n            }\n          }\n        }\n\n        const implicitTags = workUnitStore?.implicitTags\n\n        let pageFetchCacheMode = workStore.fetchCache\n\n        if (workUnitStore) {\n          switch (workUnitStore.type) {\n            case 'unstable-cache':\n              // Inside unstable-cache we treat it the same as force-no-store on\n              // the page.\n              pageFetchCacheMode = 'force-no-store'\n              break\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'request':\n            case 'cache':\n            case 'private-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n\n        const isUsingNoStore = !!workStore.isUnstableNoStore\n\n        let currentFetchCacheConfig = getRequestMeta('cache')\n        let cacheReason = ''\n        let cacheWarning: string | undefined\n\n        if (\n          typeof currentFetchCacheConfig === 'string' &&\n          typeof currentFetchRevalidate !== 'undefined'\n        ) {\n          // If the revalidate value conflicts with the cache value, we should warn the user and unset the conflicting values.\n          const isConflictingRevalidate =\n            // revalidate: 0 and cache: force-cache\n            (currentFetchCacheConfig === 'force-cache' &&\n              currentFetchRevalidate === 0) ||\n            // revalidate: >0 or revalidate: false and cache: no-store\n            (currentFetchCacheConfig === 'no-store' &&\n              (currentFetchRevalidate > 0 || currentFetchRevalidate === false))\n\n          if (isConflictingRevalidate) {\n            cacheWarning = `Specified \"cache: ${currentFetchCacheConfig}\" and \"revalidate: ${currentFetchRevalidate}\", only one should be specified.`\n            currentFetchCacheConfig = undefined\n            currentFetchRevalidate = undefined\n          }\n        }\n\n        const hasExplicitFetchCacheOptOut =\n          // fetch config itself signals not to cache\n          currentFetchCacheConfig === 'no-cache' ||\n          currentFetchCacheConfig === 'no-store' ||\n          // the fetch isn't explicitly caching and the segment level cache config signals not to cache\n          // note: `pageFetchCacheMode` is also set by being in an unstable_cache context.\n          pageFetchCacheMode === 'force-no-store' ||\n          pageFetchCacheMode === 'only-no-store'\n\n        // If no explicit fetch cache mode is set, but dynamic = `force-dynamic` is set,\n        // we shouldn't consider caching the fetch. This is because the `dynamic` cache\n        // is considered a \"top-level\" cache mode, whereas something like `fetchCache` is more\n        // fine-grained. Top-level modes are responsible for setting reasonable defaults for the\n        // other configurations.\n        const noFetchConfigAndForceDynamic =\n          !pageFetchCacheMode &&\n          !currentFetchCacheConfig &&\n          !currentFetchRevalidate &&\n          workStore.forceDynamic\n\n        if (\n          // force-cache was specified without a revalidate value. We set the revalidate value to false\n          // which will signal the cache to not revalidate\n          currentFetchCacheConfig === 'force-cache' &&\n          typeof currentFetchRevalidate === 'undefined'\n        ) {\n          currentFetchRevalidate = false\n        } else if (\n          hasExplicitFetchCacheOptOut ||\n          noFetchConfigAndForceDynamic\n        ) {\n          currentFetchRevalidate = 0\n        }\n\n        if (\n          currentFetchCacheConfig === 'no-cache' ||\n          currentFetchCacheConfig === 'no-store'\n        ) {\n          cacheReason = `cache: ${currentFetchCacheConfig}`\n        }\n\n        finalRevalidate = validateRevalidate(\n          currentFetchRevalidate,\n          workStore.route\n        )\n\n        const _headers = getRequestMeta('headers')\n        const initHeaders: Headers =\n          typeof _headers?.get === 'function'\n            ? _headers\n            : new Headers(_headers || {})\n\n        const hasUnCacheableHeader =\n          initHeaders.get('authorization') || initHeaders.get('cookie')\n\n        const isUnCacheableMethod = !['get', 'head'].includes(\n          getRequestMeta('method')?.toLowerCase() || 'get'\n        )\n\n        /**\n         * We automatically disable fetch caching under the following conditions:\n         * - Fetch cache configs are not set. Specifically:\n         *    - A page fetch cache mode is not set (export const fetchCache=...)\n         *    - A fetch cache mode is not set in the fetch call (fetch(url, { cache: ... }))\n         *      or the fetch cache mode is set to 'default'\n         *    - A fetch revalidate value is not set in the fetch call (fetch(url, { revalidate: ... }))\n         * - OR the fetch comes after a configuration that triggered dynamic rendering (e.g., reading cookies())\n         *   and the fetch was considered uncacheable (e.g., POST method or has authorization headers)\n         */\n        const hasNoExplicitCacheConfig =\n          // eslint-disable-next-line eqeqeq\n          pageFetchCacheMode == undefined &&\n          // eslint-disable-next-line eqeqeq\n          (currentFetchCacheConfig == undefined ||\n            // when considering whether to opt into the default \"no-cache\" fetch semantics,\n            // a \"default\" cache config should be treated the same as no cache config\n            currentFetchCacheConfig === 'default') &&\n          // eslint-disable-next-line eqeqeq\n          currentFetchRevalidate == undefined\n\n        let autoNoCache = Boolean(\n          (hasUnCacheableHeader || isUnCacheableMethod) &&\n            revalidateStore?.revalidate === 0\n        )\n\n        let isImplicitBuildTimeCache = false\n\n        if (!autoNoCache && hasNoExplicitCacheConfig) {\n          // We don't enable automatic no-cache behavior during build-time\n          // prerendering so that we can still leverage the fetch cache between\n          // export workers.\n          if (workStore.isBuildTimePrerendering) {\n            isImplicitBuildTimeCache = true\n          } else {\n            autoNoCache = true\n          }\n        }\n\n        // If we have no cache config, and we're in Dynamic I/O prerendering,\n        // it'll be a dynamic call. We don't have to issue that dynamic call.\n        if (hasNoExplicitCacheConfig && workUnitStore !== undefined) {\n          switch (workUnitStore.type) {\n            case 'prerender':\n            case 'prerender-runtime':\n            // While we don't want to do caching in the client scope we know the\n            // fetch will be dynamic for cacheComponents so we may as well avoid the\n            // call here. (fallthrough)\n            case 'prerender-client':\n              if (cacheSignal) {\n                cacheSignal.endRead()\n                cacheSignal = null\n              }\n\n              return makeHangingPromise<Response>(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'fetch()'\n              )\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'request':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n\n        switch (pageFetchCacheMode) {\n          case 'force-no-store': {\n            cacheReason = 'fetchCache = force-no-store'\n            break\n          }\n          case 'only-no-store': {\n            if (\n              currentFetchCacheConfig === 'force-cache' ||\n              (typeof finalRevalidate !== 'undefined' && finalRevalidate > 0)\n            ) {\n              throw new Error(\n                `cache: 'force-cache' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-no-store'`\n              )\n            }\n            cacheReason = 'fetchCache = only-no-store'\n            break\n          }\n          case 'only-cache': {\n            if (currentFetchCacheConfig === 'no-store') {\n              throw new Error(\n                `cache: 'no-store' used on fetch for ${fetchUrl} with 'export const fetchCache = 'only-cache'`\n              )\n            }\n            break\n          }\n          case 'force-cache': {\n            if (\n              typeof currentFetchRevalidate === 'undefined' ||\n              currentFetchRevalidate === 0\n            ) {\n              cacheReason = 'fetchCache = force-cache'\n              finalRevalidate = INFINITE_CACHE\n            }\n            break\n          }\n          case 'default-cache':\n          case 'default-no-store':\n          case 'auto':\n          case undefined:\n            // sometimes we won't match the above cases. the reason we don't move\n            // everything to this switch is the use of autoNoCache which is not a fetchCacheMode\n            // I suspect this could be unified with fetchCacheMode however in which case we could\n            // simplify the switch case and ensure we have an exhaustive switch handling all modes\n            break\n          default:\n            pageFetchCacheMode satisfies never\n        }\n\n        if (typeof finalRevalidate === 'undefined') {\n          if (pageFetchCacheMode === 'default-cache' && !isUsingNoStore) {\n            finalRevalidate = INFINITE_CACHE\n            cacheReason = 'fetchCache = default-cache'\n          } else if (pageFetchCacheMode === 'default-no-store') {\n            finalRevalidate = 0\n            cacheReason = 'fetchCache = default-no-store'\n          } else if (isUsingNoStore) {\n            finalRevalidate = 0\n            cacheReason = 'noStore call'\n          } else if (autoNoCache) {\n            finalRevalidate = 0\n            cacheReason = 'auto no cache'\n          } else {\n            // TODO: should we consider this case an invariant?\n            cacheReason = 'auto cache'\n            finalRevalidate = revalidateStore\n              ? revalidateStore.revalidate\n              : INFINITE_CACHE\n          }\n        } else if (!cacheReason) {\n          cacheReason = `revalidate: ${finalRevalidate}`\n        }\n\n        if (\n          // when force static is configured we don't bail from\n          // `revalidate: 0` values\n          !(workStore.forceStatic && finalRevalidate === 0) &&\n          // we don't consider autoNoCache to switch to dynamic for ISR\n          !autoNoCache &&\n          // If the revalidate value isn't currently set or the value is less\n          // than the current revalidate value, we should update the revalidate\n          // value.\n          revalidateStore &&\n          finalRevalidate < revalidateStore.revalidate\n        ) {\n          // If we were setting the revalidate value to 0, we should try to\n          // postpone instead first.\n          if (finalRevalidate === 0) {\n            if (workUnitStore) {\n              switch (workUnitStore.type) {\n                case 'prerender':\n                case 'prerender-client':\n                case 'prerender-runtime':\n                  if (cacheSignal) {\n                    cacheSignal.endRead()\n                    cacheSignal = null\n                  }\n                  return makeHangingPromise<Response>(\n                    workUnitStore.renderSignal,\n                    workStore.route,\n                    'fetch()'\n                  )\n                case 'prerender-ppr':\n                case 'prerender-legacy':\n                case 'request':\n                case 'cache':\n                case 'private-cache':\n                case 'unstable-cache':\n                  break\n                default:\n                  workUnitStore satisfies never\n              }\n            }\n\n            markCurrentScopeAsDynamic(\n              workStore,\n              workUnitStore,\n              `revalidate: 0 fetch ${input} ${workStore.route}`\n            )\n          }\n\n          // We only want to set the revalidate store's revalidate time if it\n          // was explicitly set for the fetch call, i.e.\n          // originalFetchRevalidate.\n          if (revalidateStore && originalFetchRevalidate === finalRevalidate) {\n            revalidateStore.revalidate = finalRevalidate\n          }\n        }\n\n        const isCacheableRevalidate =\n          typeof finalRevalidate === 'number' && finalRevalidate > 0\n\n        let cacheKey: string | undefined\n        const { incrementalCache } = workStore\n        let isHmrRefresh = false\n        let serverComponentsHmrCache: ServerComponentsHmrCache | undefined\n\n        if (workUnitStore) {\n          switch (workUnitStore.type) {\n            case 'request':\n            case 'cache':\n            case 'private-cache':\n              isHmrRefresh = workUnitStore.isHmrRefresh ?? false\n              serverComponentsHmrCache = workUnitStore.serverComponentsHmrCache\n              break\n            case 'prerender':\n            case 'prerender-client':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'unstable-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n\n        if (\n          incrementalCache &&\n          (isCacheableRevalidate || serverComponentsHmrCache)\n        ) {\n          try {\n            cacheKey = await incrementalCache.generateCacheKey(\n              fetchUrl,\n              isRequestInput ? (input as RequestInit) : init\n            )\n          } catch (err) {\n            console.error(`Failed to generate cache key for`, input)\n          }\n        }\n\n        const fetchIdx = workStore.nextFetchId ?? 1\n        workStore.nextFetchId = fetchIdx + 1\n\n        let handleUnlock: () => Promise<void> | void = () => {}\n\n        const doOriginalFetch = async (\n          isStale?: boolean,\n          cacheReasonOverride?: string\n        ) => {\n          const requestInputFields = [\n            'cache',\n            'credentials',\n            'headers',\n            'integrity',\n            'keepalive',\n            'method',\n            'mode',\n            'redirect',\n            'referrer',\n            'referrerPolicy',\n            'window',\n            'duplex',\n\n            // don't pass through signal when revalidating\n            ...(isStale ? [] : ['signal']),\n          ]\n\n          if (isRequestInput) {\n            const reqInput: Request = input as any\n            const reqOptions: RequestInit = {\n              body: (reqInput as any)._ogBody || reqInput.body,\n            }\n\n            for (const field of requestInputFields) {\n              // @ts-expect-error custom fields\n              reqOptions[field] = reqInput[field]\n            }\n            input = new Request(reqInput.url, reqOptions)\n          } else if (init) {\n            const { _ogBody, body, signal, ...otherInput } =\n              init as RequestInit & { _ogBody?: any }\n            init = {\n              ...otherInput,\n              body: _ogBody || body,\n              signal: isStale ? undefined : signal,\n            }\n          }\n\n          // add metadata to init without editing the original\n          const clonedInit = {\n            ...init,\n            next: { ...init?.next, fetchType: 'origin', fetchIdx },\n          }\n\n          return originFetch(input, clonedInit)\n            .then(async (res) => {\n              if (!isStale && fetchStart) {\n                trackFetchMetric(workStore, {\n                  start: fetchStart,\n                  url: fetchUrl,\n                  cacheReason: cacheReasonOverride || cacheReason,\n                  cacheStatus:\n                    finalRevalidate === 0 || cacheReasonOverride\n                      ? 'skip'\n                      : 'miss',\n                  cacheWarning,\n                  status: res.status,\n                  method: clonedInit.method || 'GET',\n                })\n              }\n              if (\n                res.status === 200 &&\n                incrementalCache &&\n                cacheKey &&\n                (isCacheableRevalidate || serverComponentsHmrCache)\n              ) {\n                const normalizedRevalidate =\n                  finalRevalidate >= INFINITE_CACHE\n                    ? CACHE_ONE_YEAR\n                    : finalRevalidate\n\n                const incrementalCacheConfig:\n                  | SetIncrementalFetchCacheContext\n                  | undefined = isCacheableRevalidate\n                  ? {\n                      fetchCache: true,\n                      fetchUrl,\n                      fetchIdx,\n                      tags,\n                      isImplicitBuildTimeCache,\n                    }\n                  : undefined\n\n                switch (workUnitStore?.type) {\n                  case 'prerender':\n                  case 'prerender-client':\n                  case 'prerender-runtime':\n                    return createCachedPrerenderResponse(\n                      res,\n                      cacheKey,\n                      incrementalCacheConfig,\n                      incrementalCache,\n                      normalizedRevalidate,\n                      handleUnlock\n                    )\n                  case 'prerender-ppr':\n                  case 'prerender-legacy':\n                  case 'request':\n                  case 'cache':\n                  case 'private-cache':\n                  case 'unstable-cache':\n                  case undefined:\n                    return createCachedDynamicResponse(\n                      workStore,\n                      res,\n                      cacheKey,\n                      incrementalCacheConfig,\n                      incrementalCache,\n                      serverComponentsHmrCache,\n                      normalizedRevalidate,\n                      input,\n                      handleUnlock\n                    )\n                  default:\n                    workUnitStore satisfies never\n                }\n              }\n\n              // we had response that we determined shouldn't be cached so we return it\n              // and don't cache it. This also needs to unlock the cache lock we acquired.\n              await handleUnlock()\n\n              return res\n            })\n            .catch((error) => {\n              handleUnlock()\n              throw error\n            })\n        }\n\n        let cacheReasonOverride\n        let isForegroundRevalidate = false\n        let isHmrRefreshCache = false\n\n        if (cacheKey && incrementalCache) {\n          let cachedFetchData: CachedFetchData | undefined\n\n          if (isHmrRefresh && serverComponentsHmrCache) {\n            cachedFetchData = serverComponentsHmrCache.get(cacheKey)\n            isHmrRefreshCache = true\n          }\n\n          if (isCacheableRevalidate && !cachedFetchData) {\n            handleUnlock = await incrementalCache.lock(cacheKey)\n            const entry = workStore.isOnDemandRevalidate\n              ? null\n              : await incrementalCache.get(cacheKey, {\n                  kind: IncrementalCacheKind.FETCH,\n                  revalidate: finalRevalidate,\n                  fetchUrl,\n                  fetchIdx,\n                  tags,\n                  softTags: implicitTags?.tags,\n                })\n\n            if (hasNoExplicitCacheConfig && workUnitStore) {\n              switch (workUnitStore.type) {\n                case 'prerender':\n                case 'prerender-client':\n                case 'prerender-runtime':\n                  // We sometimes use the cache to dedupe fetches that do not\n                  // specify a cache configuration. In these cases we want to\n                  // make sure we still exclude them from prerenders if\n                  // cacheComponents is on so we introduce an artificial task boundary\n                  // here.\n                  await getTimeoutBoundary()\n                  break\n                case 'prerender-ppr':\n                case 'prerender-legacy':\n                case 'request':\n                case 'cache':\n                case 'private-cache':\n                case 'unstable-cache':\n                  break\n                default:\n                  workUnitStore satisfies never\n              }\n            }\n\n            if (entry) {\n              await handleUnlock()\n            } else {\n              // in dev, incremental cache response will be null in case the browser adds `cache-control: no-cache` in the request headers\n              cacheReasonOverride = 'cache-control: no-cache (hard refresh)'\n            }\n\n            if (entry?.value && entry.value.kind === CachedRouteKind.FETCH) {\n              // when stale and is revalidating we wait for fresh data\n              // so the revalidated entry has the updated data\n              if (workStore.isStaticGeneration && entry.isStale) {\n                isForegroundRevalidate = true\n              } else {\n                if (entry.isStale) {\n                  workStore.pendingRevalidates ??= {}\n                  if (!workStore.pendingRevalidates[cacheKey]) {\n                    const pendingRevalidate = doOriginalFetch(true)\n                      .then(async (response) => ({\n                        body: await response.arrayBuffer(),\n                        headers: response.headers,\n                        status: response.status,\n                        statusText: response.statusText,\n                      }))\n                      .finally(() => {\n                        workStore.pendingRevalidates ??= {}\n                        delete workStore.pendingRevalidates[cacheKey || '']\n                      })\n\n                    // Attach the empty catch here so we don't get a \"unhandled\n                    // promise rejection\" warning.\n                    pendingRevalidate.catch(console.error)\n\n                    workStore.pendingRevalidates[cacheKey] = pendingRevalidate\n                  }\n                }\n\n                cachedFetchData = entry.value.data\n              }\n            }\n          }\n\n          if (cachedFetchData) {\n            if (fetchStart) {\n              trackFetchMetric(workStore, {\n                start: fetchStart,\n                url: fetchUrl,\n                cacheReason,\n                cacheStatus: isHmrRefreshCache ? 'hmr' : 'hit',\n                cacheWarning,\n                status: cachedFetchData.status || 200,\n                method: init?.method || 'GET',\n              })\n            }\n\n            const response = new Response(\n              Buffer.from(cachedFetchData.body, 'base64'),\n              {\n                headers: cachedFetchData.headers,\n                status: cachedFetchData.status,\n              }\n            )\n\n            Object.defineProperty(response, 'url', {\n              value: cachedFetchData.url,\n            })\n\n            return response\n          }\n        }\n\n        if (workStore.isStaticGeneration && init && typeof init === 'object') {\n          const { cache } = init\n\n          // Delete `cache` property as Cloudflare Workers will throw an error\n          if (isEdgeRuntime) delete init.cache\n\n          if (cache === 'no-store') {\n            // If enabled, we should bail out of static generation.\n            if (workUnitStore) {\n              switch (workUnitStore.type) {\n                case 'prerender':\n                case 'prerender-client':\n                case 'prerender-runtime':\n                  if (cacheSignal) {\n                    cacheSignal.endRead()\n                    cacheSignal = null\n                  }\n                  return makeHangingPromise<Response>(\n                    workUnitStore.renderSignal,\n                    workStore.route,\n                    'fetch()'\n                  )\n                case 'prerender-ppr':\n                case 'prerender-legacy':\n                case 'request':\n                case 'cache':\n                case 'private-cache':\n                case 'unstable-cache':\n                  break\n                default:\n                  workUnitStore satisfies never\n              }\n            }\n            markCurrentScopeAsDynamic(\n              workStore,\n              workUnitStore,\n              `no-store fetch ${input} ${workStore.route}`\n            )\n          }\n\n          const hasNextConfig = 'next' in init\n          const { next = {} } = init\n          if (\n            typeof next.revalidate === 'number' &&\n            revalidateStore &&\n            next.revalidate < revalidateStore.revalidate\n          ) {\n            if (next.revalidate === 0) {\n              // If enabled, we should bail out of static generation.\n              if (workUnitStore) {\n                switch (workUnitStore.type) {\n                  case 'prerender':\n                  case 'prerender-client':\n                  case 'prerender-runtime':\n                    return makeHangingPromise<Response>(\n                      workUnitStore.renderSignal,\n                      workStore.route,\n                      'fetch()'\n                    )\n                  case 'request':\n                  case 'cache':\n                  case 'private-cache':\n                  case 'unstable-cache':\n                  case 'prerender-legacy':\n                  case 'prerender-ppr':\n                    break\n                  default:\n                    workUnitStore satisfies never\n                }\n              }\n              markCurrentScopeAsDynamic(\n                workStore,\n                workUnitStore,\n                `revalidate: 0 fetch ${input} ${workStore.route}`\n              )\n            }\n\n            if (!workStore.forceStatic || next.revalidate !== 0) {\n              revalidateStore.revalidate = next.revalidate\n            }\n          }\n          if (hasNextConfig) delete init.next\n        }\n\n        // if we are revalidating the whole page via time or on-demand and\n        // the fetch cache entry is stale we should still de-dupe the\n        // origin hit if it's a cache-able entry\n        if (cacheKey && isForegroundRevalidate) {\n          const pendingRevalidateKey = cacheKey\n          workStore.pendingRevalidates ??= {}\n          let pendingRevalidate =\n            workStore.pendingRevalidates[pendingRevalidateKey]\n\n          if (pendingRevalidate) {\n            const revalidatedResult: {\n              body: ArrayBuffer\n              headers: Headers\n              status: number\n              statusText: string\n            } = await pendingRevalidate\n            return new Response(revalidatedResult.body, {\n              headers: revalidatedResult.headers,\n              status: revalidatedResult.status,\n              statusText: revalidatedResult.statusText,\n            })\n          }\n\n          // We used to just resolve the Response and clone it however for\n          // static generation with cacheComponents we need the response to be able to\n          // be resolved in a microtask and cloning the response will never have\n          // a body that can resolve in a microtask in node (as observed through\n          // experimentation) So instead we await the body and then when it is\n          // available we construct manually cloned Response objects with the\n          // body as an ArrayBuffer. This will be resolvable in a microtask\n          // making it compatible with cacheComponents.\n          const pendingResponse = doOriginalFetch(true, cacheReasonOverride)\n            // We're cloning the response using this utility because there\n            // exists a bug in the undici library around response cloning.\n            // See the following pull request for more details:\n            // https://github.com/vercel/next.js/pull/73274\n            .then(cloneResponse)\n\n          pendingRevalidate = pendingResponse\n            .then(async (responses) => {\n              const response = responses[0]\n              return {\n                body: await response.arrayBuffer(),\n                headers: response.headers,\n                status: response.status,\n                statusText: response.statusText,\n              }\n            })\n            .finally(() => {\n              // If the pending revalidate is not present in the store, then\n              // we have nothing to delete.\n              if (!workStore.pendingRevalidates?.[pendingRevalidateKey]) {\n                return\n              }\n\n              delete workStore.pendingRevalidates[pendingRevalidateKey]\n            })\n\n          // Attach the empty catch here so we don't get a \"unhandled promise\n          // rejection\" warning\n          pendingRevalidate.catch(() => {})\n\n          workStore.pendingRevalidates[pendingRevalidateKey] = pendingRevalidate\n\n          return pendingResponse.then((responses) => responses[1])\n        } else {\n          return doOriginalFetch(false, cacheReasonOverride)\n        }\n      }\n    )\n\n    if (cacheSignal) {\n      try {\n        return await result\n      } finally {\n        if (cacheSignal) {\n          cacheSignal.endRead()\n        }\n      }\n    }\n    return result\n  }\n\n  // Attach the necessary properties to the patched fetch function.\n  // We don't use this to determine if the fetch function has been patched,\n  // but for external consumers to determine if the fetch function has been\n  // patched.\n  patched.__nextPatched = true as const\n  patched.__nextGetStaticStore = () => workAsyncStorage\n  patched._nextOriginalFetch = originFetch\n  ;(globalThis as Record<symbol, unknown>)[NEXT_PATCH_SYMBOL] = true\n\n  // Assign the function name also as a name property, so that it's preserved\n  // even when mangling is enabled.\n  Object.defineProperty(patched, 'name', { value: 'fetch', writable: false })\n\n  return patched\n}\n\n// we patch fetch to collect cache information used for\n// determining if a page is static or not\nexport function patchFetch(options: PatchableModule) {\n  // If we've already patched fetch, we should not patch it again.\n  if (isFetchPatched()) return\n\n  // Grab the original fetch function. We'll attach this so we can use it in\n  // the patched fetch function.\n  const original = createDedupeFetch(globalThis.fetch)\n\n  // Set the global fetch to the patched fetch.\n  globalThis.fetch = createPatchedFetcher(original, options)\n}\n\nlet currentTimeoutBoundary: null | Promise<void> = null\nfunction getTimeoutBoundary() {\n  if (!currentTimeoutBoundary) {\n    currentTimeoutBoundary = new Promise((r) => {\n      setTimeout(() => {\n        currentTimeoutBoundary = null\n        r()\n      }, 0)\n    })\n  }\n  return currentTimeoutBoundary\n}\n","import type { IncrementalCache } from '../../lib/incremental-cache'\n\nimport { CACHE_ONE_YEAR } from '../../../lib/constants'\nimport { validateRevalidate, validateTags } from '../../lib/patch-fetch'\nimport {\n  workAsyncStorage,\n  type WorkStore,\n} from '../../app-render/work-async-storage.external'\nimport {\n  getCacheSignal,\n  getDraftModeProviderForCacheScope,\n  workUnitAsyncStorage,\n} from '../../app-render/work-unit-async-storage.external'\nimport {\n  CachedRouteKind,\n  IncrementalCacheKind,\n  type CachedFetchData,\n} from '../../response-cache'\nimport type {\n  UnstableCacheStore,\n  WorkUnitStore,\n} from '../../app-render/work-unit-async-storage.external'\n\ntype Callback = (...args: any[]) => Promise<any>\n\nlet noStoreFetchIdx = 0\n\nasync function cacheNewResult<T>(\n  result: T,\n  incrementalCache: IncrementalCache,\n  cacheKey: string,\n  tags: string[],\n  revalidate: number | false | undefined,\n  fetchIdx: number,\n  fetchUrl: string\n): Promise<unknown> {\n  await incrementalCache.set(\n    cacheKey,\n    {\n      kind: CachedRouteKind.FETCH,\n      data: {\n        headers: {},\n        // TODO: handle non-JSON values?\n        body: JSON.stringify(result),\n        status: 200,\n        url: '',\n      } satisfies CachedFetchData,\n      revalidate: typeof revalidate !== 'number' ? CACHE_ONE_YEAR : revalidate,\n    },\n    { fetchCache: true, tags, fetchIdx, fetchUrl }\n  )\n  return\n}\n\n/**\n * This function allows you to cache the results of expensive operations, like database queries, and reuse them across multiple requests.\n *\n * Read more: [Next.js Docs: `unstable_cache`](https://nextjs.org/docs/app/api-reference/functions/unstable_cache)\n */\nexport function unstable_cache<T extends Callback>(\n  cb: T,\n  keyParts?: string[],\n  options: {\n    /**\n     * The revalidation interval in seconds.\n     */\n    revalidate?: number | false\n    tags?: string[]\n  } = {}\n): T {\n  if (options.revalidate === 0) {\n    throw new Error(\n      `Invariant revalidate: 0 can not be passed to unstable_cache(), must be \"false\" or \"> 0\" ${cb.toString()}`\n    )\n  }\n\n  // Validate the tags provided are valid\n  const tags = options.tags\n    ? validateTags(options.tags, `unstable_cache ${cb.toString()}`)\n    : []\n\n  // Validate the revalidate options\n  validateRevalidate(\n    options.revalidate,\n    `unstable_cache ${cb.name || cb.toString()}`\n  )\n\n  // Stash the fixed part of the key at construction time. The invocation key will combine\n  // the fixed key with the arguments when actually called\n  // @TODO if cb.toString() is long we should hash it\n  // @TODO come up with a collision-free way to combine keyParts\n  // @TODO consider validating the keyParts are all strings. TS can't provide runtime guarantees\n  // and the error produced by accidentally using something that cannot be safely coerced is likely\n  // hard to debug\n  const fixedKey = `${cb.toString()}-${\n    Array.isArray(keyParts) && keyParts.join(',')\n  }`\n\n  const cachedCb = async (...args: any[]) => {\n    const workStore = workAsyncStorage.getStore()\n    const workUnitStore = workUnitAsyncStorage.getStore()\n\n    // We must be able to find the incremental cache otherwise we throw\n    const maybeIncrementalCache:\n      | import('../../lib/incremental-cache').IncrementalCache\n      | undefined =\n      workStore?.incrementalCache || (globalThis as any).__incrementalCache\n\n    if (!maybeIncrementalCache) {\n      throw new Error(\n        `Invariant: incrementalCache missing in unstable_cache ${cb.toString()}`\n      )\n    }\n    const incrementalCache = maybeIncrementalCache\n\n    const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n    if (cacheSignal) {\n      cacheSignal.beginRead()\n    }\n    try {\n      // If there's no request store, we aren't in a request (or we're not in\n      // app router) and if there's no static generation store, we aren't in app\n      // router. Default to an empty pathname and search params when there's no\n      // request store or static generation store available.\n      const fetchUrlPrefix =\n        workStore && workUnitStore\n          ? getFetchUrlPrefix(workStore, workUnitStore)\n          : ''\n\n      // Construct the complete cache key for this function invocation\n      // @TODO stringify is likely not safe here. We will coerce undefined to null which will make\n      // the keyspace smaller than the execution space\n      const invocationKey = `${fixedKey}-${JSON.stringify(args)}`\n      const cacheKey = await incrementalCache.generateCacheKey(invocationKey)\n      // $urlWithPath,$sortedQueryStringKeys,$hashOfEveryThingElse\n      const fetchUrl = `unstable_cache ${fetchUrlPrefix} ${cb.name ? ` ${cb.name}` : cacheKey}`\n      const fetchIdx =\n        (workStore ? workStore.nextFetchId : noStoreFetchIdx) ?? 1\n\n      const implicitTags = workUnitStore?.implicitTags\n\n      const innerCacheStore: UnstableCacheStore = {\n        type: 'unstable-cache',\n        phase: 'render',\n        implicitTags,\n        draftMode:\n          workUnitStore &&\n          workStore &&\n          getDraftModeProviderForCacheScope(workStore, workUnitStore),\n      }\n\n      if (workStore) {\n        workStore.nextFetchId = fetchIdx + 1\n\n        // We are in an App Router context. We try to return the cached entry if it exists and is valid\n        // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n        // the background. If the entry is missing or invalid we generate a new entry and return it.\n\n        let isNestedUnstableCache = false\n\n        if (workUnitStore) {\n          switch (workUnitStore.type) {\n            case 'cache':\n            case 'private-cache':\n            case 'prerender':\n            case 'prerender-runtime':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n              // We update the store's revalidate property if the option.revalidate is a higher precedence\n              // options.revalidate === undefined doesn't affect timing.\n              // options.revalidate === false doesn't shrink timing. it stays at the maximum.\n              if (typeof options.revalidate === 'number') {\n                if (workUnitStore.revalidate < options.revalidate) {\n                  // The store is already revalidating on a shorter time interval, leave it alone\n                } else {\n                  workUnitStore.revalidate = options.revalidate\n                }\n              }\n\n              // We need to accumulate the tags for this invocation within the store\n              const collectedTags = workUnitStore.tags\n              if (collectedTags === null) {\n                workUnitStore.tags = tags.slice()\n              } else {\n                for (const tag of tags) {\n                  // @TODO refactor tags to be a set to avoid this O(n) lookup\n                  if (!collectedTags.includes(tag)) {\n                    collectedTags.push(tag)\n                  }\n                }\n              }\n              break\n            case 'unstable-cache':\n              isNestedUnstableCache = true\n              break\n            case 'prerender-client':\n            case 'request':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n\n        if (\n          // when we are nested inside of other unstable_cache's\n          // we should bypass cache similar to fetches\n          !isNestedUnstableCache &&\n          workStore.fetchCache !== 'force-no-store' &&\n          !workStore.isOnDemandRevalidate &&\n          !incrementalCache.isOnDemandRevalidate &&\n          !workStore.isDraftMode\n        ) {\n          // We attempt to get the current cache entry from the incremental cache.\n          const cacheEntry = await incrementalCache.get(cacheKey, {\n            kind: IncrementalCacheKind.FETCH,\n            revalidate: options.revalidate,\n            tags,\n            softTags: implicitTags?.tags,\n            fetchIdx,\n            fetchUrl,\n          })\n\n          if (cacheEntry && cacheEntry.value) {\n            // The entry exists and has a value\n            if (cacheEntry.value.kind !== CachedRouteKind.FETCH) {\n              // The entry is invalid and we need a special warning\n              // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n              // so bugs can be reported\n              // @TODO the invocation key can have sensitive data in it. we should not log this entire object\n              console.error(\n                `Invariant invalid cacheEntry returned for ${invocationKey}`\n              )\n              // will fall through to generating a new cache entry below\n            } else {\n              // We have a valid cache entry so we will be returning it. We also check to see if we need\n              // to background revalidate it by checking if it is stale.\n              const cachedResponse =\n                cacheEntry.value.data.body !== undefined\n                  ? JSON.parse(cacheEntry.value.data.body)\n                  : undefined\n\n              if (cacheEntry.isStale) {\n                if (!workStore.pendingRevalidates) {\n                  workStore.pendingRevalidates = {}\n                }\n\n                // Check if there's already a pending revalidation to avoid duplicate work\n                if (!workStore.pendingRevalidates[invocationKey]) {\n                  // Create the revalidation promise\n                  const revalidationPromise = workUnitAsyncStorage\n                    .run(innerCacheStore, cb, ...args)\n                    .then(async (result) => {\n                      await cacheNewResult(\n                        result,\n                        incrementalCache,\n                        cacheKey,\n                        tags,\n                        options.revalidate,\n                        fetchIdx,\n                        fetchUrl\n                      )\n                      return result\n                    })\n                    .catch((err) => {\n                      // @TODO This error handling seems wrong. We swallow the error?\n                      console.error(\n                        `revalidating cache with key: ${invocationKey}`,\n                        err\n                      )\n                      // Return the stale value on error for foreground revalidation\n                      return cachedResponse\n                    })\n\n                  // Attach the empty catch here so we don't get a \"unhandled promise\n                  // rejection\" warning. (Behavior is matched with patch-fetch)\n                  if (workStore.isStaticGeneration) {\n                    revalidationPromise.catch(() => {})\n                  }\n\n                  workStore.pendingRevalidates[invocationKey] =\n                    revalidationPromise\n                }\n\n                // Check if we need to do foreground revalidation\n                if (workStore.isStaticGeneration) {\n                  // When the page is revalidating and the cache entry is stale,\n                  // we need to wait for fresh data (blocking revalidate)\n                  return workStore.pendingRevalidates[invocationKey]\n                }\n                // Otherwise, we're doing background revalidation - return stale immediately\n              }\n\n              // We had a valid cache entry so we return it here\n              return cachedResponse\n            }\n          }\n        }\n\n        // If we got this far then we had an invalid cache entry and need to generate a new one\n        const result = await workUnitAsyncStorage.run(\n          innerCacheStore,\n          cb,\n          ...args\n        )\n\n        if (!workStore.isDraftMode) {\n          if (!workStore.pendingRevalidates) {\n            workStore.pendingRevalidates = {}\n          }\n\n          // We need to push the cache result promise to pending\n          // revalidates otherwise it won't be awaited and is just\n          // dangling\n          workStore.pendingRevalidates[invocationKey] = cacheNewResult(\n            result,\n            incrementalCache,\n            cacheKey,\n            tags,\n            options.revalidate,\n            fetchIdx,\n            fetchUrl\n          )\n        }\n\n        return result\n      } else {\n        noStoreFetchIdx += 1\n        // We are in Pages Router or were called outside of a render. We don't have a store\n        // so we just call the callback directly when it needs to run.\n        // If the entry is fresh we return it. If the entry is stale we return it but revalidate the entry in\n        // the background. If the entry is missing or invalid we generate a new entry and return it.\n\n        if (!incrementalCache.isOnDemandRevalidate) {\n          // We aren't doing an on demand revalidation so we check use the cache if valid\n          const cacheEntry = await incrementalCache.get(cacheKey, {\n            kind: IncrementalCacheKind.FETCH,\n            revalidate: options.revalidate,\n            tags,\n            fetchIdx,\n            fetchUrl,\n            softTags: implicitTags?.tags,\n          })\n\n          if (cacheEntry && cacheEntry.value) {\n            // The entry exists and has a value\n            if (cacheEntry.value.kind !== CachedRouteKind.FETCH) {\n              // The entry is invalid and we need a special warning\n              // @TODO why do we warn this way? Should this just be an error? How are these errors surfaced\n              // so bugs can be reported\n              console.error(\n                `Invariant invalid cacheEntry returned for ${invocationKey}`\n              )\n              // will fall through to generating a new cache entry below\n            } else if (!cacheEntry.isStale) {\n              // We have a valid cache entry and it is fresh so we return it\n              return cacheEntry.value.data.body !== undefined\n                ? JSON.parse(cacheEntry.value.data.body)\n                : undefined\n            }\n          }\n        }\n\n        // If we got this far then we had an invalid cache entry and need to generate a new one\n        const result = await workUnitAsyncStorage.run(\n          innerCacheStore,\n          cb,\n          ...args\n        )\n\n        // we need to wait setting the new cache result here as\n        // we don't have pending revalidates on workStore to\n        // push to and we can't have a dangling promise\n        await cacheNewResult(\n          result,\n          incrementalCache,\n          cacheKey,\n          tags,\n          options.revalidate,\n          fetchIdx,\n          fetchUrl\n        )\n        return result\n      }\n    } finally {\n      if (cacheSignal) {\n        cacheSignal.endRead()\n      }\n    }\n  }\n  // TODO: once AsyncLocalStorage.run() returns the correct types this override will no longer be necessary\n  return cachedCb as unknown as T\n}\n\nfunction getFetchUrlPrefix(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore\n): string {\n  switch (workUnitStore.type) {\n    case 'request':\n      const pathname = workUnitStore.url.pathname\n      const searchParams = new URLSearchParams(workUnitStore.url.search)\n\n      const sortedSearch = [...searchParams.keys()]\n        .sort((a, b) => a.localeCompare(b))\n        .map((key) => `${key}=${searchParams.get(key)}`)\n        .join('&')\n\n      return `${pathname}${sortedSearch.length ? '?' : ''}${sortedSearch}`\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-runtime':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n      return workStore.route\n    default:\n      return workUnitStore satisfies never\n  }\n}\n","class UrlNode {\n  placeholder: boolean = true\n  children: Map<string, UrlNode> = new Map()\n  slugName: string | null = null\n  restSlugName: string | null = null\n  optionalRestSlugName: string | null = null\n\n  insert(urlPath: string): void {\n    this._insert(urlPath.split('/').filter(Boolean), [], false)\n  }\n\n  smoosh(): string[] {\n    return this._smoosh()\n  }\n\n  private _smoosh(prefix: string = '/'): string[] {\n    const childrenPaths = [...this.children.keys()].sort()\n    if (this.slugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[]'), 1)\n    }\n    if (this.restSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[...]'), 1)\n    }\n    if (this.optionalRestSlugName !== null) {\n      childrenPaths.splice(childrenPaths.indexOf('[[...]]'), 1)\n    }\n\n    const routes = childrenPaths\n      .map((c) => this.children.get(c)!._smoosh(`${prefix}${c}/`))\n      .reduce((prev, curr) => [...prev, ...curr], [])\n\n    if (this.slugName !== null) {\n      routes.push(\n        ...this.children.get('[]')!._smoosh(`${prefix}[${this.slugName}]/`)\n      )\n    }\n\n    if (!this.placeholder) {\n      const r = prefix === '/' ? '/' : prefix.slice(0, -1)\n      if (this.optionalRestSlugName != null) {\n        throw new Error(\n          `You cannot define a route with the same specificity as a optional catch-all route (\"${r}\" and \"${r}[[...${this.optionalRestSlugName}]]\").`\n        )\n      }\n\n      routes.unshift(r)\n    }\n\n    if (this.restSlugName !== null) {\n      routes.push(\n        ...this.children\n          .get('[...]')!\n          ._smoosh(`${prefix}[...${this.restSlugName}]/`)\n      )\n    }\n\n    if (this.optionalRestSlugName !== null) {\n      routes.push(\n        ...this.children\n          .get('[[...]]')!\n          ._smoosh(`${prefix}[[...${this.optionalRestSlugName}]]/`)\n      )\n    }\n\n    return routes\n  }\n\n  private _insert(\n    urlPaths: string[],\n    slugNames: string[],\n    isCatchAll: boolean\n  ): void {\n    if (urlPaths.length === 0) {\n      this.placeholder = false\n      return\n    }\n\n    if (isCatchAll) {\n      throw new Error(`Catch-all must be the last part of the URL.`)\n    }\n\n    // The next segment in the urlPaths list\n    let nextSegment = urlPaths[0]\n\n    // Check if the segment matches `[something]`\n    if (nextSegment.startsWith('[') && nextSegment.endsWith(']')) {\n      // Strip `[` and `]`, leaving only `something`\n      let segmentName = nextSegment.slice(1, -1)\n\n      let isOptional = false\n      if (segmentName.startsWith('[') && segmentName.endsWith(']')) {\n        // Strip optional `[` and `]`, leaving only `something`\n        segmentName = segmentName.slice(1, -1)\n        isOptional = true\n      }\n\n      if (segmentName.startsWith('')) {\n        throw new Error(\n          `Detected a three-dot character ('') at ('${segmentName}'). Did you mean ('...')?`\n        )\n      }\n\n      if (segmentName.startsWith('...')) {\n        // Strip `...`, leaving only `something`\n        segmentName = segmentName.substring(3)\n        isCatchAll = true\n      }\n\n      if (segmentName.startsWith('[') || segmentName.endsWith(']')) {\n        throw new Error(\n          `Segment names may not start or end with extra brackets ('${segmentName}').`\n        )\n      }\n\n      if (segmentName.startsWith('.')) {\n        throw new Error(\n          `Segment names may not start with erroneous periods ('${segmentName}').`\n        )\n      }\n\n      function handleSlug(previousSlug: string | null, nextSlug: string) {\n        if (previousSlug !== null) {\n          // If the specific segment already has a slug but the slug is not `something`\n          // This prevents collisions like:\n          // pages/[post]/index.js\n          // pages/[id]/index.js\n          // Because currently multiple dynamic params on the same segment level are not supported\n          if (previousSlug !== nextSlug) {\n            // TODO: This error seems to be confusing for users, needs an error link, the description can be based on above comment.\n            throw new Error(\n              `You cannot use different slug names for the same dynamic path ('${previousSlug}' !== '${nextSlug}').`\n            )\n          }\n        }\n\n        slugNames.forEach((slug) => {\n          if (slug === nextSlug) {\n            throw new Error(\n              `You cannot have the same slug name \"${nextSlug}\" repeat within a single dynamic path`\n            )\n          }\n\n          if (slug.replace(/\\W/g, '') === nextSegment.replace(/\\W/g, '')) {\n            throw new Error(\n              `You cannot have the slug names \"${slug}\" and \"${nextSlug}\" differ only by non-word symbols within a single dynamic path`\n            )\n          }\n        })\n\n        slugNames.push(nextSlug)\n      }\n\n      if (isCatchAll) {\n        if (isOptional) {\n          if (this.restSlugName != null) {\n            throw new Error(\n              `You cannot use both an required and optional catch-all route at the same level (\"[...${this.restSlugName}]\" and \"${urlPaths[0]}\" ).`\n            )\n          }\n\n          handleSlug(this.optionalRestSlugName, segmentName)\n          // slugName is kept as it can only be one particular slugName\n          this.optionalRestSlugName = segmentName\n          // nextSegment is overwritten to [[...]] so that it can later be sorted specifically\n          nextSegment = '[[...]]'\n        } else {\n          if (this.optionalRestSlugName != null) {\n            throw new Error(\n              `You cannot use both an optional and required catch-all route at the same level (\"[[...${this.optionalRestSlugName}]]\" and \"${urlPaths[0]}\").`\n            )\n          }\n\n          handleSlug(this.restSlugName, segmentName)\n          // slugName is kept as it can only be one particular slugName\n          this.restSlugName = segmentName\n          // nextSegment is overwritten to [...] so that it can later be sorted specifically\n          nextSegment = '[...]'\n        }\n      } else {\n        if (isOptional) {\n          throw new Error(\n            `Optional route parameters are not yet supported (\"${urlPaths[0]}\").`\n          )\n        }\n        handleSlug(this.slugName, segmentName)\n        // slugName is kept as it can only be one particular slugName\n        this.slugName = segmentName\n        // nextSegment is overwritten to [] so that it can later be sorted specifically\n        nextSegment = '[]'\n      }\n    }\n\n    // If this UrlNode doesn't have the nextSegment yet we create a new child UrlNode\n    if (!this.children.has(nextSegment)) {\n      this.children.set(nextSegment, new UrlNode())\n    }\n\n    this.children\n      .get(nextSegment)!\n      ._insert(urlPaths.slice(1), slugNames, isCatchAll)\n  }\n}\n\n/**\n * @deprecated Use `sortSortableRoutes` or `sortPages` instead.\n */\nexport function getSortedRoutes(\n  normalizedPages: ReadonlyArray<string>\n): string[] {\n  // First the UrlNode is created, and every UrlNode can have only 1 dynamic segment\n  // Eg you can't have pages/[post]/abc.js and pages/[hello]/something-else.js\n  // Only 1 dynamic segment per nesting level\n\n  // So in the case that is test/integration/dynamic-routing it'll be this:\n  // pages/[post]/comments.js\n  // pages/blog/[post]/comment/[id].js\n  // Both are fine because `pages/[post]` and `pages/blog` are on the same level\n  // So in this case `UrlNode` created here has `this.slugName === 'post'`\n  // And since your PR passed through `slugName` as an array basically it'd including it in too many possibilities\n  // Instead what has to be passed through is the upwards path's dynamic names\n  const root = new UrlNode()\n\n  // Here the `root` gets injected multiple paths, and insert will break them up into sublevels\n  normalizedPages.forEach((pagePath) => root.insert(pagePath))\n  // Smoosh will then sort those sublevels up to the point where you get the correct route definition priority\n  return root.smoosh()\n}\n\n/**\n * @deprecated Use `sortSortableRouteObjects` or `sortPageObjects` instead.\n */\nexport function getSortedRouteObjects<T>(\n  objects: T[],\n  getter: (obj: T) => string\n): T[] {\n  // We're assuming here that all the pathnames are unique, that way we can\n  // sort the list and use the index as the key.\n  const indexes: Record<string, number> = {}\n  const pathnames: string[] = []\n  for (let i = 0; i < objects.length; i++) {\n    const pathname = getter(objects[i])\n    indexes[pathname] = i\n    pathnames[i] = pathname\n  }\n\n  // Sort the pathnames.\n  const sorted = getSortedRoutes(pathnames)\n\n  // Map the sorted pathnames back to the original objects using the new sorted\n  // index.\n  return sorted.map((pathname) => objects[indexes[pathname]])\n}\n","import { normalizeAppPath } from './app-paths'\n\n// order matters here, the first match will be used\nexport const INTERCEPTION_ROUTE_MARKERS = [\n  '(..)(..)',\n  '(.)',\n  '(..)',\n  '(...)',\n] as const\n\nexport function isInterceptionRouteAppPath(path: string): boolean {\n  // TODO-APP: add more serious validation\n  return (\n    path\n      .split('/')\n      .find((segment) =>\n        INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n      ) !== undefined\n  )\n}\n\nexport function extractInterceptionRouteInformation(path: string) {\n  let interceptingRoute: string | undefined,\n    marker: (typeof INTERCEPTION_ROUTE_MARKERS)[number] | undefined,\n    interceptedRoute: string | undefined\n\n  for (const segment of path.split('/')) {\n    marker = INTERCEPTION_ROUTE_MARKERS.find((m) => segment.startsWith(m))\n    if (marker) {\n      ;[interceptingRoute, interceptedRoute] = path.split(marker, 2)\n      break\n    }\n  }\n\n  if (!interceptingRoute || !marker || !interceptedRoute) {\n    throw new Error(\n      `Invalid interception route: ${path}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`\n    )\n  }\n\n  interceptingRoute = normalizeAppPath(interceptingRoute) // normalize the path, e.g. /(blog)/feed -> /feed\n\n  switch (marker) {\n    case '(.)':\n      // (.) indicates that we should match with sibling routes, so we just need to append the intercepted route to the intercepting route\n      if (interceptingRoute === '/') {\n        interceptedRoute = `/${interceptedRoute}`\n      } else {\n        interceptedRoute = interceptingRoute + '/' + interceptedRoute\n      }\n      break\n    case '(..)':\n      // (..) indicates that we should match at one level up, so we need to remove the last segment of the intercepting route\n      if (interceptingRoute === '/') {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..) marker at the root level, use (.) instead.`\n        )\n      }\n      interceptedRoute = interceptingRoute\n        .split('/')\n        .slice(0, -1)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    case '(...)':\n      // (...) will match the route segment in the root directory, so we need to use the root directory to prepend the intercepted route\n      interceptedRoute = '/' + interceptedRoute\n      break\n    case '(..)(..)':\n      // (..)(..) indicates that we should match at two levels up, so we need to remove the last two segments of the intercepting route\n\n      const splitInterceptingRoute = interceptingRoute.split('/')\n      if (splitInterceptingRoute.length <= 2) {\n        throw new Error(\n          `Invalid interception route: ${path}. Cannot use (..)(..) marker at the root level or one level up.`\n        )\n      }\n\n      interceptedRoute = splitInterceptingRoute\n        .slice(0, -2)\n        .concat(interceptedRoute)\n        .join('/')\n      break\n    default:\n      throw new Error('Invariant: unexpected marker')\n  }\n\n  return { interceptingRoute, interceptedRoute }\n}\n","import {\n  extractInterceptionRouteInformation,\n  isInterceptionRouteAppPath,\n} from './interception-routes'\n\n// Identify /.*[param].*/ in route string\nconst TEST_ROUTE = /\\/[^/]*\\[[^/]+\\][^/]*(?=\\/|$)/\n\n// Identify /[param]/ in route string\nconst TEST_STRICT_ROUTE = /\\/\\[[^/]+\\](?=\\/|$)/\n\n/**\n * Check if a route is dynamic.\n *\n * @param route - The route to check.\n * @param strict - Whether to use strict mode which prohibits segments with prefixes/suffixes (default: true).\n * @returns Whether the route is dynamic.\n */\nexport function isDynamicRoute(route: string, strict: boolean = true): boolean {\n  if (isInterceptionRouteAppPath(route)) {\n    route = extractInterceptionRouteInformation(route).interceptedRoute\n  }\n\n  if (strict) {\n    return TEST_STRICT_ROUTE.test(route)\n  }\n\n  return TEST_ROUTE.test(route)\n}\n","export { getSortedRoutes, getSortedRouteObjects } from './sorted-routes'\nexport { isDynamicRoute } from './is-dynamic'\n","import {\n  abortAndThrowOnSynchronousRequestDataAccess,\n  postponeWithTracking,\n} from '../../app-render/dynamic-rendering'\nimport { isDynamicRoute } from '../../../shared/lib/router/utils'\nimport {\n  NEXT_CACHE_IMPLICIT_TAG_ID,\n  NEXT_CACHE_SOFT_TAG_MAX_LENGTH,\n} from '../../../lib/constants'\nimport { workAsyncStorage } from '../../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../../app-render/work-unit-async-storage.external'\nimport { DynamicServerError } from '../../../client/components/hooks-server-context'\nimport { InvariantError } from '../../../shared/lib/invariant-error'\n\ntype CacheLifeConfig = {\n  expire?: number\n}\n\n/**\n * This function allows you to purge [cached data](https://nextjs.org/docs/app/building-your-application/caching) on-demand for a specific cache tag.\n *\n * Read more: [Next.js Docs: `revalidateTag`](https://nextjs.org/docs/app/api-reference/functions/revalidateTag)\n */\nexport function revalidateTag(tag: string, profile: string | CacheLifeConfig) {\n  if (!profile) {\n    console.warn(\n      '\"revalidateTag\" without the second argument is now deprecated, add second argument of \"max\" or use \"updateTag\". See more info here: https://nextjs.org/docs/messages/revalidate-tag-single-arg'\n    )\n  }\n  return revalidate([tag], `revalidateTag ${tag}`, profile)\n}\n\n/**\n * This function allows you to update [cached data](https://nextjs.org/docs/app/building-your-application/caching) on-demand for a specific cache tag.\n * This can only be called from within a Server Action to enable read-your-own-writes semantics.\n *\n * Read more: [Next.js Docs: `updateTag`](https://nextjs.org/docs/app/api-reference/functions/updateTag)\n */\nexport function updateTag(tag: string) {\n  const workStore = workAsyncStorage.getStore()\n\n  // TODO: change this after investigating why phase: 'action' is\n  // set for route handlers\n  if (!workStore || workStore.page.endsWith('/route')) {\n    throw new Error(\n      'updateTag can only be called from within a Server Action. ' +\n        'To invalidate cache tags in Route Handlers or other contexts, use revalidateTag instead. ' +\n        'See more info here: https://nextjs.org/docs/app/api-reference/functions/updateTag'\n    )\n  }\n  // updateTag uses immediate expiration (no profile) without deprecation warning\n  return revalidate([tag], `updateTag ${tag}`, undefined)\n}\n\n/**\n * This function allows you to refresh client cache from server actions.\n * It's useful as dynamic data can be cached on the client which won't\n * be refreshed by expireTag\n */\nexport function refresh() {\n  const workStore = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  if (\n    !workStore ||\n    workStore.page.endsWith('/route') ||\n    workUnitStore?.phase !== 'action'\n  ) {\n    throw new Error(\n      'refresh can only be called from within a Server Action. ' +\n        'See more info here: https://nextjs.org/docs/app/api-reference/functions/refresh'\n    )\n  }\n\n  if (workStore) {\n    // TODO: break this to it's own field\n    workStore.pathWasRevalidated = true\n  }\n}\n\n/**\n * This function allows you to purge [cached data](https://nextjs.org/docs/app/building-your-application/caching) on-demand for a specific path.\n *\n * Read more: [Next.js Docs: `revalidatePath`](https://nextjs.org/docs/app/api-reference/functions/revalidatePath)\n */\nexport function revalidatePath(originalPath: string, type?: 'layout' | 'page') {\n  if (originalPath.length > NEXT_CACHE_SOFT_TAG_MAX_LENGTH) {\n    console.warn(\n      `Warning: revalidatePath received \"${originalPath}\" which exceeded max length of ${NEXT_CACHE_SOFT_TAG_MAX_LENGTH}. See more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`\n    )\n    return\n  }\n\n  let normalizedPath = `${NEXT_CACHE_IMPLICIT_TAG_ID}${originalPath || '/'}`\n\n  if (type) {\n    normalizedPath += `${normalizedPath.endsWith('/') ? '' : '/'}${type}`\n  } else if (isDynamicRoute(originalPath)) {\n    console.warn(\n      `Warning: a dynamic page path \"${originalPath}\" was passed to \"revalidatePath\", but the \"type\" parameter is missing. This has no effect by default, see more info here https://nextjs.org/docs/app/api-reference/functions/revalidatePath`\n    )\n  }\n\n  const tags = [normalizedPath]\n  if (normalizedPath === `${NEXT_CACHE_IMPLICIT_TAG_ID}/`) {\n    tags.push(`${NEXT_CACHE_IMPLICIT_TAG_ID}/index`)\n  } else if (normalizedPath === `${NEXT_CACHE_IMPLICIT_TAG_ID}/index`) {\n    tags.push(`${NEXT_CACHE_IMPLICIT_TAG_ID}/`)\n  }\n\n  return revalidate(tags, `revalidatePath ${originalPath}`)\n}\n\nfunction revalidate(\n  tags: string[],\n  expression: string,\n  profile?: string | CacheLifeConfig\n) {\n  const store = workAsyncStorage.getStore()\n  if (!store || !store.incrementalCache) {\n    throw new Error(\n      `Invariant: static generation store missing in ${expression}`\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    if (workUnitStore.phase === 'render') {\n      throw new Error(\n        `Route ${store.route} used \"${expression}\" during render which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n      )\n    }\n\n    switch (workUnitStore.type) {\n      case 'cache':\n      case 'private-cache':\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside a \"use cache\" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n        )\n      case 'unstable-cache':\n        throw new Error(\n          `Route ${store.route} used \"${expression}\" inside a function cached with \"unstable_cache(...)\" which is unsupported. To ensure revalidation is performed consistently it must always happen outside of renders and cached functions. See more info here: https://nextjs.org/docs/app/building-your-application/rendering/static-and-dynamic#dynamic-rendering`\n        )\n      case 'prerender':\n      case 'prerender-runtime':\n        // cacheComponents Prerender\n        const error = new Error(\n          `Route ${store.route} used ${expression} without first calling \\`await connection()\\`.`\n        )\n        return abortAndThrowOnSynchronousRequestDataAccess(\n          store.route,\n          expression,\n          error,\n          workUnitStore\n        )\n      case 'prerender-client':\n        throw new InvariantError(\n          `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being included in client components statically, but did not in this case.`\n        )\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          store.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        workUnitStore.revalidate = 0\n\n        const err = new DynamicServerError(\n          `Route ${store.route} couldn't be rendered statically because it used \\`${expression}\\`. See more info here: https://nextjs.org/docs/messages/dynamic-server-error`\n        )\n        store.dynamicUsageDescription = expression\n        store.dynamicUsageStack = err.stack\n\n        throw err\n      case 'request':\n        if (process.env.NODE_ENV !== 'production') {\n          // TODO: This is most likely incorrect. It would lead to the ISR\n          // status being flipped when revalidating a static page with a server\n          // action.\n          workUnitStore.usedDynamic = true\n        }\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  if (!store.pendingRevalidatedTags) {\n    store.pendingRevalidatedTags = []\n  }\n\n  for (const tag of tags) {\n    const existingIndex = store.pendingRevalidatedTags.findIndex((item) => {\n      if (item.tag !== tag) return false\n      // Compare profiles: both strings, both objects, or both undefined\n      if (typeof item.profile === 'string' && typeof profile === 'string') {\n        return item.profile === profile\n      }\n      if (typeof item.profile === 'object' && typeof profile === 'object') {\n        return JSON.stringify(item.profile) === JSON.stringify(profile)\n      }\n      return item.profile === profile\n    })\n    if (existingIndex === -1) {\n      store.pendingRevalidatedTags.push({\n        tag,\n        profile,\n      })\n    }\n  }\n\n  // if profile is provided and this is a stale-while-revalidate\n  // update we do not mark the path as revalidated so that server\n  // actions don't pull their own writes\n  const cacheLife =\n    profile && typeof profile === 'object'\n      ? profile\n      : profile &&\n          typeof profile === 'string' &&\n          store?.cacheLifeProfiles?.[profile]\n        ? store.cacheLifeProfiles[profile]\n        : undefined\n\n  if (!profile || cacheLife?.expire === 0) {\n    // TODO: only revalidate if the path matches\n    store.pathWasRevalidated = true\n  }\n}\n","import { workAsyncStorage } from '../../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../../app-render/work-unit-async-storage.external'\nimport { markCurrentScopeAsDynamic } from '../../app-render/dynamic-rendering'\n\n/**\n * This function can be used to declaratively opt out of static rendering and indicate a particular component should not be cached.\n *\n * It marks the current scope as dynamic.\n *\n * - In [non-PPR](https://nextjs.org/docs/app/api-reference/next-config-js/partial-prerendering) cases this will make a static render\n * halt and mark the page as dynamic.\n * - In PPR cases this will postpone the render at this location.\n *\n * If we are inside a cache scope then this function does nothing.\n *\n * @note It expects to be called within App Router and will error otherwise.\n *\n * Read more: [Next.js Docs: `unstable_noStore`](https://nextjs.org/docs/app/api-reference/functions/unstable_noStore)\n */\nexport function unstable_noStore() {\n  const callingExpression = 'unstable_noStore()'\n  const store = workAsyncStorage.getStore()\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (!store) {\n    // This generally implies we are being called in Pages router. We should probably not support\n    // unstable_noStore in contexts outside of `react-server` condition but since we historically\n    // have not errored here previously, we maintain that behavior for now.\n    return\n  } else if (store.forceStatic) {\n    return\n  } else {\n    store.isUnstableNoStore = true\n    if (workUnitStore) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n        case 'prerender-client':\n        case 'prerender-runtime':\n          // unstable_noStore() is a noop in Dynamic I/O.\n          return\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'request':\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n    markCurrentScopeAsDynamic(store, workUnitStore, callingExpression)\n  }\n}\n","import { InvariantError } from '../../shared/lib/invariant-error'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\n\nexport type CacheLife = {\n  // How long the client can cache a value without checking with the server.\n  stale?: number\n  // How frequently you want the cache to refresh on the server.\n  // Stale values may be served while revalidating.\n  revalidate?: number\n  // In the worst case scenario, where you haven't had traffic in a while,\n  // how stale can a value be until you prefer deopting to dynamic.\n  // Must be longer than revalidate.\n  expire?: number\n}\n// The equivalent header is kind of like:\n// Cache-Control: max-age=[stale],s-max-age=[revalidate],stale-while-revalidate=[expire-revalidate],stale-if-error=[expire-revalidate]\n// Except that stale-while-revalidate/stale-if-error only applies to shared caches - not private caches.\n\n// The default revalidates relatively frequently but doesn't expire to ensure it's always\n// able to serve fast results but by default doesn't hang.\n\n// This gets overridden by the next-types-plugin\ntype CacheLifeProfiles =\n  | 'default'\n  | 'seconds'\n  | 'minutes'\n  | 'hours'\n  | 'days'\n  | 'weeks'\n  | 'max'\n  | (string & {})\n\nfunction validateCacheLife(profile: CacheLife) {\n  if (profile.stale !== undefined) {\n    if ((profile.stale as any) === false) {\n      throw new Error(\n        'Pass `Infinity` instead of `false` if you want to cache on the client forever ' +\n          'without checking with the server.'\n      )\n    } else if (typeof profile.stale !== 'number') {\n      throw new Error('The stale option must be a number of seconds.')\n    }\n  }\n  if (profile.revalidate !== undefined) {\n    if ((profile.revalidate as any) === false) {\n      throw new Error(\n        'Pass `Infinity` instead of `false` if you do not want to revalidate by time.'\n      )\n    } else if (typeof profile.revalidate !== 'number') {\n      throw new Error('The revalidate option must be a number of seconds.')\n    }\n  }\n  if (profile.expire !== undefined) {\n    if ((profile.expire as any) === false) {\n      throw new Error(\n        'Pass `Infinity` instead of `false` if you want to cache on the server forever ' +\n          'without checking with the origin.'\n      )\n    } else if (typeof profile.expire !== 'number') {\n      throw new Error('The expire option must be a number of seconds.')\n    }\n  }\n\n  if (profile.revalidate !== undefined && profile.expire !== undefined) {\n    if (profile.revalidate > profile.expire) {\n      throw new Error(\n        'If providing both the revalidate and expire options, ' +\n          'the expire option must be greater than the revalidate option. ' +\n          'The expire option indicates how many seconds from the start ' +\n          'until it can no longer be used.'\n      )\n    }\n  }\n\n  if (profile.stale !== undefined && profile.expire !== undefined) {\n    if (profile.stale > profile.expire) {\n      throw new Error(\n        'If providing both the stale and expire options, ' +\n          'the expire option must be greater than the stale option. ' +\n          'The expire option indicates how many seconds from the start ' +\n          'until it can no longer be used.'\n      )\n    }\n  }\n}\n\nexport function cacheLife(profile: CacheLifeProfiles | CacheLife): void {\n  if (!process.env.__NEXT_USE_CACHE) {\n    throw new Error(\n      '`cacheLife()` is only available with the `experimental.cacheComponents` config.'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  switch (workUnitStore?.type) {\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-runtime':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'unstable-cache':\n    case undefined:\n      throw new Error(\n        '`cacheLife()` can only be called inside a \"use cache\" function.'\n      )\n    case 'cache':\n    case 'private-cache':\n      break\n    default:\n      workUnitStore satisfies never\n  }\n\n  if (typeof profile === 'string') {\n    const workStore = workAsyncStorage.getStore()\n    if (!workStore) {\n      throw new Error(\n        '`cacheLife()` can only be called during App Router rendering at the moment.'\n      )\n    }\n    if (!workStore.cacheLifeProfiles) {\n      throw new InvariantError('`cacheLifeProfiles` should always be provided.')\n    }\n\n    // TODO: This should be globally available and not require an AsyncLocalStorage.\n    const configuredProfile = workStore.cacheLifeProfiles[profile]\n    if (configuredProfile === undefined) {\n      if (workStore.cacheLifeProfiles[profile.trim()]) {\n        throw new Error(\n          `Unknown \\`cacheLife()\\` profile \"${profile}\" is not configured in next.config.js\\n` +\n            `Did you mean \"${profile.trim()}\" without the spaces?`\n        )\n      }\n      throw new Error(\n        `Unknown \\`cacheLife()\\` profile \"${profile}\" is not configured in next.config.js\\n` +\n          'module.exports = {\\n' +\n          '  experimental: {\\n' +\n          '    cacheLife: {\\n' +\n          `      \"${profile}\": ...\\n` +\n          '    }\\n' +\n          '  }\\n' +\n          '}'\n      )\n    }\n    profile = configuredProfile\n  } else if (\n    typeof profile !== 'object' ||\n    profile === null ||\n    Array.isArray(profile)\n  ) {\n    throw new Error(\n      'Invalid `cacheLife()` option. Either pass a profile name or object.'\n    )\n  } else {\n    validateCacheLife(profile)\n  }\n\n  if (profile.revalidate !== undefined) {\n    // Track the explicit revalidate time.\n    if (\n      workUnitStore.explicitRevalidate === undefined ||\n      workUnitStore.explicitRevalidate > profile.revalidate\n    ) {\n      workUnitStore.explicitRevalidate = profile.revalidate\n    }\n  }\n  if (profile.expire !== undefined) {\n    // Track the explicit expire time.\n    if (\n      workUnitStore.explicitExpire === undefined ||\n      workUnitStore.explicitExpire > profile.expire\n    ) {\n      workUnitStore.explicitExpire = profile.expire\n    }\n  }\n  if (profile.stale !== undefined) {\n    // Track the explicit stale time.\n    if (\n      workUnitStore.explicitStale === undefined ||\n      workUnitStore.explicitStale > profile.stale\n    ) {\n      workUnitStore.explicitStale = profile.stale\n    }\n  }\n}\n","import { workUnitAsyncStorage } from '../app-render/work-unit-async-storage.external'\nimport { validateTags } from '../lib/patch-fetch'\n\nexport function cacheTag(...tags: string[]): void {\n  if (!process.env.__NEXT_USE_CACHE) {\n    throw new Error(\n      '`cacheTag()` is only available with the `experimental.cacheComponents` config.'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  switch (workUnitStore?.type) {\n    case 'prerender':\n    case 'prerender-client':\n    case 'prerender-runtime':\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    case 'unstable-cache':\n    case undefined:\n      throw new Error(\n        '`cacheTag()` can only be called inside a \"use cache\" function.'\n      )\n    case 'cache':\n    case 'private-cache':\n      break\n    default:\n      workUnitStore satisfies never\n  }\n\n  const validTags = validateTags(tags, '`cacheTag()`')\n\n  if (!workUnitStore.tags) {\n    workUnitStore.tags = validTags\n  } else {\n    workUnitStore.tags.push(...validTags)\n  }\n}\n","const cacheExports = {\n  unstable_cache: require('next/dist/server/web/spec-extension/unstable-cache')\n    .unstable_cache,\n\n  updateTag: require('next/dist/server/web/spec-extension/revalidate')\n    .updateTag,\n\n  revalidateTag: require('next/dist/server/web/spec-extension/revalidate')\n    .revalidateTag,\n  revalidatePath: require('next/dist/server/web/spec-extension/revalidate')\n    .revalidatePath,\n\n  refresh: require('next/dist/server/web/spec-extension/revalidate').refresh,\n\n  unstable_noStore:\n    require('next/dist/server/web/spec-extension/unstable-no-store')\n      .unstable_noStore,\n  unstable_cacheLife: require('next/dist/server/use-cache/cache-life')\n    .cacheLife,\n  unstable_cacheTag: require('next/dist/server/use-cache/cache-tag').cacheTag,\n}\n\n// https://nodejs.org/api/esm.html#commonjs-namespaces\n// When importing CommonJS modules, the module.exports object is provided as the default export\nmodule.exports = cacheExports\n\n// make import { xxx } from 'next/cache' work\nexports.unstable_cache = cacheExports.unstable_cache\nexports.revalidatePath = cacheExports.revalidatePath\nexports.revalidateTag = cacheExports.revalidateTag\nexports.updateTag = cacheExports.updateTag\nexports.unstable_noStore = cacheExports.unstable_noStore\nexports.unstable_cacheLife = cacheExports.unstable_cacheLife\nexports.unstable_cacheTag = cacheExports.unstable_cacheTag\nexports.refresh = cacheExports.refresh\n","export type SortFilterItem = {\r\n  title: string;\r\n  slug: string | null;\r\n  sortKey: 'RELEVANCE' | 'BEST_SELLING' | 'CREATED_AT' | 'PRICE';\r\n  reverse: boolean;\r\n};\r\n\r\nexport const defaultSort: SortFilterItem = {\r\n  title: 'Relevance',\r\n  slug: null,\r\n  sortKey: 'RELEVANCE',\r\n  reverse: false\r\n};\r\n\r\nexport const sorting: SortFilterItem[] = [\r\n  defaultSort,\r\n  { title: 'Trending', slug: 'trending-desc', sortKey: 'BEST_SELLING', reverse: false }, // asc\r\n  { title: 'Latest arrivals', slug: 'latest-desc', sortKey: 'CREATED_AT', reverse: true },\r\n  { title: 'Price: Low to high', slug: 'price-asc', sortKey: 'PRICE', reverse: false }, // asc\r\n  { title: 'Price: High to low', slug: 'price-desc', sortKey: 'PRICE', reverse: true }\r\n];\r\n\r\nexport const TAGS = {\r\n  collections: 'collections',\r\n  products: 'products',\r\n  cart: 'cart'\r\n};\r\n\r\nexport const HIDDEN_PRODUCT_TAG = 'nextjs-frontend-hidden';\r\nexport const DEFAULT_OPTION = 'Default Title';\r\nexport const SHOPIFY_GRAPHQL_API_ENDPOINT = '/api/2023-01/graphql.json';\r\n","export interface ShopifyErrorLike {\r\n  status: number;\r\n  message: Error;\r\n  cause?: Error;\r\n}\r\n\r\nexport const isObject = (object: unknown): object is Record<string, unknown> => {\r\n  return typeof object === 'object' && object !== null && !Array.isArray(object);\r\n};\r\n\r\nexport const isShopifyError = (error: unknown): error is ShopifyErrorLike => {\r\n  if (!isObject(error)) return false;\r\n\r\n  if (error instanceof Error) return true;\r\n\r\n  return findError(error);\r\n};\r\n\r\nfunction findError<T extends object>(error: T): boolean {\r\n  if (Object.prototype.toString.call(error) === '[object Error]') {\r\n    return true;\r\n  }\r\n\r\n  const prototype = Object.getPrototypeOf(error) as T | null;\r\n\r\n  return prototype === null ? false : findError(prototype);\r\n}\r\n","import {\r\n  HIDDEN_PRODUCT_TAG,\r\n  SHOPIFY_GRAPHQL_API_ENDPOINT,\r\n  TAGS\r\n} from 'lib/constants';\r\nimport { isShopifyError } from 'lib/type-guards';\r\nimport { ensureStartsWith } from 'lib/utils';\r\nimport {\r\n  revalidateTag,\r\n  unstable_cacheTag as cacheTag,\r\n  unstable_cacheLife as cacheLife\r\n} from 'next/cache';\r\nimport { cookies, headers } from 'next/headers';\r\nimport { NextRequest, NextResponse } from 'next/server';\r\nimport {\r\n  addToCartMutation,\r\n  createCartMutation,\r\n  editCartItemsMutation,\r\n  removeFromCartMutation\r\n} from './mutations/cart';\r\nimport { getCartQuery } from './queries/cart';\r\nimport {\r\n  getCollectionProductsQuery,\r\n  getCollectionQuery,\r\n  getCollectionsQuery\r\n} from './queries/collection';\r\nimport { getMenuQuery } from './queries/menu';\r\nimport { getPageQuery, getPagesQuery } from './queries/page';\r\nimport {\r\n  getProductQuery,\r\n  getProductRecommendationsQuery,\r\n  getProductsQuery\r\n} from './queries/product';\r\nimport {\r\n  Cart,\r\n  Collection,\r\n  Connection,\r\n  Image,\r\n  Menu,\r\n  Page,\r\n  Product,\r\n  ShopifyAddToCartOperation,\r\n  ShopifyCart,\r\n  ShopifyCartOperation,\r\n  ShopifyCollection,\r\n  ShopifyCollectionOperation,\r\n  ShopifyCollectionProductsOperation,\r\n  ShopifyCollectionsOperation,\r\n  ShopifyCreateCartOperation,\r\n  ShopifyMenuOperation,\r\n  ShopifyPageOperation,\r\n  ShopifyPagesOperation,\r\n  ShopifyProduct,\r\n  ShopifyProductOperation,\r\n  ShopifyProductRecommendationsOperation,\r\n  ShopifyProductsOperation,\r\n  ShopifyRemoveFromCartOperation,\r\n  ShopifyUpdateCartOperation\r\n} from './types';\r\n\r\nconst domain = process.env.SHOPIFY_STORE_DOMAIN\r\n  ? ensureStartsWith(process.env.SHOPIFY_STORE_DOMAIN, 'https://')\r\n  : '';\r\nconst endpoint = domain ? `${domain}${SHOPIFY_GRAPHQL_API_ENDPOINT}` : '';\r\nconst key = process.env.SHOPIFY_STOREFRONT_ACCESS_TOKEN!;\r\n\r\ntype ExtractVariables<T> = T extends { variables: object }\r\n  ? T['variables']\r\n  : never;\r\n\r\nexport async function shopifyFetch<T>({\r\n  headers,\r\n  query,\r\n  variables\r\n}: {\r\n  headers?: HeadersInit;\r\n  query: string;\r\n  variables?: ExtractVariables<T>;\r\n}): Promise<{ status: number; body: T } | never> {\r\n  try {\r\n    if (!endpoint) {\r\n      throw new Error('SHOPIFY_STORE_DOMAIN environment variable is not set');\r\n    }\r\n\r\n    const result = await fetch(endpoint, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json',\r\n        'X-Shopify-Storefront-Access-Token': key,\r\n        ...headers\r\n      },\r\n      body: JSON.stringify({\r\n        ...(query && { query }),\r\n        ...(variables && { variables })\r\n      })\r\n    });\r\n\r\n    const body = await result.json();\r\n\r\n    if (body.errors) {\r\n      throw body.errors[0];\r\n    }\r\n\r\n    return {\r\n      status: result.status,\r\n      body\r\n    };\r\n  } catch (e) {\r\n    if (isShopifyError(e)) {\r\n      throw {\r\n        cause: e.cause?.toString() || 'unknown',\r\n        status: e.status || 500,\r\n        message: e.message,\r\n        query\r\n      };\r\n    }\r\n\r\n    throw {\r\n      error: e,\r\n      query\r\n    };\r\n  }\r\n}\r\n\r\nconst removeEdgesAndNodes = <T>(array: Connection<T>): T[] => {\r\n  return array.edges.map((edge) => edge?.node);\r\n};\r\n\r\nconst reshapeCart = (cart: ShopifyCart): Cart => {\r\n  if (!cart.cost?.totalTaxAmount) {\r\n    cart.cost.totalTaxAmount = {\r\n      amount: '0.0',\r\n      currencyCode: cart.cost.totalAmount.currencyCode\r\n    };\r\n  }\r\n\r\n  return {\r\n    ...cart,\r\n    lines: removeEdgesAndNodes(cart.lines)\r\n  };\r\n};\r\n\r\nconst reshapeCollection = (\r\n  collection: ShopifyCollection\r\n): Collection | undefined => {\r\n  if (!collection) {\r\n    return undefined;\r\n  }\r\n\r\n  return {\r\n    ...collection,\r\n    path: `/search/${collection.handle}`\r\n  };\r\n};\r\n\r\nconst reshapeCollections = (collections: ShopifyCollection[]) => {\r\n  const reshapedCollections = [];\r\n\r\n  for (const collection of collections) {\r\n    if (collection) {\r\n      const reshapedCollection = reshapeCollection(collection);\r\n\r\n      if (reshapedCollection) {\r\n        reshapedCollections.push(reshapedCollection);\r\n      }\r\n    }\r\n  }\r\n\r\n  return reshapedCollections;\r\n};\r\n\r\nconst reshapeImages = (images: Connection<Image>, productTitle: string) => {\r\n  const flattened = removeEdgesAndNodes(images);\r\n\r\n  return flattened.map((image) => {\r\n    const filename = image.url.match(/.*\\/(.*)\\..*/)?.[1];\r\n    return {\r\n      ...image,\r\n      altText: image.altText || `${productTitle} - ${filename}`\r\n    };\r\n  });\r\n};\r\n\r\nconst reshapeProduct = (\r\n  product: ShopifyProduct,\r\n  filterHiddenProducts: boolean = true\r\n) => {\r\n  if (\r\n    !product ||\r\n    (filterHiddenProducts && product.tags.includes(HIDDEN_PRODUCT_TAG))\r\n  ) {\r\n    return undefined;\r\n  }\r\n\r\n  const { images, variants, ...rest } = product;\r\n\r\n  return {\r\n    ...rest,\r\n    images: reshapeImages(images, product.title),\r\n    variants: removeEdgesAndNodes(variants)\r\n  };\r\n};\r\n\r\nconst reshapeProducts = (products: ShopifyProduct[]) => {\r\n  const reshapedProducts = [];\r\n\r\n  for (const product of products) {\r\n    if (product) {\r\n      const reshapedProduct = reshapeProduct(product);\r\n\r\n      if (reshapedProduct) {\r\n        reshapedProducts.push(reshapedProduct);\r\n      }\r\n    }\r\n  }\r\n\r\n  return reshapedProducts;\r\n};\r\n\r\nexport async function createCart(): Promise<Cart> {\r\n  if (!endpoint) {\r\n    //  - \r\n    const { createDemoCart } = await import('lib/demo/cart');\r\n    const cart = await createDemoCart();\r\n    // Cookie    createDemoCart\r\n    return cart;\r\n  }\r\n\r\n  const res = await shopifyFetch<ShopifyCreateCartOperation>({\r\n    query: createCartMutation\r\n  });\r\n\r\n  return reshapeCart(res.body.data.cartCreate.cart);\r\n}\r\n\r\nexport async function addToCart(\r\n  lines: { merchandiseId: string; quantity: number }[],\r\n  deliveryPrice?: number\r\n): Promise<Cart> {\r\n  if (!endpoint) {\r\n    //  - \r\n    const { addToDemoCart, createDemoCart } = await import('lib/demo/cart');\r\n    const cookieStore = await cookies();\r\n    let cartId = cookieStore.get('cartId')?.value;\r\n    \r\n    if (!cartId) {\r\n      const newCart = await createDemoCart();\r\n      cartId = newCart.id!;\r\n    }\r\n    \r\n    return addToDemoCart(cartId, lines, deliveryPrice);\r\n  }\r\n\r\n  const cartId = (await cookies()).get('cartId')?.value!;\r\n  const res = await shopifyFetch<ShopifyAddToCartOperation>({\r\n    query: addToCartMutation,\r\n    variables: {\r\n      cartId,\r\n      lines\r\n    }\r\n  });\r\n  return reshapeCart(res.body.data.cartLinesAdd.cart);\r\n}\r\n\r\nexport async function removeFromCart(lineIds: string[]): Promise<Cart> {\r\n  if (!endpoint) {\r\n    //  - \r\n    const { removeFromDemoCart } = await import('lib/demo/cart');\r\n    const cartId = (await cookies()).get('cartId')?.value!;\r\n    return removeFromDemoCart(cartId, lineIds);\r\n  }\r\n\r\n  const cartId = (await cookies()).get('cartId')?.value!;\r\n  const res = await shopifyFetch<ShopifyRemoveFromCartOperation>({\r\n    query: removeFromCartMutation,\r\n    variables: {\r\n      cartId,\r\n      lineIds\r\n    }\r\n  });\r\n\r\n  return reshapeCart(res.body.data.cartLinesRemove.cart);\r\n}\r\n\r\nexport async function updateCart(\r\n  lines: { id: string; merchandiseId: string; quantity: number }[]\r\n): Promise<Cart> {\r\n  if (!endpoint) {\r\n    //  - \r\n    const { updateDemoCart } = await import('lib/demo/cart');\r\n    const cartId = (await cookies()).get('cartId')?.value!;\r\n    return updateDemoCart(cartId, lines);\r\n  }\r\n\r\n  const cartId = (await cookies()).get('cartId')?.value!;\r\n  const res = await shopifyFetch<ShopifyUpdateCartOperation>({\r\n    query: editCartItemsMutation,\r\n    variables: {\r\n      cartId,\r\n      lines\r\n    }\r\n  });\r\n\r\n  return reshapeCart(res.body.data.cartLinesUpdate.cart);\r\n}\r\n\r\nexport async function getCart(): Promise<Cart | undefined> {\r\n  const cartId = (await cookies()).get('cartId')?.value;\r\n\r\n  if (!cartId) {\r\n    return undefined;\r\n  }\r\n\r\n  if (!endpoint) {\r\n    //  - \r\n    const { getDemoCart } = await import('lib/demo/cart');\r\n    return getDemoCart(cartId);\r\n  }\r\n\r\n  const res = await shopifyFetch<ShopifyCartOperation>({\r\n    query: getCartQuery,\r\n    variables: { cartId }\r\n  });\r\n\r\n  // Old carts becomes `null` when you checkout.\r\n  if (!res.body.data.cart) {\r\n    return undefined;\r\n  }\r\n\r\n  return reshapeCart(res.body.data.cart);\r\n}\r\n\r\nexport async function getCollection(\r\n  handle: string\r\n): Promise<Collection | undefined> {\r\n  'use cache';\r\n  cacheTag(TAGS.collections);\r\n  cacheLife('days');\r\n\r\n  if (!endpoint) {\r\n    //  -  Shopify\r\n    const { getCategoryByHandle, CATEGORY_STRUCTURE } = await import('lib/demo/categories');\r\n    \r\n    // If handle is empty, return \"All Categories\"\r\n    if (!handle) {\r\n      return {\r\n        handle: '',\r\n        title: 'All Categories',\r\n        description: 'All products',\r\n        seo: {\r\n          title: 'All Categories',\r\n          description: 'All products'\r\n        },\r\n        path: '/search',\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n    }\r\n    \r\n    // First try to find main category\r\n    const category = getCategoryByHandle(handle);\r\n    if (category) {\r\n      return {\r\n        handle: category.handle,\r\n        title: category.name,\r\n        description: `${category.name} category`,\r\n        seo: {\r\n          title: category.name,\r\n          description: `${category.name} category`\r\n        },\r\n        path: `/search/${category.handle}`,\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n    }\r\n    \r\n    // If not found, search in all subcategories\r\n    for (const cat of CATEGORY_STRUCTURE) {\r\n      const subcategory = cat.subcategories?.find(sub => sub.handle === handle);\r\n      if (subcategory) {\r\n        return {\r\n          handle: subcategory.handle,\r\n          title: subcategory.name,\r\n          description: `${subcategory.name} in ${cat.name}`,\r\n          seo: {\r\n            title: subcategory.name,\r\n            description: `${subcategory.name} in ${cat.name}`\r\n          },\r\n          path: `/search/${cat.handle}/${subcategory.handle}`,\r\n          updatedAt: new Date().toISOString()\r\n        };\r\n      }\r\n    }\r\n    \r\n    return undefined;\r\n  }\r\n\r\n  const res = await shopifyFetch<ShopifyCollectionOperation>({\r\n    query: getCollectionQuery,\r\n    variables: {\r\n      handle\r\n    }\r\n  });\r\n\r\n  return reshapeCollection(res.body.data.collection);\r\n}\r\n\r\nexport async function getCollectionProducts({\r\n  collection,\r\n  reverse,\r\n  sortKey,\r\n  filters\r\n}: {\r\n  collection: string;\r\n  reverse?: boolean;\r\n  sortKey?: string;\r\n  filters?: {\r\n    subcategory?: string;\r\n    minPrice?: string;\r\n    maxPrice?: string;\r\n    keywords?: string;\r\n    location?: string;\r\n  };\r\n}): Promise<Product[]> {\r\n  'use cache';\r\n  cacheTag(TAGS.collections, TAGS.products);\r\n  cacheLife('days');\r\n\r\n  if (!endpoint) {\r\n    //  -  Shopify\r\n    const { getDemoCollectionProducts } = await import('lib/demo/products');\r\n    return getDemoCollectionProducts(collection, filters);\r\n  }\r\n\r\n  const res = await shopifyFetch<ShopifyCollectionProductsOperation>({\r\n    query: getCollectionProductsQuery,\r\n    variables: {\r\n      handle: collection,\r\n      reverse,\r\n      sortKey: sortKey === 'CREATED_AT' ? 'CREATED' : sortKey\r\n    }\r\n  });\r\n\r\n  if (!res.body.data.collection) {\r\n    console.log(`No collection found for \\`${collection}\\``);\r\n    return [];\r\n  }\r\n\r\n  return reshapeProducts(\r\n    removeEdgesAndNodes(res.body.data.collection.products)\r\n  );\r\n}\r\n\r\nexport async function getCollections(): Promise<Collection[]> {\r\n  'use cache';\r\n  cacheTag(TAGS.collections);\r\n  cacheLife('days');\r\n\r\n  if (!endpoint) {\r\n    //  -  Shopify\r\n    const { DEMO_COLLECTIONS } = await import('lib/demo/categories');\r\n    return [\r\n      {\r\n        handle: '',\r\n        title: 'All Categories',\r\n        description: 'All products',\r\n        seo: {\r\n          title: 'All Categories',\r\n          description: 'All products'\r\n        },\r\n        path: '/search',\r\n        updatedAt: new Date().toISOString()\r\n      },\r\n      ...DEMO_COLLECTIONS\r\n    ];\r\n  }\r\n\r\n  const res = await shopifyFetch<ShopifyCollectionsOperation>({\r\n    query: getCollectionsQuery\r\n  });\r\n  const shopifyCollections = removeEdgesAndNodes(res.body?.data?.collections);\r\n  const collections = [\r\n    {\r\n      handle: '',\r\n      title: 'All',\r\n      description: 'All products',\r\n      seo: {\r\n        title: 'All',\r\n        description: 'All products'\r\n      },\r\n      path: '/search',\r\n      updatedAt: new Date().toISOString()\r\n    },\r\n    // Filter out the `hidden` collections.\r\n    // Collections that start with `hidden-*` need to be hidden on the search page.\r\n    ...reshapeCollections(shopifyCollections).filter(\r\n      (collection) => !collection.handle.startsWith('hidden')\r\n    )\r\n  ];\r\n\r\n  return collections;\r\n}\r\n\r\nexport async function getMenu(handle: string): Promise<Menu[]> {\r\n  'use cache';\r\n  cacheTag(TAGS.collections);\r\n  cacheLife('days');\r\n\r\n  if (!endpoint) {\r\n    //  -  Shopify\r\n    const { getDemoMenu } = await import('lib/demo/menu');\r\n    return getDemoMenu(handle);\r\n  }\r\n\r\n  const res = await shopifyFetch<ShopifyMenuOperation>({\r\n    query: getMenuQuery,\r\n    variables: {\r\n      handle\r\n    }\r\n  });\r\n\r\n  return (\r\n    res.body?.data?.menu?.items.map((item: { title: string; url: string }) => ({\r\n      title: item.title,\r\n      path: item.url\r\n        .replace(domain, '')\r\n        .replace('/collections', '/search')\r\n        .replace('/pages', '')\r\n    })) || []\r\n  );\r\n}\r\n\r\nexport async function getPage(handle: string): Promise<Page> {\r\n  'use cache';\r\n  cacheTag('pages');\r\n  cacheLife('days');\r\n  \r\n  const res = await shopifyFetch<ShopifyPageOperation>({\r\n    query: getPageQuery,\r\n    variables: { handle }\r\n  });\r\n\r\n  return res.body.data.pageByHandle;\r\n}\r\n\r\nexport async function getPages(): Promise<Page[]> {\r\n  const res = await shopifyFetch<ShopifyPagesOperation>({\r\n    query: getPagesQuery\r\n  });\r\n\r\n  return removeEdgesAndNodes(res.body.data.pages);\r\n}\r\n\r\nexport async function getProduct(handle: string): Promise<Product | undefined> {\r\n  'use cache';\r\n  cacheTag(TAGS.products);\r\n  cacheLife('days');\r\n\r\n  if (!endpoint) {\r\n    //  -  Shopify\r\n    const { getDemoProduct } = await import('lib/demo/products');\r\n    return getDemoProduct(handle);\r\n  }\r\n\r\n  const res = await shopifyFetch<ShopifyProductOperation>({\r\n    query: getProductQuery,\r\n    variables: {\r\n      handle\r\n    }\r\n  });\r\n\r\n  return reshapeProduct(res.body.data.product, false);\r\n}\r\n\r\nexport async function getProductRecommendations(\r\n  productId: string\r\n): Promise<Product[]> {\r\n  'use cache';\r\n  cacheTag(TAGS.products);\r\n  cacheLife('days');\r\n\r\n  if (!endpoint) {\r\n    //  -  Shopify\r\n    const { getDemoProductRecommendations } = await import('lib/demo/products');\r\n    return getDemoProductRecommendations(productId);\r\n  }\r\n\r\n  const res = await shopifyFetch<ShopifyProductRecommendationsOperation>({\r\n    query: getProductRecommendationsQuery,\r\n    variables: {\r\n      productId\r\n    }\r\n  });\r\n\r\n  return reshapeProducts(res.body.data.productRecommendations);\r\n}\r\n\r\nexport async function getProducts({\r\n  query,\r\n  reverse,\r\n  sortKey\r\n}: {\r\n  query?: string;\r\n  reverse?: boolean;\r\n  sortKey?: string;\r\n}): Promise<Product[]> {\r\n  'use cache';\r\n  cacheTag(TAGS.products);\r\n  cacheLife('days');\r\n\r\n  if (!endpoint) {\r\n    //  -  Shopify\r\n    const { getDemoProducts } = await import('lib/demo/products');\r\n    let products = getDemoProducts();\r\n    \r\n    //    query ( )\r\n    if (query) {\r\n      const searchQuery = query.toLowerCase();\r\n      products = products.filter(\r\n        p => p.title.toLowerCase().includes(searchQuery) ||\r\n             p.description.toLowerCase().includes(searchQuery)\r\n      );\r\n    }\r\n    \r\n    return products;\r\n  }\r\n\r\n  const res = await shopifyFetch<ShopifyProductsOperation>({\r\n    query: getProductsQuery,\r\n    variables: {\r\n      query,\r\n      reverse,\r\n      sortKey\r\n    }\r\n  });\r\n\r\n  return reshapeProducts(removeEdgesAndNodes(res.body.data.products));\r\n}\r\n\r\n// This is called from `app/api/revalidate.ts` so providers can control revalidation logic.\r\nexport async function revalidate(req: NextRequest): Promise<NextResponse> {\r\n  // We always need to respond with a 200 status code to Shopify,\r\n  // otherwise it will continue to retry the request.\r\n  const collectionWebhooks = [\r\n    'collections/create',\r\n    'collections/delete',\r\n    'collections/update'\r\n  ];\r\n  const productWebhooks = [\r\n    'products/create',\r\n    'products/delete',\r\n    'products/update'\r\n  ];\r\n  const topic = (await headers()).get('x-shopify-topic') || 'unknown';\r\n  const secret = req.nextUrl.searchParams.get('secret');\r\n  const isCollectionUpdate = collectionWebhooks.includes(topic);\r\n  const isProductUpdate = productWebhooks.includes(topic);\r\n\r\n  if (!secret || secret !== process.env.SHOPIFY_REVALIDATION_SECRET) {\r\n    console.error('Invalid revalidation secret.');\r\n    return NextResponse.json({ status: 401 });\r\n  }\r\n\r\n  if (!isCollectionUpdate && !isProductUpdate) {\r\n    // We don't need to revalidate anything for any other topics.\r\n    return NextResponse.json({ status: 200 });\r\n  }\r\n\r\n  if (isCollectionUpdate) {\r\n    revalidateTag(TAGS.collections, 'seconds');\r\n  }\r\n\r\n  if (isProductUpdate) {\r\n    revalidateTag(TAGS.products, 'seconds');\r\n  }\r\n\r\n  return NextResponse.json({ status: 200, revalidated: true, now: Date.now() });\r\n}\r\n","const imageFragment = /* GraphQL */ `\r\n  fragment image on Image {\r\n    url\r\n    altText\r\n    width\r\n    height\r\n  }\r\n`;\r\n\r\nexport default imageFragment;\r\n","const seoFragment = /* GraphQL */ `\r\n  fragment seo on SEO {\r\n    description\r\n    title\r\n  }\r\n`;\r\n\r\nexport default seoFragment;\r\n","import imageFragment from './image';\r\nimport seoFragment from './seo';\r\n\r\nconst productFragment = /* GraphQL */ `\r\n  fragment product on Product {\r\n    id\r\n    handle\r\n    availableForSale\r\n    title\r\n    description\r\n    descriptionHtml\r\n    options {\r\n      id\r\n      name\r\n      values\r\n    }\r\n    priceRange {\r\n      maxVariantPrice {\r\n        amount\r\n        currencyCode\r\n      }\r\n      minVariantPrice {\r\n        amount\r\n        currencyCode\r\n      }\r\n    }\r\n    variants(first: 250) {\r\n      edges {\r\n        node {\r\n          id\r\n          title\r\n          availableForSale\r\n          selectedOptions {\r\n            name\r\n            value\r\n          }\r\n          price {\r\n            amount\r\n            currencyCode\r\n          }\r\n        }\r\n      }\r\n    }\r\n    featuredImage {\r\n      ...image\r\n    }\r\n    images(first: 20) {\r\n      edges {\r\n        node {\r\n          ...image\r\n        }\r\n      }\r\n    }\r\n    seo {\r\n      ...seo\r\n    }\r\n    tags\r\n    updatedAt\r\n  }\r\n  ${imageFragment}\r\n  ${seoFragment}\r\n`;\r\n\r\nexport default productFragment;\r\n","import productFragment from './product';\r\n\r\nconst cartFragment = /* GraphQL */ `\r\n  fragment cart on Cart {\r\n    id\r\n    checkoutUrl\r\n    cost {\r\n      subtotalAmount {\r\n        amount\r\n        currencyCode\r\n      }\r\n      totalAmount {\r\n        amount\r\n        currencyCode\r\n      }\r\n      totalTaxAmount {\r\n        amount\r\n        currencyCode\r\n      }\r\n    }\r\n    lines(first: 100) {\r\n      edges {\r\n        node {\r\n          id\r\n          quantity\r\n          cost {\r\n            totalAmount {\r\n              amount\r\n              currencyCode\r\n            }\r\n          }\r\n          merchandise {\r\n            ... on ProductVariant {\r\n              id\r\n              title\r\n              selectedOptions {\r\n                name\r\n                value\r\n              }\r\n              product {\r\n                ...product\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    totalQuantity\r\n  }\r\n  ${productFragment}\r\n`;\r\n\r\nexport default cartFragment;\r\n","import cartFragment from '../fragments/cart';\r\n\r\nexport const addToCartMutation = /* GraphQL */ `\r\n  mutation addToCart($cartId: ID!, $lines: [CartLineInput!]!) {\r\n    cartLinesAdd(cartId: $cartId, lines: $lines) {\r\n      cart {\r\n        ...cart\r\n      }\r\n    }\r\n  }\r\n  ${cartFragment}\r\n`;\r\n\r\nexport const createCartMutation = /* GraphQL */ `\r\n  mutation createCart($lineItems: [CartLineInput!]) {\r\n    cartCreate(input: { lines: $lineItems }) {\r\n      cart {\r\n        ...cart\r\n      }\r\n    }\r\n  }\r\n  ${cartFragment}\r\n`;\r\n\r\nexport const editCartItemsMutation = /* GraphQL */ `\r\n  mutation editCartItems($cartId: ID!, $lines: [CartLineUpdateInput!]!) {\r\n    cartLinesUpdate(cartId: $cartId, lines: $lines) {\r\n      cart {\r\n        ...cart\r\n      }\r\n    }\r\n  }\r\n  ${cartFragment}\r\n`;\r\n\r\nexport const removeFromCartMutation = /* GraphQL */ `\r\n  mutation removeFromCart($cartId: ID!, $lineIds: [ID!]!) {\r\n    cartLinesRemove(cartId: $cartId, lineIds: $lineIds) {\r\n      cart {\r\n        ...cart\r\n      }\r\n    }\r\n  }\r\n  ${cartFragment}\r\n`;\r\n","import cartFragment from '../fragments/cart';\r\n\r\nexport const getCartQuery = /* GraphQL */ `\r\n  query getCart($cartId: ID!) {\r\n    cart(id: $cartId) {\r\n      ...cart\r\n    }\r\n  }\r\n  ${cartFragment}\r\n`;\r\n","import productFragment from '../fragments/product';\r\nimport seoFragment from '../fragments/seo';\r\n\r\nconst collectionFragment = /* GraphQL */ `\r\n  fragment collection on Collection {\r\n    handle\r\n    title\r\n    description\r\n    seo {\r\n      ...seo\r\n    }\r\n    updatedAt\r\n  }\r\n  ${seoFragment}\r\n`;\r\n\r\nexport const getCollectionQuery = /* GraphQL */ `\r\n  query getCollection($handle: String!) {\r\n    collection(handle: $handle) {\r\n      ...collection\r\n    }\r\n  }\r\n  ${collectionFragment}\r\n`;\r\n\r\nexport const getCollectionsQuery = /* GraphQL */ `\r\n  query getCollections {\r\n    collections(first: 100, sortKey: TITLE) {\r\n      edges {\r\n        node {\r\n          ...collection\r\n        }\r\n      }\r\n    }\r\n  }\r\n  ${collectionFragment}\r\n`;\r\n\r\nexport const getCollectionProductsQuery = /* GraphQL */ `\r\n  query getCollectionProducts(\r\n    $handle: String!\r\n    $sortKey: ProductCollectionSortKeys\r\n    $reverse: Boolean\r\n  ) {\r\n    collection(handle: $handle) {\r\n      products(sortKey: $sortKey, reverse: $reverse, first: 100) {\r\n        edges {\r\n          node {\r\n            ...product\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  ${productFragment}\r\n`;\r\n","export const getMenuQuery = /* GraphQL */ `\r\n  query getMenu($handle: String!) {\r\n    menu(handle: $handle) {\r\n      items {\r\n        title\r\n        url\r\n      }\r\n    }\r\n  }\r\n`;\r\n","import seoFragment from '../fragments/seo';\r\n\r\nconst pageFragment = /* GraphQL */ `\r\n  fragment page on Page {\r\n    ... on Page {\r\n      id\r\n      title\r\n      handle\r\n      body\r\n      bodySummary\r\n      seo {\r\n        ...seo\r\n      }\r\n      createdAt\r\n      updatedAt\r\n    }\r\n  }\r\n  ${seoFragment}\r\n`;\r\n\r\nexport const getPageQuery = /* GraphQL */ `\r\n  query getPage($handle: String!) {\r\n    pageByHandle(handle: $handle) {\r\n      ...page\r\n    }\r\n  }\r\n  ${pageFragment}\r\n`;\r\n\r\nexport const getPagesQuery = /* GraphQL */ `\r\n  query getPages {\r\n    pages(first: 100) {\r\n      edges {\r\n        node {\r\n          ...page\r\n        }\r\n      }\r\n    }\r\n  }\r\n  ${pageFragment}\r\n`;\r\n","import productFragment from '../fragments/product';\r\n\r\nexport const getProductQuery = /* GraphQL */ `\r\n  query getProduct($handle: String!) {\r\n    product(handle: $handle) {\r\n      ...product\r\n    }\r\n  }\r\n  ${productFragment}\r\n`;\r\n\r\nexport const getProductsQuery = /* GraphQL */ `\r\n  query getProducts($sortKey: ProductSortKeys, $reverse: Boolean, $query: String) {\r\n    products(sortKey: $sortKey, reverse: $reverse, query: $query, first: 100) {\r\n      edges {\r\n        node {\r\n          ...product\r\n        }\r\n      }\r\n    }\r\n  }\r\n  ${productFragment}\r\n`;\r\n\r\nexport const getProductRecommendationsQuery = /* GraphQL */ `\r\n  query getProductRecommendations($productId: ID!) {\r\n    productRecommendations(productId: $productId) {\r\n      ...product\r\n    }\r\n  }\r\n  ${productFragment}\r\n`;\r\n"],"names":["isThenable","promise","then","trackDynamicImport","modulePromise","process","env","NEXT_RUNTIME","InvariantError","trackPendingImport","module","exports","require","vendored","ReactServerDOMTurbopackServer","registerServerReference","ReactDOM","ReactServerDOMTurbopackStatic","ensureLeadingSlash","path","startsWith","DEFAULT_SEGMENT_KEY","PAGE_SEGMENT_KEY","addSearchParamsIfPageSegment","isGroupSegment","isParallelRouteSegment","segment","endsWith","searchParams","isPageSegment","includes","stringifiedQuery","JSON","stringify","normalizeAppPath","normalizeRscURL","route","split","reduce","pathname","index","segments","length","url","replace","arrayBufferToString","decrypt","encrypt","getActionEncryptionKey","getClientReferenceManifestForRsc","getServerModuleMap","setReferenceManifestsSingleton","stringToUint8Array","__next_loaded_action_key","buffer","bytes","Uint8Array","len","byteLength","String","fromCharCode","apply","binary","i","arr","charCodeAt","key","iv","data","crypto","subtle","name","SERVER_ACTION_MANIFESTS_SINGLETON","Symbol","for","page","clientReferenceManifest","serverActionsManifest","serverModuleMap","globalThis","clientReferenceManifestsPerPage","serverActionsManifestSingleton","workStore","workAsyncStorage","getStore","mergeClientReferenceManifests","rawKey","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","undefined","importKey","atob","clientReferenceManifests","Object","values","mergedClientReferenceManifest","clientModules","edgeRscModuleMapping","rscModuleMapping","AppRenderSpan","AppRouteRouteHandlersSpan","BaseServerSpan","LoadComponentsSpan","LogSpanAllowList","MiddlewareSpan","NextNodeServerSpan","NextServerSpan","NextVanillaSpanAllowlist","NodeSpan","RenderSpan","ResolveMetadataSpan","RouterSpan","StartServerSpan","BubbledError","SpanKind","SpanStatusCode","getTracer","isBubbledError","api","err","context","propagation","trace","ROOT_CONTEXT","Error","constructor","bubble","result","error","closeSpanWithError","span","setAttribute","recordException","setStatus","code","ERROR","message","end","rootSpanAttributesStore","Map","rootSpanIdKey","createContextKey","lastSpanId","getSpanId","clientTraceDataSetter","set","carrier","value","push","NextTracerImpl","getTracerInstance","getContext","getTracePropagationData","activeContext","active","entries","inject","getActiveScopeSpan","getSpan","withPropagatedContext","fn","getter","getSpanContext","remoteContext","extract","with","args","type","fnOrOptions","fnOrEmpty","options","spanName","NEXT_OTEL_VERBOSE","hideSpan","spanContext","parentSpan","isRootSpan","isRemote","spanId","attributes","setValue","startActiveSpan","startTime","performance","now","onCleanup","delete","NEXT_OTEL_PERFORMANCE_PREFIX","measure","pop","match","toLowerCase","start","res","catch","finally","wrap","tracer","optionsObj","arguments","lastArgId","cb","scopeBoundCb","bind","_span","done","startSpan","setSpan","getRootSpanAttributes","getValue","get","setRootSpanAttribute","has","DetachedPromise","resolve","reject","Promise","rej","ENCODED_TAGS","OPENING","HTML","BODY","CLOSED","HEAD","BODY_AND_HTML","META","ICON_MARK","indexOfUint8Array","isEquivalentUint8Arrays","removeFromUint8Array","a","b","completeMatch","j","tagIndex","subarray","removed","slice","MISSING_ROOT_TAGS_ERROR","DOC_PREFETCH_RANGE_HEADER_VALUE","doesExportedHtmlMatchBuildId","insertBuildIdComment","DOCTYPE_PREFIX","MAX_BUILD_ID_LENGTH","escapeBuildId","buildId","truncated","originalHtml","partialHtmlDocument","chainStreams","continueDynamicHTMLResume","continueDynamicPrerender","continueFizzStream","continueStaticPrerender","createBufferedTransformStream","createDocumentClosingStream","createRootLayoutValidatorStream","renderToInitialFizzStream","streamFromBuffer","streamFromString","streamToBuffer","streamToString","voidCatch","encoder","TextEncoder","streams","ReadableStream","controller","close","readable","writable","TransformStream","pipeTo","preventClose","nextStream","lastStream","str","enqueue","encode","chunk","stream","reader","getReader","chunks","read","Buffer","concat","signal","decoder","TextDecoder","fatal","string","aborted","decode","maxBufferByteLength","Infinity","bufferedChunks","bufferByteLength","pending","flush","copiedBytes","bufferedChunk","scheduleFlush","detached","scheduleImmediate","transform","createPrefetchCommentStream","isBuildTimePrerendering","didTransformFirstChunk","chunkStr","updatedChunkStr","ReactDOMServer","element","streamOptions","renderToReadableStream","createMetadataTransformStream","insert","chunkIndex","isMarkRemoved","iconMarkIndex","closedHeadIndex","iconMarkLength","replaced","insertion","encodedInsertion","insertionLength","createHeadInsertionTransformStream","inserted","hasBytes","insertedHeadContent","createDeferredSuffixStream","suffix","flushed","createFlightDataInjectionTransformStream","delayDataUntilFirstHtmlChunk","htmlStreamFinished","pull","donePulling","startOrContinuePulling","startPulling","atLeastOneTask","CLOSE_TAG","createMoveSuffixStream","foundSuffix","before","after","createStripDocumentClosingTagsTransform","foundHtml","foundBody","missingTags","map","c","join","chainTransformers","transformers","transformer","pipeThrough","renderStream","inlinedDataStream","isStaticGeneration","getServerInsertedHTML","getServerInsertedMetadata","validateRootLayout","suffixUnclosed","allReady","prerenderStream","decryptActionBoundArgs","encryptActionBoundArgs","isEdgeRuntime","textEncoder","textDecoder","filterStackFrame","NODE_ENV","filterStackFrameDEV","findSourceMapURL","findSourceMapURLDEV","decodeActionBoundArg","actionId","arg","originalPayload","ivValue","payload","decrypted","encodeActionBoundArg","randomBytes","workUnitAsyncStorage","exit","getRandomValues","encrypted","btoa","ReadStatus","React","cache","workUnitStore","cacheSignal","getCacheSignal","captureStackTrace","didCatchError","hangingInputAbortSignal","createHangingInputAbortSignal","readStatus","startReadOnce","beginRead","endReadIfStarted","endRead","addEventListener","once","serialized","onError","console","prerenderResumeDataCache","getPrerenderResumeDataCache","renderResumeDataCache","getRenderResumeDataCache","cacheKey","cachedEncrypted","encryptedBoundArgs","encryptedPromise","decryptedBoundArgs","deserialized","createFromReadableStream","renderSignal","serverConsumerManifest","moduleLoading","moduleMap","formatServerError","getStackWithoutErrorMessage","invalidServerComponentReactHooks","setMessage","stack","lines","addedMessage","clientHook","regex","RegExp","test","NEXT_REQUEST_META","addRequestMeta","getRequestMeta","removeRequestMeta","setRequestMeta","req","meta","request","isNodeNextRequest","isNodeNextResponse","isWebNextRequest","isWebNextResponse","NextRequestAdapter","ResponseAborted","ResponseAbortedName","createAbortController","signalFromNodeResponse","response","AbortController","writableFinished","abort","errored","destroyed","AbortSignal","fromBaseNextRequest","fromWebNextRequest","fromNodeNextRequest","body","method","URL","base","NextRequest","headers","fromNodeOutgoingHttpHeaders","duplex","getClientComponentLoaderMetrics","wrapClientComponentLoader","clientComponentLoadStart","clientComponentLoadTimes","clientComponentLoadCount","ComponentMod","__next_app__","loadChunk","metrics","reset","isAbortError","pipeToNodeResponse","e","createWriterFromResponse","waitUntilForEnd","started","drained","onDrain","on","off","finished","WritableStream","write","flushHeaders","startResponse","ok","cause","destroy","writer","HTTPAccessErrorStatus","HTTP_ERROR_FALLBACK_ERROR_CODE","getAccessFallbackErrorTypeByStatus","getAccessFallbackHTTPStatus","isHTTPAccessFallbackError","NOT_FOUND","FORBIDDEN","UNAUTHORIZED","ALLOWED_CODES","Set","digest","prefix","httpStatus","Number","status","RedirectStatusCode","REDIRECT_ERROR_CODE","RedirectType","isRedirectError","errorCode","destination","at","statusCode","isNaN","isNextRouterError","getObjectClassLabel","isPlainObject","prototype","toString","call","getPrototypeOf","hasOwnProperty","isError","getProperError","safeStringify","obj","seen","WeakSet","_key","add","createDigestWithErrorCode","extractNextErrorCode","ERROR_CODE_DELIMITER","thrownValue","originalDigest","__NEXT_ERROR_CODE","find","isReactLargeShellError","createFlightReactServerErrorHandler","createHTMLErrorHandler","createHTMLReactServerErrorHandler","getDigestForWellKnownError","isUserLandError","isBailoutToCSRError","isDynamicServerError","isPrerenderInterruptedError","shouldFormatError","onReactServerRenderError","stringHash","isNextExport","reactServerErrors","silenceLogger","allCapturedErrors","onHTMLRenderSSRError","errorInfo","isSSRError","componentStack","DYNAMIC_EXPIRE","RUNTIME_PREFETCH_DYNAMIC_STALE","getCacheHandler","getCacheHandlerEntries","getCacheHandlers","initializeCacheHandlers","setCacheHandler","debug","NEXT_PRIVATE_DEBUG_CACHE","log","handlersSymbol","handlersMapSymbol","handlersSetSymbol","reference","fallback","DefaultCache","DefaultCacheHandler","RemoteCache","kind","cacheHandler","UseCacheTimeoutError","isUseCacheTimeoutError","USE_CACHE_TIMEOUT_ERROR_CODE","describeHasCheckingStringProperty","describeStringPropertyAccess","wellKnownProperties","isDefinitelyAValidIdentifier","target","prop","stringifiedProp","createPrerenderSearchParamsForClientPage","createSearchParamsFromClient","createServerSearchParamsForMetadata","createServerSearchParamsForServerPage","makeErroringSearchParamsForUseCache","underlyingSearchParams","createStaticPrerenderSearchParams","createRenderSearchParams","throwInvariantForMissingStore","createRuntimePrerenderSearchParams","forceStatic","makeHangingPromise","prerenderStore","makeHangingSearchParams","makeErroringSearchParams","delayUntilRuntimeStage","makeUntrackedSearchParams","makeUntrackedSearchParamsWithDevWarnings","CachedSearchParams","WeakMap","CachedSearchParamsForUseCache","cachedSearchParams","proxiedPromise","Proxy","receiver","hasOwn","ReflectAdapter","expression","annotateDynamicAccess","dynamicShouldError","throwWithStaticGenerationBailoutErrorWithDynamicError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","throwForSearchParamsAccessInUseCache","store","proxiedProperties","promiseInitialized","proxiedUnderlying","Reflect","ownKeys","makeDevtoolsIOAwarePromise","keys","forEach","warnForSyncAccess","createDedupedByCallsiteServerErrorLoggerDev","createSearchAccessError","createLazyResult","isResolvedLazyResult","pendingResult","onfulfilled","onrejected","generateCacheEntry","cacheContext","encodedArguments","sharedErrorStack","runInCleanSnapshot","generateCacheEntryWithRestoredWorkStore","run","generateCacheEntryWithCacheContext","createUseCacheStore","defaultCacheLife","outerWorkUnitStore","phase","implicitTags","revalidate","expire","stale","explicitRevalidate","explicitExpire","explicitStale","tags","hmrRefreshHash","getHmrRefreshHash","isHmrRefresh","serverComponentsHmrCache","getServerComponentsHmrCache","forceRevalidate","shouldForceRevalidate","runtimeStagePromise","getRuntimeStagePromise","draftMode","getDraftModeProviderForCacheScope","rootParams","cookies","useCacheOrRequestStore","assertDefaultCacheLife","cacheLifeProfiles","cacheStore","dynamicAccessAsyncStorage","abortController","generateCacheEntryImpl","propagateCacheLifeAndTagsToRevalidateStore","revalidateStore","entry","outerTags","tag","propagateCacheLifeAndTags","collectResult","savedStream","innerCacheStore","errors","idx","bufferStream","invalidDynamicUsageError","collectedTags","collectedRevalidate","collectedExpire","collectedStale","timestamp","temporaryReferences","createServerTemporaryReferenceSet","decodeReply","decodeReplyFromAsyncIterable","asyncIterator","timeOrigin","resultPromise","handleError","timeoutAbortController","timer","setTimeout","dynamicAccessAbortSignal","abortSignal","any","prelude","prerender","environmentName","reason","clearTimeout","hangingPromise","returnStream","tee","pendingCacheEntry","cloneCacheEntry","streamA","streamB","clonedEntry","clonePendingCacheEntry","getNthCacheEntry","encodeFormData","formData","stringValue","arrayBuffer","fromCodePoint","Uint16Array","createTrackedReadableStream","wrapAsInvalidDynamicUsageError","id","boundArgsLength","originalFn","sharedError","isPrivate","indexOf","cachedFn","isPageOrLayoutSegmentFunction","isPageSegmentFunction","params","outerParams","outerSearchParams","otherOuterArgs","props","_innerParams","innerSearchParams","otherInnerArgs","isLayoutSegmentFunction","$$isLayout","outerSlots","innerSlots","shift","boundArgs","Array","isArray","unshift","createClientTemporaryReferenceSet","cacheKeyParts","encodeCacheKeyParts","encodeReply","encodedCacheKeyParts","dynamicAccessAbortController","serializedCacheKey","cachedEntry","existingEntry","allowEmptyStaticShell","lazyRefreshTags","refreshTagsByCacheKind","implicitTagsExpiration","lazyExpiration","expirationsByCacheKind","expiration","shouldDiscardCacheEntry","currentTime","newStream","isDraftMode","savedCacheEntry","pendingRevalidateWrites","entryLeft","entryRight","ignoredStream","cancel","replayConsoleLogs","maybeProps","$$isPage","isOnDemandRevalidate","dev","some","isRecentlyRevalidatedTag","previouslyRevalidatedTags","pendingRevalidatedTags","item","cloneResponse","noop","registry","FinalizationRegistry","weakRef","deref","locked","original","body1","body2","cloned1","Response","statusText","defineProperty","configurable","enumerable","register","WeakRef","cloned2","createDedupeFetch","simpleCacheKey","headersToExcludeInCacheKey","generateCacheKey","filteredHeaders","from","filter","mode","redirect","credentials","referrer","referrerPolicy","integrity","originalFetch","getCacheEntries","dedupeFetch","resource","Request","keepalive","cacheEntries","CachedRouteKind","IncrementalCacheKind","Batcher","cacheKeyFn","schedulerFn","create","batch","RenderResult","EMPTY","metadata","contentType","fromStatic","waitUntil","assignMetadata","assign","isNull","isDynamic","toUnchunkedString","isBuffer","coerce","RouteKind","fromResponseCacheEntry","routeKindToIncrementalCacheKind","toResponseCacheEntry","cacheEntry","PAGES","html","pageData","APP_PAGE","postponed","rscData","segmentData","isMiss","isStale","cacheControl","HTML_CONTENT_TYPE_HEADER","routeKind","IMAGE","APP_ROUTE","PAGES_API","ResponseCache","minimal_mode","getBatcher","scheduleOnNextTick","revalidateBatcher","responseGenerator","hasResolved","previousCacheEntry","previousCacheItem","expiresAt","Date","incrementalCache","isFallback","isRoutePPREnabled","isPrefetch","handleGet","previousIncrementalCacheEntry","resolved","incrementalResponseCacheEntry","handleRevalidate","responseCacheEntry","isRevalidating","Math","min","max","NEXT_PATCH_SYMBOL","createPatchedFetcher","patchFetch","validateRevalidate","validateTags","isFetchPatched","revalidateVal","normalizedRevalidate","INFINITE_CACHE","description","validTags","invalidTags","NEXT_CACHE_TAG_MAX_LENGTH","NEXT_CACHE_TAG_MAX_ITEMS","warn","trackFetchMetric","ctx","shouldTrackFetchMetrics","fetchMetrics","nextFetchId","createCachedPrerenderResponse","incrementalCacheContext","handleUnlock","bodyBuffer","fetchedData","fromEntries","FETCH","createCachedDynamicResponse","input","cacheSetPromise","pendingRevalidateKey","pendingRevalidates","originFetch","patched","fetch","init","username","password","fetchUrl","href","toUpperCase","isInternal","next","internal","NEXT_OTEL_FETCH_DISABLED","fetchStart","internalFetch","CLIENT","Boolean","hostname","port","isRequestInput","field","finalRevalidate","getNextField","originalFetchRevalidate","currentFetchRevalidate","pageFetchCacheMode","fetchCache","isUsingNoStore","isUnstableNoStore","currentFetchCacheConfig","cacheReason","cacheWarning","isConflictingRevalidate","hasExplicitFetchCacheOptOut","noFetchConfigAndForceDynamic","forceDynamic","_headers","initHeaders","Headers","hasUnCacheableHeader","isUnCacheableMethod","hasNoExplicitCacheConfig","autoNoCache","isImplicitBuildTimeCache","markCurrentScopeAsDynamic","isCacheableRevalidate","fetchIdx","doOriginalFetch","cacheReasonOverride","requestInputFields","reqInput","reqOptions","_ogBody","otherInput","clonedInit","fetchType","cacheStatus","CACHE_ONE_YEAR","incrementalCacheConfig","isForegroundRevalidate","isHmrRefreshCache","cachedFetchData","lock","softTags","getTimeoutBoundary","pendingRevalidate","hasNextConfig","revalidatedResult","pendingResponse","responses","__nextPatched","__nextGetStaticStore","_nextOriginalFetch","currentTimeoutBoundary","r","unstable_cache","noStoreFetchIdx","cacheNewResult","keyParts","fixedKey","cachedCb","maybeIncrementalCache","__incrementalCache","fetchUrlPrefix","getFetchUrlPrefix","invocationKey","isNestedUnstableCache","cachedResponse","parse","revalidationPromise","URLSearchParams","search","sortedSearch","sort","localeCompare","getSortedRouteObjects","getSortedRoutes","UrlNode","urlPath","_insert","smoosh","_smoosh","childrenPaths","children","slugName","splice","restSlugName","optionalRestSlugName","routes","prev","curr","placeholder","urlPaths","slugNames","isCatchAll","nextSegment","segmentName","isOptional","substring","handleSlug","previousSlug","nextSlug","slug","normalizedPages","root","pagePath","objects","indexes","pathnames","sorted","INTERCEPTION_ROUTE_MARKERS","extractInterceptionRouteInformation","isInterceptionRouteAppPath","m","interceptingRoute","marker","interceptedRoute","splitInterceptingRoute","isDynamicRoute","TEST_ROUTE","TEST_STRICT_ROUTE","strict","refresh","revalidatePath","revalidateTag","updateTag","profile","pathWasRevalidated","originalPath","NEXT_CACHE_SOFT_TAG_MAX_LENGTH","normalizedPath","NEXT_CACHE_IMPLICIT_TAG_ID","abortAndThrowOnSynchronousRequestDataAccess","DynamicServerError","dynamicUsageDescription","dynamicUsageStack","usedDynamic","existingIndex","findIndex","cacheLife","unstable_noStore","callingExpression","validateCacheLife","__NEXT_USE_CACHE","configuredProfile","trim","cacheTag"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64]}