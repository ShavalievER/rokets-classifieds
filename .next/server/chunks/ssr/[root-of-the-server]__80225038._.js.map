{"version":3,"sources":["turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/shared/lib/is-thenable.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/app-render/module-loading/track-dynamic-import.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/build/webpack/loaders/next-flight-loader/track-dynamic-import.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/src/server/og/image-response.ts","turbopack:///[project]/node_modules/.pnpm/next@15.6.0-canary.60_react_60c2d962eb59e8fdc3ce5782532c32a4/node_modules/next/og.js","turbopack:///[project]/components/opengraph-image.tsx","turbopack:///[project]/app/opengraph-image.tsx","turbopack:///[project]/app/opengraph-image--metadata.js"],"sourcesContent":["/**\n * Check to see if a value is Thenable.\n *\n * @param promise the maybe-thenable value\n * @returns true if the value is thenable\n */\nexport function isThenable<T = unknown>(\n  promise: Promise<T> | T\n): promise is Promise<T> {\n  return (\n    promise !== null &&\n    typeof promise === 'object' &&\n    'then' in promise &&\n    typeof promise.then === 'function'\n  )\n}\n","import { InvariantError } from '../../../shared/lib/invariant-error'\nimport { isThenable } from '../../../shared/lib/is-thenable'\nimport { trackPendingImport } from './track-module-loading.external'\n\n/**\n * in CacheComponents, `import(...)` will be transformed into `trackDynamicImport(import(...))`.\n * A dynamic import is essentially a cached async function, except it's cached by the module system.\n *\n * The promises are tracked globally regardless of if the `import()` happens inside a render or outside of it.\n * When rendering, we can make the `cacheSignal` wait for all pending promises via `trackPendingModules`.\n * */\nexport function trackDynamicImport<TExports extends Record<string, any>>(\n  modulePromise: Promise<TExports>\n): Promise<TExports> {\n  if (process.env.NEXT_RUNTIME === 'edge') {\n    throw new InvariantError(\n      \"Dynamic imports should not be instrumented in the edge runtime, because `cacheComponents` doesn't support it\"\n    )\n  }\n\n  if (!isThenable(modulePromise)) {\n    // We're expecting `import()` to always return a promise. If it's not, something's very wrong.\n    throw new InvariantError(\n      '`trackDynamicImport` should always receive a promise. Something went wrong in the dynamic imports transform.'\n    )\n  }\n\n  // Even if we're inside a prerender and have `workUnitStore.cacheSignal`, we always track the promise globally.\n  // (i.e. via the global `moduleLoadingSignal` that `trackPendingImport` uses internally).\n  //\n  // We do this because the `import()` promise might be cached in userspace:\n  // (which is quite common for e.g. lazy initialization in libraries)\n  //\n  //   let promise;\n  //   function doDynamicImportOnce() {\n  //     if (!promise) {\n  //       promise = import(\"...\");\n  //       // transformed into:\n  //       // promise = trackDynamicImport(import(\"...\"));\n  //     }\n  //     return promise;\n  //   }\n  //\n  // If multiple prerenders (e.g. multiple pages) depend on `doDynamicImportOnce`,\n  // we have to wait for the import *in all of them*.\n  // If we only tracked it using `workUnitStore.cacheSignal.trackRead()`,\n  // then only the first prerender to call `doDynamicImportOnce` would wait --\n  // Subsequent prerenders would re-use the existing `promise`,\n  // and `trackDynamicImport` wouldn't be called again in their scope,\n  // so their respective CacheSignals wouldn't wait for the promise.\n  trackPendingImport(modulePromise)\n\n  return modulePromise\n}\n","export { trackDynamicImport } from '../../../../server/app-render/module-loading/track-dynamic-import'\n","type OgModule = typeof import('next/dist/compiled/@vercel/og')\n\nfunction importModule(): Promise<\n  typeof import('next/dist/compiled/@vercel/og')\n> {\n  return import(\n    process.env.NEXT_RUNTIME === 'edge'\n      ? 'next/dist/compiled/@vercel/og/index.edge.js'\n      : 'next/dist/compiled/@vercel/og/index.node.js'\n  )\n}\n\n/**\n * The ImageResponse class allows you to generate dynamic images using JSX and CSS.\n * This is useful for generating social media images such as Open Graph images, Twitter cards, and more.\n *\n * Read more: [Next.js Docs: `ImageResponse`](https://nextjs.org/docs/app/api-reference/functions/image-response)\n */\nexport class ImageResponse extends Response {\n  public static displayName = 'ImageResponse'\n  constructor(...args: ConstructorParameters<OgModule['ImageResponse']>) {\n    const readable = new ReadableStream({\n      async start(controller) {\n        const OGImageResponse: typeof import('next/dist/compiled/@vercel/og').ImageResponse =\n          // So far we have to manually determine which build to use,\n          // as the auto resolving is not working\n          (await importModule()).ImageResponse\n        const imageResponse = new OGImageResponse(...args) as Response\n\n        if (!imageResponse.body) {\n          return controller.close()\n        }\n\n        const reader = imageResponse.body!.getReader()\n        while (true) {\n          const { done, value } = await reader.read()\n          if (done) {\n            return controller.close()\n          }\n          controller.enqueue(value)\n        }\n      },\n    })\n\n    const options = args[1] || {}\n\n    const headers = new Headers({\n      'content-type': 'image/png',\n      'cache-control':\n        process.env.NODE_ENV === 'development'\n          ? 'no-cache, no-store'\n          : 'public, max-age=0, must-revalidate',\n    })\n    if (options.headers) {\n      const newHeaders = new Headers(options.headers)\n      newHeaders.forEach((value, key) => headers.set(key, value))\n    }\n    super(readable, {\n      headers,\n      status: options.status,\n      statusText: options.statusText,\n    })\n  }\n}\n","module.exports = require('./dist/server/og/image-response')\n","import { ImageResponse } from 'next/og';\r\nimport { join } from 'path';\r\nimport { readFile } from 'fs/promises';\r\nimport { existsSync } from 'fs';\r\n\r\nexport type Props = {\r\n  title?: string;\r\n};\r\n\r\nexport default async function OpengraphImage(\r\n  props?: Props\r\n): Promise<ImageResponse> {\r\n  const { title } = {\r\n    ...{\r\n      title: process.env.SITE_NAME\r\n    },\r\n    ...props\r\n  };\r\n\r\n  const file = await readFile(join(process.cwd(), './fonts/Inter-Bold.ttf'));\r\n  const font = Uint8Array.from(file).buffer;\r\n\r\n  // Try to load custom logo if it exists\r\n  let logoDataUrl: string | null = null;\r\n  const logoSvgPath = join(process.cwd(), './public/rokets-logo.svg');\r\n  const logoPngPath = join(process.cwd(), './public/rokets-logo.png');\r\n  \r\n  try {\r\n    if (existsSync(logoSvgPath)) {\r\n      const logoFile = await readFile(logoSvgPath);\r\n      const logoBase64 = logoFile.toString('base64');\r\n      logoDataUrl = `data:image/svg+xml;base64,${logoBase64}`;\r\n    } else if (existsSync(logoPngPath)) {\r\n      const logoFile = await readFile(logoPngPath);\r\n      const logoBase64 = logoFile.toString('base64');\r\n      logoDataUrl = `data:image/png;base64,${logoBase64}`;\r\n    }\r\n  } catch (error) {\r\n    // If logo file can't be read, use fallback\r\n    console.error('Error loading logo:', error);\r\n  }\r\n\r\n  return new ImageResponse(\r\n    (\r\n      <div tw=\"flex h-full w-full flex-col items-center justify-center bg-black\">\r\n        <div tw=\"flex flex-none items-center justify-center border border-neutral-700 h-[160px] w-[160px] rounded-3xl\">\r\n          {logoDataUrl ? (\r\n            <img\r\n              src={logoDataUrl}\r\n              alt=\"Rokets logo\"\r\n              width=\"64\"\r\n              height=\"64\"\r\n              tw=\"object-contain\"\r\n            />\r\n          ) : (\r\n            // Fallback inline SVG logo\r\n            <svg width=\"64\" height=\"58\" viewBox=\"0 0 24 28\" fill=\"white\">\r\n              <path d=\"M12 2L8 10L8 18L12 24L16 18L16 10L12 2Z\" />\r\n              <path d=\"M12 2L10 6L12 10L14 6L12 2Z\" />\r\n              <path d=\"M8 10L4 14L6 16L8 14L8 10Z\" />\r\n              <path d=\"M16 10L16 14L18 16L20 14L16 10Z\" />\r\n              <circle cx=\"12\" cy=\"14\" r=\"1.5\" fill=\"black\" />\r\n              <path d=\"M10 18L12 22L14 18L12 20L10 18Z\" />\r\n            </svg>\r\n          )}\r\n        </div>\r\n        <p tw=\"mt-12 text-6xl font-bold text-white\">{title}</p>\r\n      </div>\r\n    ),\r\n    {\r\n      width: 1200,\r\n      height: 630,\r\n      fonts: [\r\n        {\r\n          name: 'Inter',\r\n          data: font,\r\n          style: 'normal',\r\n          weight: 700\r\n        }\r\n      ]\r\n    }\r\n  );\r\n}\r\n","import OpengraphImage from 'components/opengraph-image';\r\n\r\nexport default async function Image() {\r\n  return await OpengraphImage();\r\n}\r\n","import {  } from \"./opengraph-image.tsx\"\nimport { fillMetadataSegment } from 'next/dist/lib/metadata/get-metadata-route'\n\nconst imageModule = {  }\n\nexport default async function (props) {\n    const { __metadata_id__: _, ...params } = await props.params\n    const imageUrl = fillMetadataSegment(\"/\", params, \"opengraph-image\")\n\n    function getImageMetadata(imageMetadata, idParam) {\n        const data = {\n            alt: imageMetadata.alt,\n            type: imageMetadata.contentType || 'image/png',\n            url: imageUrl + (idParam ? ('/' + idParam) : '') + \"?c48355960a0994c7\",\n        }\n        const { size } = imageMetadata\n        if (size) {\n            data.width = size.width; data.height = size.height;\n        }\n        return data\n    }\n\n    return [getImageMetadata(imageModule, '')]\n}\n"],"names":["isThenable","promise","then","trackDynamicImport","modulePromise","process","env","NEXT_RUNTIME","InvariantError","trackPendingImport","ImageResponse","importModule","Response","displayName","constructor","args","readable","ReadableStream","start","controller","OGImageResponse","imageResponse","body","close","reader","getReader","done","value","read","enqueue","options","headers","Headers","NODE_ENV","newHeaders","forEach","key","set","status","statusText"],"mappings":"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","ignoreList":[0,1,2,3,4]}